{
  "structure": [
    {
      "originalPath": "1. Release Note",
      "name": "Release Note",
      "path": "release-note",
      "type": "folder",
      "children": []
    },
    {
      "originalPath": "3.Getting Started",
      "name": "Getting Started",
      "path": "getting-started",
      "type": "folder",
      "children": [
        {
          "originalPath": "1.Installation.md",
          "id": 1,
          "name": "Installation",
          "type": "file",
          "path": "getting-started/installation",
          "content": "\n# `@dbnx/mysql`\n\nA lightweight MySQL client for Node.js, built on top of `mysql2`, providing a simple and secure way to interact with MySQL databases using prepared statements and connection pooling.\n\n---\n\n## 1. Installation\n\nInstall the `@dbnx/mysql` package and its dependency `mysql2` using npm or yarn.\n\n### Prerequisites\n\nInstall `mysql2`:\n\n```bash\nnpm install mysql2\n```\n\n### Install with npm\n\n```bash\nnpm install @dbnx/mysql\n```\n\n### Install with yarn\n\n```bash\nyarn add @dbnx/mysql\n```\n\n---\n\n## 2. Setup and Configuration\n\nImport the `@dbnx/mysql` package and initialize a database connection with your MySQL credentials.\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Database configuration\nconst dbConfig = {\n  host: 'localhost',\n  user: 'your-username',\n  password: 'your-password',\n  database: 'your-database-name',\n};\n\n// Initialize database instance\nconst dbInstance = new DBnx(dbConfig).connect();\n```\n\n---\n\n## 3. Usage Examples\n\nThe following examples demonstrate common database operations using `@dbnx/mysql`. All queries are executed asynchronously and support prepared statements for security.\n\n### Executing Raw SQL Queries\n\nRun a raw SQL query with parameterized inputs.\n\n```typescript\n(async () => {\n  const result = await dbInstance.execute('SELECT * FROM users WHERE age > ?', [25]);\n  console.log('Query Result:', result);\n})();\n```\n\n### Using Prepared Statements\n\nRetrieve data with a prepared statement for a specific user.\n\n```typescript\n(async () => {\n  const userId = 1;\n  const user = await dbInstance.execute('SELECT * FROM users WHERE id = ?', [userId]);\n  console.log('User Data:', user);\n})();\n```\n\n### Inserting Data\n\nInsert a new record into the database.\n\n```typescript\n(async () => {\n  const result = await dbInstance.execute(\n    'INSERT INTO users (name, email, age) VALUES (?, ?, ?)',\n    ['John Doe', 'john.doe@example.com', 30]\n  );\n  console.log('Insert Result:', result);\n})();\n```\n\n### Updating Data\n\nUpdate an existing record.\n\n```typescript\n(async () => {\n  const result = await dbInstance.execute('UPDATE users SET age = ? WHERE id = ?', [31, 1]);\n  console.log('Update Result:', result);\n})();\n```\n\n### Deleting Data\n\nDelete a record from the database.\n\n```typescript\n(async () => {\n  const result = await dbInstance.execute('DELETE FROM users WHERE id = ?', [1]);\n  console.log('Delete Result:', result);\n})();\n```\n\n---\n\n## 4. Closing the Connection\n\nClose the database connection when it is no longer needed to free up resources.\n\n```typescript\n(async () => {\n  try {\n    await dbInstance.close();\n    console.log('Database connection closed.');\n  } catch (error) {\n    console.error('Error closing connection:', error);\n  }\n})();\n```\n\n---\n\n## 5. Additional Notes\n\n### Error Handling\n\nAlways use `try-catch` blocks to handle errors gracefully during database operations.\n\n```typescript\n(async () => {\n  try {\n    const result = await dbInstance.execute('SELECT * FROM users WHERE id = ?', [1]);\n    console.log('Result:', result);\n  } catch (error) {\n    console.error('Database error:', error);\n  }\n})();\n```\n\n### Connection Pooling\n\nFor high-traffic applications, enable connection pooling to optimize performance. Configure the `connectionLimit` in the `dbConfig`.\n\n```typescript\nconst dbConfig = {\n  host: 'localhost',\n  user: 'your-username',\n  password: 'your-password',\n  database: 'your-database-name',\n  connectionLimit: 10, // Maximum number of connections in the pool\n};\n\nconst dbInstance = new DBnx(dbConfig).connect();\n```\n\n---\n"
        },
        {
          "originalPath": "2.Configuration.md",
          "id": 2,
          "name": "Configuration",
          "type": "file",
          "path": "getting-started/configuration",
          "content": "\n# `@dbnx/mysql` Advanced Features\n\nThis section covers advanced usage of the `@dbnx/mysql` package, including initializing database connections, defining models, executing queries, and leveraging connection pooling. Built on `mysql2`, this package provides a robust and flexible interface for MySQL interactions in Node.js.\n\n---\n\n## 1. Initializing DBnx\n\nThe `DBnx` class is used to establish a MySQL database connection. It supports configuration via a configuration object or a MySQL connection URL, with optional connection pooling.\n\n### Initialization Example\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Database configuration\nconst dbConfig = {\n  host: 'localhost',              // MySQL server hostname (default: 'localhost')\n  user: 'root',                   // MySQL username (default: 'root')\n  password: '11224455',           // MySQL password\n  database: 'world',              // Database name\n  waitForConnections: true,       // Wait for connections when pool is full (default: true)\n  multipleStatements: true,       // Allow multiple SQL statements per query (default: true)\n  connectionLimit: 10,            // Maximum connections in pool (default: 10)\n  queueLimit: 0,                  // Maximum queued connection requests (default: 0, no limit)\n};\n\n// Initialize with connection pooling enabled\nconst db = new DBnx(dbConfig, true).connect((err, success) => {\n  if (err) console.error('Connection error:', err);\n  else console.log('Connected successfully');\n});\n```\n\n### Configuration Options\n\n| Option                | Type      | Description                                                                 | Default         |\n|-----------------------|-----------|-----------------------------------------------------------------------------|-----------------|\n| `host`                | `string`  | MySQL server hostname or IP address.                                        | `'localhost'`   |\n| `user`                | `string`  | MySQL username.                                                             | `'root'`        |\n| `password`            | `string`  | MySQL password.                                                             | `''`            |\n| `database`            | `string`  | Name of the database to connect to.                                         | `undefined`     |\n| `waitForConnections`  | `boolean` | Wait for a connection when the pool is full.                                | `true`          |\n| `multipleStatements`  | `boolean` | Allow multiple SQL statements in a single query.                            | `true`          |\n| `connectionLimit`     | `number`  | Maximum number of connections in the pool.                                  | `10`            |\n| `queueLimit`          | `number`  | Maximum number of queued connection requests (0 = no limit).                | `0`             |\n\n### Connection Pooling\n\nConnection pooling optimizes performance by reusing database connections. Enable or disable pooling using the second argument in the `DBnx` constructor:\n\n- `true`: Enable connection pooling (default).\n- `false`: Disable connection pooling.\n\nExample with pooling disabled:\n\n```typescript\nconst db = new DBnx(dbConfig, false).connect((err, success) => {\n  if (err) console.error('Connection error:', err);\n  else console.log('Connected successfully');\n});\n```\n\n### Connecting with a MySQL URL\n\nYou can initialize `DBnx` using a MySQL connection URL in the format:\n\n```bash\nmysql://user:password@host:port/database\n```\n\n- `user`: MySQL username.\n- `password`: MySQL password.\n- `host`: MySQL server hostname or IP.\n- `port`: MySQL port (default: `3306`).\n- `database`: Database name.\n\n#### Example\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// MySQL connection URL\nconst connectionUrl = 'mysql://root:11224455@localhost:3306/world';\n\n// Initialize with pooling enabled\nconst db = new DBnx(connectionUrl, true).connect((err, success) => {\n  if (err) console.error('Connection error:', err);\n  else console.log('Connected successfully');\n});\n```\n\n---\n\n## 2. Defining Models\n\nThe `Model` class allows you to define the structure of database tables, including fields, data types, constraints, and relationships.\n\n### Model Definition Example\n\n```typescript\nimport { Model } from '@dbnx/mysql';\nimport { db } from './server'; // Import initialized DBnx instance\n\n// Define 'User' model using db.define\nconst User = db.define('User', {\n  username: {\n    type: 'VARCHAR(50)',      // Field data type\n    allowNull: false,         // Field cannot be NULL\n    defaultValue: null,       // Default value\n    unique: true,             // Enforce unique values\n  },\n  created_at: {\n    type: 'TIMESTAMP',        // Field data type\n    defaultValue: 'CURRENT_TIMESTAMP', // Default to current timestamp\n  },\n}, {\n  // Table options (see below)\n});\n\n// Define 'Product' model using Model.init\nconst Product = Model.init('Product', {\n  product_id: {\n    type: 'BIGINT',           // Field data type\n    autoIncrement: true,      // Auto-incrementing ID\n    primaryKey: true,         // Primary key\n    unique: true,             // Enforce unique values\n  },\n  title: {\n    type: 'VARCHAR(255)',     // Field data type\n    defaultValue: null,       // Default value\n  },\n  created_at: {\n    type: 'TIMESTAMP',        // Field data type\n    defaultValue: 'CURRENT_TIMESTAMP', // Default to current timestamp\n  },\n  updated_at: {\n    type: 'TIMESTAMP',        // Field data type\n    allowNull: false,         // Field cannot be NULL\n    defaultValue: 'CURRENT_TIMESTAMP', // Default to current timestamp\n    onUpdate: 'CURRENT_TIMESTAMP', // Update on record change\n  },\n}, db, {\n  // Table options (see below)\n});\n```\n\n### Table Options\n\nTable options can be passed as the third argument to `db.define` or `Model.init`:\n\n```typescript\nexport type TableOptions = {\n  engine?: string;           // Database engine (e.g., 'InnoDB', 'MyISAM')\n  charset?: string;          // Character set (e.g., 'utf8mb4')\n  collation?: string;        // Collation (e.g., 'utf8mb4_unicode_ci')\n  auto_increment?: number;   // Starting value for auto-increment (default: 1)\n};\n```\n\n### Field Properties\n\nEach field in a model can include the following properties:\n\n| Property         | Type      | Description                                                                 |\n|------------------|-----------|-----------------------------------------------------------------------------|\n| `type`           | `string`  | SQL data type (e.g., `VARCHAR(50)`, `BIGINT`, `TIMESTAMP`).                 |\n| `defaultValue`   | `any`     | Default value for the field (e.g., `null`, `'CURRENT_TIMESTAMP'`).          |\n| `allowNull`      | `boolean` | Whether the field can be `NULL` (default: `true`).                          |\n| `unique`         | `boolean` | Enforce unique values for the field.                                       |\n| `primaryKey`     | `boolean` | Mark the field as the primary key.                                         |\n| `autoIncrement`  | `boolean` | Enable auto-increment for the field (e.g., for IDs).                        |\n| `references`     | `string`  | Foreign key reference to another table.                                    |\n| `onUpdate`       | `string`  | Behavior on update (e.g., `'CURRENT_TIMESTAMP'` for timestamps).            |\n| `modifyColumn`   | `string`  | Rename the column to another name.                                        |\n\n### Model Methods\n\n- **`db.define(tableName, fields, options)`**: Define a new model for a table.\n  - `tableName`: Name of the table.\n  - `fields`: Object defining the fields and their properties.\n  - `options`: Table options (e.g., engine, charset).\n\n- **`Model.init(tableName, fields, dbHandler, options)`**: Initialize a model and attach it to the `DBnx` instance.\n  - `tableName`: Name of the table.\n  - `fields`: Field definitions.\n  - `dbHandler`: Initialized `DBnx` instance.\n  - `options`: Table options.\n\n---\n\n## 3. Query Execution with DBnx\n\nExecute raw SQL queries using the `execute` method. Queries are asynchronous and support prepared statements for security.\n\n### Example\n\n```typescript\nconst fetchData = async () => {\n  try {\n    const result = await db.execute('SELECT * FROM users');\n    console.log('Query Result:', result);\n  } catch (error) {\n    console.error('Error executing query:', error);\n  }\n};\n\nfetchData();\n```\n\n- The `execute` method accepts an SQL string and optional parameters for prepared statements.\n- Always use `try-catch` for error handling.\n\n---\n\n## 4. Summary of Key Features\n\n- **Connection Pooling**: Efficiently manage multiple connections with customizable pool settings.\n- **Model Definition**: Define table structures with `db.define` or `Model.init`, supporting advanced field configurations.\n- **Flexible Querying**: Execute raw SQL queries with `execute` for full control.\n- **URL-Based Connections**: Simplify configuration with MySQL connection URLs.\n- **Type Safety**: Define fields with precise data types and constraints.\n\n---\n"
        },
        {
          "originalPath": "3.Logger Function.md",
          "id": 3,
          "name": "Logger Function",
          "type": "file",
          "path": "getting-started/logger-function",
          "content": "\n# `@dbnx/mysql` Constructor\n\nThe `DBnx` constructor initializes a MySQL database connection with flexible configuration options, supporting both single connections and connection pooling. It also allows custom logging for debugging and monitoring.\n\n---\n\n## Constructor Signatures\n\nThe `DBnx` constructor supports multiple signatures to accommodate different use cases:\n\n```typescript\nconstructor(dbConfig: ConnectionOptions | PoolOptions | string, usePool?: boolean, logger?: (log: any) => void)\nconstructor(dbConfig: ConnectionOptions | PoolOptions | string, logger?: (log: any) => void)\nconstructor(dbConfig: ConnectionOptions | PoolOptions | string)\n```\n\n---\n\n## Parameters\n\n| Parameter    | Type                                      | Description                                                                 | Default        |\n|--------------|-------------------------------------------|-----------------------------------------------------------------------------|----------------|\n| `dbConfig`   | `ConnectionOptions | PoolOptions | string` | Database configuration. Can be a configuration object or a MySQL connection URL. | -              |\n| `usePool`    | `boolean` (optional)                      | Enable connection pooling.                                                  | `false`        |\n| `logger`     | `(log: any) => void` (optional)           | Callback function for logging connection events and queries.                | `undefined`    |\n\n### `dbConfig` Details\n\n- **As an Object** (`ConnectionOptions | PoolOptions`):\n  - Includes properties like `host`, `user`, `password`, `database`, `connectionLimit`, etc.\n- **As a String**:\n  - A MySQL connection URL in the format: `mysql://user:password@host:port/database`.\n\n### `usePool`\n\n- `true`: Enables connection pooling for efficient management of multiple connections.\n- `false`: Uses a single connection (default).\n\n### `logger`\n\n- A function that receives log messages (e.g., connection events, query details) for debugging or monitoring.\n\n---\n\n## Example Usage\n\nInitialize a `DBnx` instance with connection pooling and custom logging:\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize with configuration object, pooling, and logging\nconst db = new DBnx(\n  {\n    host: 'localhost',              // MySQL server hostname\n    user: 'root',                   // MySQL username\n    password: '12345678',           // MySQL password\n    database: 'world',              // Database name\n    waitForConnections: true,       // Wait for connections when pool is full\n    multipleStatements: true,       // Allow multiple SQL statements\n    connectionLimit: 10,            // Maximum connections in pool\n    queueLimit: 0,                  // No limit on queued requests\n  },\n  true, // Enable connection pooling\n  (log) => console.log('Log:', log) // Custom logging\n).connect();\n```\n\n---\n\n## Key Features\n\n1. **Flexible Configuration**:\n   - Supports both configuration objects and MySQL connection URLs for easy setup.\n2. **Connection Pooling**:\n   - Optional pooling via the `usePool` parameter, optimizing performance for high-traffic applications.\n3. **Custom Logging**:\n   - Integrates with custom logging systems through the `logger` callback.\n4. **Dynamic Initialization**:\n   - Adapts to various use cases with optional parameters for pooling and logging.\n\n---\n\n## Advanced Configurations\n\n### Using a Connection URL\n\nInitialize with a MySQL connection URL and enable pooling:\n\n```typescript\nconst db = new DBnx(\n  'mysql://root:12345678@localhost:3306/world',\n  true, // Enable pooling\n  (log) => console.log('Log:', log)\n).connect();\n```\n\n### Single Connection without Logging\n\nInitialize a single connection without pooling or logging:\n\n```typescript\nconst db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '12345678',\n  database: 'world',\n}).connect();\n```\n\n### Single Connection with Logging\n\nInitialize a single connection with custom logging:\n\n```typescript\nconst db = new DBnx(\n  {\n    host: 'localhost',\n    user: 'root',\n    password: '12345678',\n    database: 'world',\n  },\n  (log) => console.log('Log:', log)\n).connect();\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "4. Condition.md",
      "id": 4,
      "name": "Condition",
      "type": "file",
      "path": "condition",
      "content": "\n# `@dbnx/mysql` `dbnxCondition`\n\nThe `dbnxCondition` function generates SQL `WHERE` clause conditions from a filters object, supporting a wide range of operators and logical combinations. It is designed to create secure, dynamic SQL queries for use with the `@dbnx/mysql` package.\n\n---\n\n## 1. Importing the Function\n\nImport the `dbnxCondition` function or initialize a `DBnx` instance to use the `condition` method.\n\n```typescript\nimport { dbnxCondition } from '@dbnx/mysql';\n```\n\n### Initializing DBnx for Use with `condition`\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nexport const db = new DBnx({\n  host: 'localhost',              // Database host\n  user: 'root',                   // Database user\n  password: '11224455',           // Database password\n  database: 'world',              // Database name\n  waitForConnections: true,       // Wait for connections when pool is full\n  multipleStatements: true,       // Allow multiple SQL statements\n  connectionLimit: 10,            // Maximum connections in pool\n  queueLimit: 0,                  // No limit on queued requests\n}).connect()\n\n// Example usage with db.condition\nconst result = await db.findOne('users', {\n  where: db.condition({ name: 'dbnx' })\n}).execute();\nconsole.log(result);\n```\n\n---\n\n## 2. Function Signature\n\n```typescript\ndbnxCondition(filters: Filters, joinBy: 'AND' | 'OR' = 'AND'): string\n```\n\n### Parameters\n\n- **`filters`** (`Filters`): An object defining the conditions for the SQL query.\n- **`joinBy`** (`'AND' | 'OR'`, optional): Logical operator to combine top-level conditions. Defaults to `'AND'`.\n\n### Returns\n\n- A `string` representing the SQL `WHERE` clause condition.\n\n---\n\n## 3. Filters Type\n\n### FilterValue Type\n\nThe `FilterValue` type defines the possible values for conditions in the `filters` object:\n\n| Value Type                              | Description                                                                 |\n|-----------------------------------------|-----------------------------------------------------------------------------|\n| `string | number`                       | Equality check (e.g., `status = 'active'`).                                 |\n| `Array<string | number>`                | `IN` check (e.g., `tags IN ('electronics', 'home')`).                      |\n| `{ in: Array<string | number> }`        | Explicit `IN` check (same as array).                                        |\n| `{ notIn: Array<string | number> }`     | `NOT IN` check (e.g., `location NOT IN ('New York', 'California')`).       |\n| `{ between: [number, number] }`         | `BETWEEN` check (e.g., `price BETWEEN 1000 AND 5000`).                     |\n| `{ notBetween: [number, number] }`      | `NOT BETWEEN` check.                                                       |\n| `{ inRange: [number, number] }`         | Range check (alias for `BETWEEN`).                                         |\n| `{ like: string }`                      | `LIKE` check (e.g., `title LIKE '%phone%'`).                               |\n| `{ notLike: string }`                   | `NOT LIKE` check (e.g., `description NOT LIKE '%old%'`).                   |\n| `{ regexp: string }`                    | `REGEXP` check (e.g., `brand REGEXP '^Samsung'`).                          |\n| `{ isNull: boolean }`                   | `IS NULL` or `IS NOT NULL` check (e.g., `updatedAt IS NULL`).              |\n| `{ $or: FilterValue[] }`                | Logical OR condition (e.g., `(color LIKE 'red' OR color LIKE 'blue')`).    |\n| `{ $and: FilterValue[] }`               | Logical AND condition (e.g., `(category = 'electronics' AND brand = 'Samsung')`). |\n| `{ eq: string | number }`               | Equality check (e.g., `status = 'active'`).                                |\n| `{ neq: string | number }`              | Not equal check (e.g., `status != 'inactive'`).                            |\n| `{ gt: number }`                        | Greater than check (e.g., `price > 1000`).                                 |\n| `{ lt: number }`                        | Less than check (e.g., `price < 5000`).                                    |\n| `{ gte: number }`                       | Greater than or equal check (e.g., `price >= 1000`).                       |\n| `{ lte: number }`                       | Less than or equal check (e.g., `price <= 5000`).                          |\n\n### Filters Type\n\nThe `Filters` type represents the structure of the `filters` object, supporting both direct column filters and logical groupings:\n\n```typescript\ntype Filters = {\n  [key: string]: FilterValue; // Direct column filters\n} | {\n  $or?: Record<string, FilterValue>; // Logical OR conditions\n  $and?: Record<string, FilterValue>; // Logical AND conditions\n};\n```\n\n---\n\n## 4. Usage Example\n\nGenerate a complex SQL `WHERE` clause using `dbnxCondition`:\n\n```typescript\nimport { dbnxCondition, Filters } from '@dbnx/mysql';\n\n// Define filters\nconst filters: Filters = {\n  status: 'active',                       // Equality\n  price: { between: [1000, 5000] },      // Range\n  tags: ['electronics', 'home'],         // IN\n  location: { notIn: ['New York', 'California'] }, // NOT IN\n  stock: { inRange: [10, 50] },          // Range\n  updatedAt: { isNull: true },            // NULL check\n  title: { like: '%phone%' },            // Pattern matching\n  description: { notLike: '%old%' },     // Negative pattern\n  color: {\n    $or: [\n      { like: 'red' },\n      { like: 'blue' },\n    ],                                   // OR condition\n  },\n  $and: {\n    category: 'electronics',\n    brand: { regexp: '^Samsung' },       // Regular expression\n  },\n};\n\n// Generate SQL condition\nconst sqlCondition = dbnxCondition(filters, 'AND');\n\nconsole.log(sqlCondition);\n```\n\n### Output\n\n```sql\nstatus = 'active' AND \nprice BETWEEN 1000 AND 5000 AND \ntags IN ('electronics', 'home') AND \nlocation NOT IN ('New York', 'California') AND \nstock BETWEEN 10 AND 50 AND \nupdatedAt IS NULL AND \ntitle LIKE '%phone%' AND \ndescription NOT LIKE '%old%' AND \n(color LIKE 'red' OR color LIKE 'blue') AND \n(category = 'electronics' AND brand REGEXP '^Samsung')\n```\n\n### Integration with DBnx\n\nUse the generated condition in a query:\n\n```typescript\nconst result = await db.findOne('products', {\n  where: db.condition(filters)\n}).execute();\nconsole.log(result);\n```\n\n---\n\n## 5. Function Details\n\n1. **Supported Conditions**:\n   - Equality (`eq`, direct string/number values).\n   - Inequality (`neq`, `gt`, `lt`, `gte`, `lte`).\n   - List checks (`in`, `notIn`).\n   - Range checks (`between`, `notBetween`, `inRange`).\n   - Pattern matching (`like`, `notLike`, `regexp`).\n   - NULL checks (`isNull`).\n   - Logical groupings (`$and`, `$or`).\n\n2. **Logical Operators**:\n   - Top-level conditions are combined using `joinBy` (`AND` or `OR`).\n   - Nested conditions use `$and` or `$or` for complex logic.\n\n3. **Security**:\n   - Inputs are sanitized to prevent SQL injection, ensuring safe query generation.\n\n---\n\n## 6. Notes\n\n- Use `db.condition()` when working with an initialized `DBnx` instance, or `dbnxCondition` as a standalone function.\n- Combine multiple logical operators (`$and`, `$or`) for complex queries.\n- Ensure filter values match the expected column types to avoid SQL errors.\n- The function is designed for `WHERE` clauses but can be adapted for other SQL clauses with manual concatenation.\n\n---\n"
    },
    {
      "originalPath": "5.Model",
      "name": "Model",
      "path": "model",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Create Model.md",
          "id": 5,
          "name": "Create Model",
          "type": "file",
          "path": "model/create-model",
          "content": "\n# `@dbnx/mysql` Dynamic Model\n\nThe `@dbnx/mysql` package provides a flexible and powerful way to define database models dynamically using the `Model` class. Models represent database tables, allowing you to specify column types, constraints, relationships, and table options. This documentation covers model definition, configuration, and common CRUD operations.\n\n---\n\n## 1. Dependencies\n\nTo define models, you need the following components from `@dbnx/mysql`:\n\n- **`DBnx`**: Manages database connections and executes SQL commands.\n- **`Model`**: Base class for defining table structures.\n- **`DataTypes`**: Utility for specifying column data types.\n\n### Example: Initialize DBnx\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nexport const db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '11224455',\n  database: 'world',\n  waitForConnections: true,    // Wait for connections when pool is full\n  multipleStatements: true,    // Allow multiple SQL statements\n  connectionLimit: 10,         // Maximum connections in pool\n  queueLimit: 0,               // No limit on queued requests\n}).connect();\n```\n\n---\n\n## 2. Model Definition\n\nModels are defined using either `Model.init` or `db.define`, specifying table name, column configurations, and optional table settings.\n\n### Example: Product Model\n\nDefine a `product` table using `Model.init`:\n\n```typescript\nimport { Model } from '@dbnx/mysql';\n\nconst Product = Model.init('product', {\n  product_id: {\n    type: 'BIGINT',\n    autoIncrement: true,\n    primaryKey: true,\n    unique: true,\n  },\n  title: {\n    type: 'VARCHAR(255)',\n    defaultValue: null,\n  },\n  brand: {\n    type: 'VARCHAR(255)',\n    defaultValue: 'hello',\n  },\n  created_at: {\n    type: 'TIMESTAMP',\n    defaultValue: 'CURRENT_TIMESTAMP',\n  },\n  updated_at: {\n    type: 'TIMESTAMP',\n    allowNull: false,\n    defaultValue: 'CURRENT_TIMESTAMP',\n    onUpdate: 'CURRENT_TIMESTAMP',\n  },\n}, db);\n```\n\n### Example: Users Model\n\nDefine a `users` table using `db.define` with advanced options:\n\n```typescript\nimport { DataTypes } from '@dbnx/mysql';\n\nconst Users = db.define('users', {\n  username: {\n    type: DataTypes.SMALLINT(),\n    defaultValue: null,\n    unique: true,\n  },\n  city: {\n    type: DataTypes.INT(),\n    allowNull: true,\n    references: {\n      model: 'city',\n      key: 'ID',\n      onDelete: 'SET NULL',\n      onUpdate: 'CASCADE',\n    },\n  },\n  status: {\n    type: DataTypes.ENUM(),\n    values: ['active', 'inactive'],\n  },\n  created_at: {\n    type: DataTypes.TIMESTAMP(),\n    onUpdate: 'CURRENT_TIMESTAMP',\n  },\n}, {\n  auto_increment: 100,\n  charset: 'utf8mb4',\n  collation: 'utf8mb4_unicode_ci',\n});\n```\n\n### Table Options\n\nTable options customize the table's properties:\n\n```typescript\ntype TableOptions = {\n  engine?: string;           // e.g., 'InnoDB', 'MyISAM'\n  charset?: string;          // e.g., 'utf8mb4'\n  collation?: string;        // e.g., 'utf8mb4_unicode_ci'\n  auto_increment?: number;   // Starting value for auto-increment (default: 1)\n};\n```\n\n### Column Options\n\nEach column in a model can include the following properties:\n\n| Property         | Type                                      | Description                                                                 |\n|------------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `type`           | `string`                                  | Data type (e.g., `VARCHAR(255)`, `BIGINT`, `TIMESTAMP`).                    |\n| `modifyColumn`   | `string`                                  | Rename the column in the database.                                         |\n| `onUpdate`       | `string \\| 'CURRENT_TIMESTAMP'`            | Action on update (e.g., `CURRENT_TIMESTAMP` for timestamps).                |\n| `allowNull`      | `boolean`                                 | Allow `NULL` values (default: `true`).                                     |\n| `primaryKey`     | `boolean`                                 | Mark as primary key.                                                       |\n| `autoIncrement`  | `boolean`                                 | Enable auto-increment.                                                     |\n| `defaultValue`   | `string | number \\| 'CURRENT_TIMESTAMP' \\| null` \\| Default value for the column.                                              |\n| `references`     | `object \\| string`                         | Foreign key configuration (model, key, `onDelete`, `onUpdate`).          |\n| `unique`         | `boolean`                                 | Enforce unique values.                                                     |\n| `values`         | `string[]`                                | Allowed values for `ENUM` types.                                           |\n\n```typescript\nexport type ColumnOptions = {\n  modifyColumn?: string;\n  type: string;\n  allowNull?: boolean;\n  primaryKey?: boolean;\n  autoIncrement?: boolean;\n  onUpdate?: string | 'CURRENT_TIMESTAMP';\n  defaultValue?: string | number | 'CURRENT_TIMESTAMP' | null;\n  references?: string | {\n    model: string | typeof Model;\n    onUpdate?: 'CASCADE' | 'SET NULL' | 'NO ACTION' | 'RESTRICT';\n    onDelete?: 'CASCADE' | 'SET NULL' | 'NO ACTION' | 'RESTRICT';\n    key: string;\n  };\n  unique?: boolean;\n  values?: readonly string[];\n};\n```\n\n### Return Properties\n\nA defined model provides the following properties:\n\n- **`ddlQuery`**: SQL `CREATE TABLE` statement.\n- **`database`**: SQL statement for table creation (alias for `ddlQuery`).\n- **`modelAttributes`**: Object containing column configurations.\n- **`tableOptions`**: Table settings (e.g., engine, charset).\n- **`dbInstance`**: Associated `DBnx` instance.\n- **`tableName`**: Name of the table.\n- **`dbTableIdentifier`**: Table identifier in the database.\n\n---\n\n## 3. Usage Examples\n\n### Changing a Column Name\n\nRename a column using `modifyColumn`:\n\n```typescript\nconst Product = Model.init('product', {\n  brand_name: {\n    modifyColumn: 'brand',       // Rename 'brand' to 'brand_name'\n    type: 'VARCHAR(255)',\n    defaultValue: 'hello',\n  },\n}, db);\n```\n\n### Creating a Table\n\nGenerate and execute the `CREATE TABLE` statement:\n\n```typescript\nconsole.log(Product.ddlQuery); // Output the SQL CREATE TABLE query\nawait Product.sync();           // Execute the CREATE TABLE query\n```\n\n### Adding Foreign Key Constraints\n\nDefine a foreign key relationship:\n\n```typescript\nconst Orders = db.define('orders', {\n  product_id: {\n    type: 'BIGINT',\n    allowNull: false,\n    references: {\n      model: Product,          // Reference the Product model\n      key: 'product_id',\n      onDelete: 'CASCADE',\n      onUpdate: 'CASCADE',\n    },\n  },\n});\n```\n\n**Alternative (using table name)**:\n\n```typescript\nconst Orders = db.define('orders', {\n  product_id: {\n    type: 'BIGINT',\n    allowNull: false,\n    references: {\n      model: 'product',        // Reference the product table\n      key: 'product_id',\n      onDelete: 'CASCADE',\n      onUpdate: 'CASCADE',\n    },\n  },\n});\n```\n\n### CRUD Operations\n\n#### Create\n\nInsert a new record:\n\n```typescript\n(async () => {\n  const result = await Users.create({\n    username: 'John Doe',\n    city: 1,\n    status: 'active',\n  });\n  console.log('Record created:', result);\n})();\n```\n\n#### Find All\n\nRetrieve multiple records with optional pagination:\n\n```typescript\n(async () => {\n  const records = await Users.findAll({\n    limitSkip: { limit: 10, skip: 0 },\n  });\n  console.log('Found records:', records);\n})();\n```\n\n#### Find One\n\nRetrieve a single record:\n\n```typescript\n(async () => {\n  const record = await Users.findOne();\n  console.log('Single record found:', record);\n})();\n```\n\n#### Update\n\nUpdate records based on a condition:\n\n```typescript\n(async () => {\n  const result = await Users.update({\n    where: `username = 'John Doe'`,\n    values: { status: 'inactive' },\n  });\n  console.log('Record updated:', result);\n})();\n```\n\n#### Delete\n\nDelete records based on a condition:\n\n```typescript\n(async () => {\n  const result = await Users.delete({\n    where: `username = 'John Doe'`,\n  });\n  console.log('Record deleted:', result);\n})();\n```\n\n### Retrieving Engine Options\n\nAccess table configuration options:\n\n```typescript\nconsole.log(Users.getEngineOptions());\n// Outputs: { engine: 'InnoDB', charset: 'utf8mb4', collation: 'utf8mb4_unicode_ci', auto_increment: 100 }\n```\n\n---\n"
        },
        {
          "originalPath": "2. DataTypes.md",
          "id": 6,
          "name": "DataTypes",
          "type": "file",
          "path": "model/datatypes",
          "content": "\n# `@dbnx/mysql` Model Definition and DataTypes\n\nThe `@dbnx/mysql` package provides a robust interface for defining database models using the `db.define()` method and `DataTypes` utility. Models represent database tables, allowing you to specify column types, constraints, relationships, and default values. The `DataTypes` object simplifies schema design by mapping JavaScript methods to MySQL column types.\n\n---\n\n## 1. Defining Models\n\nUse the `db.define()` method to create a model, specifying the table name, column configurations, and optional table options.\n\n### Example: Users Model\n\n```javascript\nconst { DBnx, DataTypes } = require('@dbnx/mysql');\n\n// Initialize DBnx instance\nconst db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '11224455',\n  database: 'world',\n  waitForConnections: true,\n  multipleStatements: true,\n  connectionLimit: 10,\n  queueLimit: 0,\n}).connect();\n\nconst Users = db.define('users', {\n  username: {\n    type: DataTypes.STRING(150),\n    unique: true,\n    allowNull: false,\n    defaultValue: null,\n  },\n  city: {\n    type: DataTypes.INT(),\n    allowNull: true,\n    references: {\n      model: 'city',\n      key: 'ID',\n      onDelete: 'SET NULL',\n      onUpdate: 'CASCADE',\n    },\n  },\n  status: {\n    type: DataTypes.ENUM('active', 'inactive'),\n    defaultValue: 'inactive',\n  },\n  created_at: {\n    type: DataTypes.TIMESTAMP(),\n    onUpdate: 'CURRENT_TIMESTAMP',\n  },\n});\n```\n\n---\n\n## 2. DataTypes\n\nThe `DataTypes` object provides methods to define MySQL column types in a JavaScript-friendly way. Each method maps to a corresponding MySQL data type, with optional parameters for customization.\n\n### String Types\n\n- **`STRING(size = 250)`**: Variable-length string (`VARCHAR`).  \n  Example: `DataTypes.STRING(100)` → `VARCHAR(100)`\n\n- **`CHAR(size = 35)`**: Fixed-length string (`CHAR`).  \n  Example: `DataTypes.CHAR(10)` → `CHAR(10)`\n\n- **`TEXT(type = 'TEXT')`**: Large text field.  \n  Options: `'TINYTEXT'`, `'TEXT'`, `'MEDIUMTEXT'`, `'LONGTEXT'`.  \n  Example: `DataTypes.TEXT('MEDIUMTEXT')` → `MEDIUMTEXT`\n\n### Numeric Types\n\n- **`TINYINT(unsigned = false)`**: Tiny integer (1 byte).  \n  Example: `DataTypes.TINYINT(true)` → `TINYINT UNSIGNED`\n\n- **`SMALLINT(unsigned = false)`**: Small integer (2 bytes).  \n  Example: `DataTypes.SMALLINT()` → `SMALLINT`\n\n- **`INT(unsigned = false)`**: Standard integer (4 bytes).  \n  Example: `DataTypes.INT(true)` → `INT UNSIGNED`\n\n- **`BIGINT(unsigned = false)`**: Large integer (8 bytes).  \n  Example: `DataTypes.BIGINT()` → `BIGINT`\n\n- **`DECIMAL(precision = 10, scale = 0)`**: Fixed-point decimal.  \n  Example: `DataTypes.DECIMAL(12, 4)` → `DECIMAL(12, 4)`\n\n### Date and Time Types\n\n- **`TIMESTAMP()`**: Timestamp with optional auto-update.  \n  Example: `DataTypes.TIMESTAMP()` → `TIMESTAMP`\n\n- **`DATE()`**: Date without time.  \n  Example: `DataTypes.DATE()` → `DATE`\n\n### Enumerations\n\n- **`ENUM(...values)`**: Enum with specific values.  \n  Example: `DataTypes.ENUM('active', 'inactive')` → `ENUM('active', 'inactive')`\n\n### Binary Types\n\n- **`BINARY(size = 16)`**: Fixed-length binary data.  \n  Example: `DataTypes.BINARY(32)` → `BINARY(32)`\n\n- **`VARBINARY(size = 255)`**: Variable-length binary data.  \n  Example: `DataTypes.VARBINARY(100)` → `VARBINARY(100)`\n\n- **`BLOB(type = 'BLOB')`**: Binary large object.  \n  Options: `'TINYBLOB'`, `'BLOB'`, `'MEDIUMBLOB'`, `'LONGBLOB'`.  \n  Example: `DataTypes.BLOB('LONGBLOB')` → `LONGBLOB`\n\n### JSON Type\n\n- **`JSON()`**: JSON-formatted data.  \n  Example: `DataTypes.JSON()` → `JSON`\n\n### DataTypes Reference\n\n| Type                  | Description                                                                 | Example                              |\n|-----------------------|-----------------------------------------------------------------------------|--------------------------------------|\n| `STRING(size)`        | Variable-length string (`VARCHAR`). Default: 250.                           | `DataTypes.STRING(150)`             |\n| `CHAR(size)`          | Fixed-length string (`CHAR`). Default: 35.                                  | `DataTypes.CHAR(20)`                |\n| `TEXT(type)`          | Large text field (`TINYTEXT`, `TEXT`, `MEDIUMTEXT`, `LONGTEXT`).            | `DataTypes.TEXT('LONGTEXT')`        |\n| `TINYINT(unsigned)`   | Tiny integer (1 byte). Optional unsigned.                                   | `DataTypes.TINYINT(true)`           |\n| `SMALLINT(unsigned)`  | Small integer (2 bytes). Optional unsigned.                                 | `DataTypes.SMALLINT()`              |\n| `INT(unsigned)`       | Standard integer (4 bytes). Optional unsigned.                              | `DataTypes.INT(true)`               |\n| `BIGINT(unsigned)`    | Large integer (8 bytes). Optional unsigned.                                 | `DataTypes.BIGINT()`                |\n| `DECIMAL(p, s)`       | Fixed-point decimal with precision `p`, scale `s`. Default: `(10, 0)`.     | `DataTypes.DECIMAL(12, 4)`          |\n| `TIMESTAMP()`         | Timestamp with optional auto-update.                                       | `DataTypes.TIMESTAMP()`             |\n| `DATE()`              | Date without time.                                                         | `DataTypes.DATE()`                  |\n| `ENUM(...values)`     | Enum with specific values.                                                 | `DataTypes.ENUM('active', 'inactive')` |\n| `BINARY(size)`        | Fixed-length binary data. Default: 16.                                      | `DataTypes.BINARY(32)`              |\n| `VARBINARY(size)`     | Variable-length binary data. Default: 255.                                  | `DataTypes.VARBINARY(100)`          |\n| `BLOB(type)`          | Binary large object (`TINYBLOB`, `BLOB`, `MEDIUMBLOB`, `LONGBLOB`).         | `DataTypes.BLOB('LONGBLOB')`        |\n| `JSON()`              | JSON-formatted data.                                                       | `DataTypes.JSON()`                  |\n\n---\n\n## 3. Advanced Features\n\n### Relationships\n\nDefine foreign key relationships using the `references` field:\n\n```javascript\ncity: {\n  type: DataTypes.INT(),\n  allowNull: true,\n  references: {\n    model: 'city',\n    key: 'ID',\n    onDelete: 'SET NULL',\n    onUpdate: 'CASCADE',\n  },\n}\n```\n\n- **`model`**: Referenced table name or model.\n- **`key`**: Referenced column.\n- **`onDelete`**: Action on deletion (`CASCADE`, `SET NULL`, `NO ACTION`, `RESTRICT`).\n- **`onUpdate`**: Action on update (`CASCADE`, `SET NULL`, `NO ACTION`, `RESTRICT`).\n\n### Default Values\n\nSet default values for columns to ensure consistent data:\n\n```javascript\nstatus: {\n  type: DataTypes.ENUM('active', 'inactive'),\n  defaultValue: 'inactive',\n}\n```\n\n---\n\n## 4. Example: CRUD Operations\n\nPerform common database operations using the model.\n\n### Create a User\n\nInsert a new record:\n\n```javascript\nawait Users.create({\n  username: 'john_doe',\n  city: 1,\n  status: 'active',\n});\n```\n\n### Find Users\n\nRetrieve all records:\n\n```javascript\nconst allUsers = await Users.findAll();\n```\n\n### Update a User\n\nUpdate records based on a condition:\n\n```javascript\nawait Users.update({\n  values: { status: 'inactive' },\n  where: \"username = 'john_doe'\",\n});\n```\n\n### Delete a User\n\nDelete records based on a condition:\n\n```javascript\nawait Users.delete({\n  where: \"username = 'john_doe'\",\n});\n```\n\n---\n"
        },
        {
          "originalPath": "3. Synchronize Database Model.md",
          "id": 7,
          "name": "Synchronize Database Model",
          "type": "file",
          "path": "model/synchronize-database-model",
          "content": "\n# `@dbnx/mysql` SYNC Database Model Documentation\n\nThis guide explains how to set up and synchronize a MySQL database using the `@dbnx/mysql` package in a Node.js application. It covers establishing a database connection, defining table models, and synchronizing the schema with raw SQL queries. The process is split into three key files: `database.js`, `models.js`, and `syncDatabase.js`.\n\n---\n\n## 1. Database Connection (`database.js`)\n\nThe `database.js` file establishes a connection to a MySQL database using the `DBnx` class from `@dbnx/mysql`.\n\n### Code\n\n```javascript\n// database.js\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nexport const db = new DBnx({\n  host: 'localhost',              // Database host\n  user: 'root',                   // Database user\n  password: '11224455',           // Database password\n  database: 'world',              // Database name\n  waitForConnections: true,       // Wait for connections when pool is full\n  multipleStatements: true,       // Allow multiple SQL statements\n  connectionLimit: 10,            // Maximum connections in pool\n  queueLimit: 0,                  // No limit on queued requests\n}).connect();\n```\n\n### Parameters\n\n| Parameter              | Type      | Description                                                                 | Default       |\n|------------------------|-----------|-----------------------------------------------------------------------------|---------------|\n| `host`                 | `string`  | MySQL server hostname or IP address.                                        | `'localhost'` |\n| `user`                 | `string`  | MySQL username.                                                             | `'root'`      |\n| `password`             | `string`  | MySQL password.                                                             | `''`          |\n| `database`             | `string`  | Name of the database to connect to.                                         | `undefined`   |\n| `waitForConnections`   | `boolean` | Wait for a connection when the pool is full.                                | `true`        |\n| `multipleStatements`   | `boolean` | Allow multiple SQL statements in a single query.                            | `true`        |\n| `connectionLimit`      | `number`  | Maximum number of connections in the pool.                                  | `10`          |\n| `queueLimit`           | `number`  | Maximum number of queued connection requests (0 = no limit).                | `0`           |\n\n### Methods\n\n- **`db.connect()`**: Establishes the database connection. Returns a promise that resolves when connected.\n- **`db.close()`**: Closes the database connection, freeing resources.\n\n---\n\n## 2. Model Definition (`models.js`)\n\nThe `models.js` file defines table schemas using the `db.define()` method. Models specify the structure of tables, including columns, data types, and constraints.\n\n### Code\n\n```javascript\n// models.js\nimport { db } from './database.js';\n\n// Define the UserModel for the 'users' table\nexport const UserModel = db.define('users', {\n  username: {\n    type: 'VARCHAR(50)',         // Variable-length string\n    allowNull: false,            // Cannot be NULL\n    unique: true,                // Enforce unique values\n    defaultValue: null,          // Default value\n  },\n  code: {\n    type: 'CHAR(3)',             // Fixed-length string\n    allowNull: true,             // Allow NULL values\n  },\n  created_at: {\n    type: 'TIMESTAMP',            // Timestamp column\n    defaultValue: 'CURRENT_TIMESTAMP', // Auto-set to current timestamp\n  },\n});\n```\n\n### Field Parameters\n\n| Parameter        | Type                                      | Description                                                                 |\n|------------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `type`           | `string`                                  | MySQL data type (e.g., `VARCHAR(50)`, `CHAR(3)`, `TIMESTAMP`).              |\n| `allowNull`      | `boolean`                                 | Allow `NULL` values (default: `true`).                                     |\n| `defaultValue`   | `string \\| number \\| 'CURRENT_TIMESTAMP' \\| null` | Default value for the column.                                              |\n| `unique`         | `boolean`                                 | Enforce unique values.                                                     |\n| `references`     | `object \\| string`                         | Foreign key configuration (e.g., `{ model: 'table', key: 'column' }`).     |\n\n---\n\n## 3. Database Synchronization (`syncDatabase.js`)\n\nThe `syncDatabase.js` file synchronizes the database schema by creating or updating tables based on defined models. It supports both non-destructive and force synchronization.\n\n### Basic Sync\n\nCreate tables if they don’t exist without modifying existing tables.\n\n```javascript\n// syncDatabase.js\nimport { UserModel, PostModel } from './models.js';\n\nasync function syncDatabase() {\n  try {\n    // Synchronize models (create tables if they don't exist)\n    await UserModel.sync(); // Sync users table\n    await PostModel.sync(); // Sync posts table\n    console.log('Database synchronized successfully.');\n  } catch (error) {\n    console.error('Error syncing database:', error);\n  } finally {\n    await db.close(); // Close database connection\n  }\n}\n\nsyncDatabase();\n```\n\n### Force Sync\n\nDrop and recreate tables, even if they exist.\n\n```javascript\n// syncDatabase.js\nimport { UserModel, PostModel } from './models.js';\n\nasync function syncDatabase() {\n  try {\n    // Force sync: Drop and recreate tables\n    await UserModel.sync(true); // Drop and recreate users table\n    await PostModel.sync(true); // Drop and recreate posts table\n    console.log('Database synchronized successfully.');\n  } catch (error) {\n    console.error('Error syncing database:', error);\n  } finally {\n    await db.close(); // Close database connection\n  }\n}\n\nsyncDatabase();\n```\n\n### Sync Methods\n\n- **`sync(force?: boolean)`**: Synchronizes the table schema.\n  - **`force: false`** (default): Creates the table if it doesn’t exist; no changes to existing tables.\n  - **`force: true`**: Drops the existing table and recreates it, potentially causing data loss.\n\n---\n\n## 4. Common Errors & Troubleshooting\n\n1. **Connection Errors**:\n   - **Cause**: Incorrect credentials, MySQL service not running, or network issues.\n   - **Solution**:\n     - Verify credentials in `database.js`.\n     - Check MySQL service: `sudo systemctl status mysql`.\n     - Ensure no firewall or permission issues block the connection.\n\n2. **Table Already Exists**:\n   - **Cause**: Attempting to create a table that already exists without `force: true`.\n   - **Solution**: Use `sync(true)` to drop and recreate the table, or ensure the table name is unique.\n\n3. **Type Mismatch**:\n   - **Cause**: Model data types (e.g., `VARCHAR(50)`) don’t match database constraints.\n   - **Solution**: Verify that model definitions align with MySQL requirements.\n\n4. **Missing Dependencies**:\n   - **Cause**: `@dbnx/mysql` or `mysql2` not installed.\n   - **Solution**: Install dependencies:\n\n```bash\nnpm install @dbnx/mysql mysql2\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "6.CRUD operations",
      "name": "CRUD Operations",
      "path": "crud-operations",
      "type": "folder",
      "children": [
        {
          "originalPath": "1.Create.md",
          "id": 8,
          "name": "Create",
          "type": "file",
          "path": "crud-operations/create",
          "content": "\n# `@dbnx/mysql` Create/Insert Operation\n\nThe `@dbnx/mysql` package provides a powerful `create` method for inserting records into a MySQL database. This method supports single and batch insertions, customizable conflict handling, and query generation for both model-based and direct table operations.\n\n---\n\n## 1. Creating a Model\n\nBefore performing insert operations, define a model using the `db.define()` method to specify the table schema.\n\n### Example: User Model\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nconst db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '11224455',\n  database: 'world',\n  waitForConnections: true,\n  multipleStatements: true,\n  connectionLimit: 10,\n  queueLimit: 0,\n}).connect();\n\n// Define User model\nconst User = db.define('User', {\n  username: {\n    type: 'VARCHAR(50)',\n    allowNull: false,\n    unique: true,\n    defaultValue: null,\n  },\n  created_at: {\n    type: 'TIMESTAMP',\n    defaultValue: 'CURRENT_TIMESTAMP',\n  },\n});\n```\n\n---\n\n## 2. Static Method: `create`\n\nThe static `create` method on a model inserts one or more records into the associated table.\n\n### Signature\n\n```typescript\nstatic async create(\n  values: CreateParamsType<[]>,\n  options?: InsertIntoOptionsType\n): Promise<ResponseType>\n```\n\n- **Single row**: `{ name: 'John', age: 30 }`\n- **Multiple rows**: `[{ name: 'Alice', age: 25 }, { name: 'Bob', age: 28 }]`\n\n### Parameters\n\n| Name      | Type                    | Description                                                                 |\n|-----------|-------------------------|-----------------------------------------------------------------------------|\n| `values`  | `CreateParamsType<[]>`  | Data to insert. Can be a single object or an array of objects.              |\n| `options` | `InsertIntoOptionsType` | Optional settings for uniqueness constraints or duplicate key handling.     |\n\n### Returns\n\n- A `Promise` resolving to a `ResponseType` object containing details like the number of inserted rows or any errors.\n\n### Usage Example\n\n```typescript\n// Single record\nconst result = await User.create(\n  { username: 'John Doe', email: 'john@example.com' },\n  { uniqueColumn: 'email' }\n);\nconsole.log(result); // Logs database response\n```\n\n```typescript\n// Using db.create with model\nconst result = await db.create(\n  User,\n  { username: 'John Doe', email: 'john@example.com' },\n  { uniqueColumn: 'email' }\n);\nconsole.log(result); // Logs database response\n```\n\n---\n\n## 3. Instance Method: `create`\n\nThe instance `create` method on a `DBnx` instance inserts data into a specified table, offering chainable query building.\n\n### Signature\n\n```typescript\ncreate(\n  table: string | typeof Model,\n  values: CreateParamsType<[]>,\n  options?: InsertIntoOptionsType\n): DBnx | Promise<ResponseType>\n```\n\n### Parameters\n\n| Name      | Type                    | Description                                                                 |\n|-----------|-------------------------|-----------------------------------------------------------------------------|\n| `table`   | `string \\| typeof Model` | Name of the table or model to insert data into.                            |\n| `values`  | `CreateParamsType<[]>`  | Data to insert. Can be a single object or an array of objects.              |\n| `options` | `InsertIntoOptionsType` | Optional settings for uniqueness or duplicate key handling.                 |\n\n### Returns\n\n- **Chainable**: Returns the `DBnx` instance for query chaining (e.g., with `.build()` or `.execute()`).\n- **Execution**: Returns a `Promise` resolving to a `ResponseType` when executed.\n\n### Usage Example\n\n```typescript\n// Single record insertion\nconst result = await db.create(\n  'users',\n  { username: 'Alice', age: 30 },\n  { onDuplicateUpdateFields: ['age'] }\n).execute();\nconsole.log(result); // Logs execution result\n```\n\n```typescript\n// View generated query\nconst query = await db.create(\n  'users',\n  { username: 'Alice', age: 30 },\n  { onDuplicateUpdateFields: ['age'] }\n).build();\nconsole.log(query); // Logs raw SQL query\n```\n\n---\n\n## 4. Options for `create`\n\nCustomize insert operations with the following options:\n\n| Option                     | Type                | Description                                                                 |\n|----------------------------|---------------------|-----------------------------------------------------------------------------|\n| `uniqueColumn`             | `string \\| null`     | Enforce uniqueness for the specified column.                               |\n| `onDuplicateUpdateFields`  | `string[]`          | Fields to update if a duplicate key conflict occurs.                        |\n\n---\n\n## 5. Types\n\n### CreateParamsType\n\nDefines the structure of the `values` parameter:\n\n```typescript\ntype CreateParamsType<columns extends any[]> =\n  | { [P in columns[number]]?: string[] }\n  | Record<string, string | number>\n  | { [P in columns[number]]?: string[] }[];\n```\n\n- **Single record**: `Record<string, string | number>` (e.g., `{ name: 'John', age: 30 }`).\n- **Multiple records**: Array of objects (e.g., `[{ name: 'Alice', age: 25 }, { name: 'Bob', age: 28 }]`).\n\n### InsertIntoOptionsType\n\nDefines optional settings for insert operations:\n\n```typescript\ntype InsertIntoOptionsType = {\n  uniqueColumn?: string | null;\n  onDuplicateUpdateFields?: string[];\n};\n```\n\n---\n\n## 6. Common Errors & Troubleshooting\n\n| Error Message                         | Cause                                           | Solution                                                                 |\n|---------------------------------------|-------------------------------------------------|--------------------------------------------------------------------------|\n| `Values must be a non-empty object.`  | Empty or invalid `values` parameter.            | Ensure `values` is a non-empty object or array of objects.               |\n| `Expected a table name and/or values.`| Missing table name or values.                   | Provide a valid table name/model and `values` object.                    |\n| `Duplicate entry for key 'PRIMARY'`   | Duplicate data violates a unique constraint.    | Use `onDuplicateUpdateFields` or adjust data to avoid conflicts.         |\n\n---\n\n## 7. Advanced Features\n\n### Batch Insert\n\nInsert multiple records efficiently to optimize performance for large datasets:\n\n```typescript\nconst result = await db.create(\n  'users',\n  [\n    { username: 'Alice', age: 30 },\n    { username: 'Bob', age: 25 },\n    { username: 'Charlie', age: 35 },\n  ]\n).execute();\nconsole.log(result); // Logs batch insertion result\n```\n\n### On Duplicate Key Updates\n\nUpdate specific fields when a duplicate key conflict occurs:\n\n```typescript\nconst result = await db.create(\n  'users',\n  { username: 'John', age: 30 },\n  { onDuplicateUpdateFields: ['age'] }\n).execute();\nconsole.log(result); // Logs result after updating 'age' on conflict\n```\n\n### Custom Conflict Handling\n\nUse `onDuplicateUpdateFields` to define which fields to update on duplicate key conflicts, providing fine-grained control over insertion behavior.\n\n---\n"
        },
        {
          "originalPath": "2.Find",
          "name": "Find",
          "path": "crud-operations/2find",
          "type": "folder",
          "children": [
            {
              "originalPath": "1.FindOne.md",
              "id": 9,
              "name": "FindOne",
              "type": "file",
              "path": "crud-operations/find/findone",
              "content": "\n# `@dbnx/mysql` findOne Function\n\nThe `findOne` function in `@dbnx/mysql` retrieves a single record from a MySQL database table or model. It supports flexible query configuration, including filtering, sorting, grouping, joins, subqueries, aggregates, and recursive common table expressions (CTEs). This makes it ideal for both simple and complex data retrieval tasks.\n\n---\n\n## 1. Overview\n\nThe `findOne` function is designed to fetch a single record from a database, offering extensive customization through the `FindOneParamsType` interface. It supports both table-based queries (using a table name) and model-based queries (using a model class), providing flexibility for raw SQL and ORM-style operations.\n\n---\n\n## 2. FindOneParamsType\n\n### Type Definition\n\nThe `FindOneParamsType` interface defines the configuration options for the `findOne` function.\n\n```typescript\nexport interface FindOneParamsType<Tables extends string[]> {\n  distinct?: boolean;\n  sort?: SortType<Tables>;\n  columns?: {\n    [P in Tables[number]]?: string[];\n  } | { extra?: string | string[] } | string | string[];\n  groupBy?: {\n    [P in Tables[number]]?: string[];\n  } | { extra?: string | string[] } | string | string[];\n  aggregates?: Array<{\n    [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string;\n  } | { alias?: string }>;\n  where?: string;\n  having?: string;\n  subQueries?: {\n    query: string;\n    as?: string;\n  }[];\n  joins?: JoinsType<Tables>;\n  recursiveCTE?: { baseCase: string; recursiveCase: string; alias: string };\n}\n```\n\n### Key Parameters\n\n| Parameter       | Type                                      | Description                                                                 |\n|-----------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `distinct`      | `boolean`                                 | Return distinct results if `true`.                                          |\n| `sort`          | `SortType<Tables>`                        | Sorting criteria (e.g., `{ age: 1 }` for ascending).                        |\n| `columns`       | `object \\| string \\| string[]`              | Columns to select (e.g., `{ users: ['id', 'name'] }` or `'id, name'`).     |\n| `groupBy`       | `object \\| string \\| string[]`              | Columns to group by (e.g., `{ users: ['status'] }`).                       |\n| `aggregates`    | `Array<object>`                           | Aggregate functions (e.g., `[{ COUNT: 'id' }]`).                            |\n| `where`         | `string`                                  | Filter condition (e.g., `\"status = 'active'\"`).                             |\n| `having`        | `string`                                  | Condition for grouped results (e.g., `\"COUNT(age) > 2\"`).                   |\n| `subQueries`    | `Array<{ query: string; as?: string }>`   | Subqueries for `FROM` or `WHERE` clauses.                                  |\n| `joins`         | `JoinsType<Tables>`                       | Join clauses for multi-table queries.                                      |\n| `recursiveCTE`  | `object`                                  | Recursive CTE configuration with base case, recursive case, and alias.     |\n\n---\n\n## 3. The `findOne` Function\n\n### Function Signatures\n\n```typescript\npublic findOne<tables extends string[]>(table: string, config?: FindOneParamsType<tables>): DBnx;\npublic findOne<tables extends string[]>(model: typeof Model, config?: FindOneParamsType<tables>): Promise<ResponseType>;\npublic findOne(...args: any): DBnx | Promise<ResponseType>;\n```\n\n### How It Works\n\n- **Table Name**: When a string is provided, the function generates a `SELECT` query for the specified table, supporting query chaining.\n- **Model**: When a model is provided, the function executes the query immediately using the model’s table definition.\n- **Config**: The `FindOneParamsType` object specifies filters, sorting, columns, and other query options.\n\n### Return Types\n\n- **Chainable**: Returns a `DBnx` instance for query chaining (e.g., with `.build()` or `.execute()`) when used with a table name.\n- **Immediate Execution**: Returns a `Promise<ResponseType>` with the query result when used with a model or executed.\n\n---\n\n## 4. Usage Examples\n\n### Basic Query\n\nRetrieve a single record based on a condition.\n\n```typescript\nconst query = await db.findOne('users', {\n  where: 'id = 1',\n}).build();\nconsole.log(query);\n// SQL: SELECT * FROM users WHERE id = 1 LIMIT 1;\n```\n\n```typescript\nconst result = await db.findOne('users', {\n  where: 'id = 1',\n}).execute();\nconsole.log(result); // Logs execution result\n```\n\n**Using a Model**:\n\n```typescript\nconst result = await db.findOne(UserModel, {\n  where: 'id = 1',\n});\nconsole.log(result); // Logs execution result\n```\n\n```typescript\nconst result = await UserModel.findOne({\n  where: 'id = 1',\n});\nconsole.log(result); // Logs execution result\n```\n\n### Query with Sorting\n\nSort results before selecting the first record.\n\n```typescript\nconst query = await db.findOne('users', {\n  where: \"status = 'active'\",\n  sort: { name: 1 },\n}).build();\nconsole.log(query);\n// SQL: SELECT * FROM users WHERE status = 'active' ORDER BY name ASC LIMIT 1;\n```\n\n### Query with Aggregates\n\nApply an aggregate function to the result.\n\n```typescript\nconst query = await db.findOne('orders', {\n  aggregates: [{ COUNT: 'id' }],\n  where: \"status = 'completed'\",\n}).build();\nconsole.log(query);\n// SQL: SELECT COUNT(id) FROM orders WHERE status = 'completed' LIMIT 1;\n```\n\n### Query with Joins\n\nRetrieve a record with data from joined tables.\n\n```typescript\nconst query = await db.findOne('users', {\n  joins: {\n    type: 'INNER',\n    table: 'orders',\n    on: 'users.id = orders.user_id',\n  },\n  where: \"users.status = 'active'\",\n}).build();\nconsole.log(query);\n// SQL: SELECT * FROM users INNER JOIN orders ON users.id = orders.user_id WHERE users.status = 'active' LIMIT 1;\n```\n\n### Query with Subqueries\n\nUse a subquery in the query.\n\n```typescript\nconst query = await db.findOne('users', {\n  subQueries: [{\n    query: \"SELECT id FROM users WHERE status = 'active'\",\n    as: 'active_users',\n  }],\n  where: 'id IN (SELECT id FROM active_users)',\n}).build();\nconsole.log(query);\n// SQL: SELECT * FROM users WHERE id IN (SELECT id FROM users WHERE status = 'active') LIMIT 1;\n```\n\n### Query with Recursive CTEs\n\nUse a recursive CTE for hierarchical or recursive data.\n\n```typescript\nconst query = await db.findOne('users', {\n  recursiveCTE: {\n    baseCase: \"SELECT id FROM users WHERE status = 'active'\",\n    recursiveCase: \"SELECT u.id FROM users u INNER JOIN users r ON u.id = r.id\",\n    alias: 'recursion',\n  },\n}).build();\nconsole.log(query);\n// SQL: WITH recursion AS (SELECT id FROM users WHERE status = 'active' UNION ALL SELECT u.id FROM users u INNER JOIN users r ON u.id = r.id) SELECT * FROM users WHERE id IN (SELECT id FROM recursion) LIMIT 1;\n```\n\n---\n\n## 5. Best Practices\n\n1. **Always Use a WHERE Clause**:\n   - Specify a `where` condition to avoid retrieving unintended records. Without a `where` clause, the first record in the table is returned.\n\n2. **Optimize Column Selection**:\n   - Use the `columns` parameter to select only necessary columns, improving query performance.\n\n3. **Test Subqueries and Joins**:\n   - Preview complex queries with `.build()` to ensure correctness before execution, especially when using subqueries or joins.\n\n4. **Use Aggregates Judiciously**:\n   - Ensure `aggregates` are paired with appropriate `groupBy` and `having` clauses to avoid unexpected results.\n\n5. **Handle Recursive CTEs Carefully**:\n   - Recursive CTEs can be resource-intensive. Test in a development environment and ensure the recursion terminates correctly.\n\n---\n"
            },
            {
              "originalPath": "2.FindAll.md",
              "id": 10,
              "name": "FindAll",
              "type": "file",
              "path": "crud-operations/find/findall",
              "content": "\n# `@dbnx/mysql` findAll Function\n\nThe `findAll` function in `@dbnx/mysql` retrieves multiple records from a MySQL database table or model. It supports flexible query configuration, including filtering, sorting, pagination, grouping, joins, subqueries, aggregates, and recursive common table expressions (CTEs). This makes it suitable for a wide range of data retrieval tasks.\n\n---\n\n## 1. Overview\n\nThe `findAll` function fetches multiple records from a database, offering extensive customization through the `FindAllParamsType` interface. It supports both table-based queries (using a table name) and model-based queries (using a model class), providing flexibility for raw SQL and ORM-style operations.\n\n---\n\n## 2. Method Signature\n\n```typescript\npublic findAll<tables extends string[]>(table: string, config?: FindAllParamsType<tables>): DBnx;\npublic findAll<tables extends string[]>(model: typeof Model, config?: FindAllParamsType<tables>): Promise<ResponseType>;\npublic findAll(...args: any): DBnx | Promise<ResponseType>;\n```\n\n### Parameters\n\n| Parameter | Type                     | Description                                                                 | Required |\n|-----------|--------------------------|-----------------------------------------------------------------------------|----------|\n| `table`   | `string`                 | Name of the table to query. Used for raw table-based queries.               | Yes (if not using model) |\n| `model`   | `typeof Model`           | Model class to query. Used for model-based queries.                         | Yes (if not using table) |\n| `config`  | `FindAllParamsType`      | Configuration object for customizing the query (e.g., filters, sorting).    | No       |\n\n### Returns\n\n- **Table Name**: Returns a `DBnx` instance for query chaining (e.g., with `.build()` or `.execute()`).\n- **Model**: Returns a `Promise<ResponseType>` with the query results.\n\n---\n\n## 3. FindAllParamsType\n\n### Type Definition\n\nThe `FindAllParamsType` interface defines the configuration options for the `findAll` function.\n\n```typescript\nexport interface FindAllParamsType<Tables extends string[]> {\n  distinct?: boolean;\n  sort?: SortType<Tables>;\n  limitSkip?: { limit?: number; skip?: number };\n  columns?: { [P in Tables[number]]?: string[] } | { extra?: string | string[] } | string | string[];\n  groupBy?: { [P in Tables[number]]?: string[] } | { extra?: string | string[] } | string | string[];\n  aggregates?: Array<{ [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string } | { alias?: string }>;\n  where?: string;\n  having?: string;\n  subQueries?: { query: string; as?: string }[];\n  joins?: JoinsType<Tables>;\n  recursiveCTE?: { baseCase: string; recursiveCase: string; alias: string };\n}\n```\n\n### Key Parameters\n\n| Parameter       | Type                                      | Description                                                                 |\n|-----------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `distinct`      | `boolean`                                 | Return distinct records if `true`.                                          |\n| `sort`          | `SortType<Tables>`                        | Sorting criteria (e.g., `{ name: 'ASC' }`).                                 |\n| `limitSkip`     | `{ limit?: number; skip?: number }`       | Pagination options for limiting and skipping records.                      |\n| `columns`       | `object \\| string \\| string[]`              | Columns to select (e.g., `{ users: ['id', 'name'] }` or `'id, name'`).     |\n| `groupBy`       | `object \\| string \\| string[]`              | Columns to group by (e.g., `{ users: ['status'] }`).                       |\n| `aggregates`    | `Array<object>`                           | Aggregate functions (e.g., `[{ COUNT: 'id' }]`).                            |\n| `where`         | `string`                                  | Filter condition (e.g., `\"age > 25\"`).                                     |\n| `having`        | `string`                                  | Condition for grouped results (e.g., `\"COUNT(id) > 2\"`).                   |\n| `subQueries`    | `Array<{ query: string; as?: string }>`   | Subqueries for `FROM` or `WHERE` clauses.                                  |\n| `joins`         | `JoinsType<Tables>`                       | Join clauses for multi-table queries.                                      |\n| `recursiveCTE`  | `object`                                  | Recursive CTE configuration with base case, recursive case, and alias.     |\n\n---\n\n## 4. Usage Examples\n\n### Using a Table Name\n\nQuery a table with pagination and sorting.\n\n```typescript\nconst handler = db.findAll('users', {\n  limitSkip: { limit: 10, skip: 0 },\n  sort: { name: 'ASC' },\n  columns: { users: ['id', 'name'] },\n});\n\nconst result = await handler.execute();\nconsole.log(result); // Logs query result\n```\n\n**Generated SQL**:\n\n```sql\nSELECT users.id, users.name FROM users ORDER BY name ASC LIMIT 10 OFFSET 0;\n```\n\n### Using a Model\n\nQuery a model with filtering.\n\n```typescript\nconst result = await User.findAll({\n  limitSkip: { limit: 5 },\n  where: 'age > 25',\n  columns: { users: ['id', 'name', 'age'] },\n});\nconsole.log(result); // Logs fetched data\n```\n\n**Generated SQL**:\n\n```sql\nSELECT users.id, users.name, users.age FROM users WHERE age > 25 LIMIT 5;\n```\n\n### Advanced Configuration\n\nQuery with joins, aggregates, and subqueries.\n\n```typescript\nconst handler = db.findAll('users', {\n  distinct: true,\n  limitSkip: { limit: 10, skip: 0 },\n  sort: { name: 'ASC' },\n  columns: { users: ['id', 'name'] },\n  where: 'age > 25',\n  joins: [{ type: 'INNER', table: 'orders', on: 'users.id = orders.user_id' }],\n  aggregates: [{ COUNT: 'orders.id', alias: 'order_count' }],\n  groupBy: { users: ['id', 'name'] },\n  having: 'COUNT(orders.id) > 1',\n  subQueries: [{ query: 'SELECT user_id FROM orders WHERE status = \"completed\"', as: 'completed_orders' }],\n});\n\nconst result = await handler.execute();\nconsole.log(result); // Logs query result\n```\n\n**Generated SQL**:\n\n```sql\nSELECT DISTINCT users.id, users.name, COUNT(orders.id) AS order_count\nFROM users\nINNER JOIN orders ON users.id = orders.user_id,\n(SELECT user_id FROM orders WHERE status = 'completed') AS completed_orders\nWHERE age > 25\nGROUP BY users.id, users.name\nHAVING COUNT(orders.id) > 1\nORDER BY name ASC\nLIMIT 10 OFFSET 0;\n```\n\n---\n\n## 5. Error Handling\n\n| Error Message                                      | Cause                                              | Solution                                                                 |\n|----------------------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------|\n| `No arguments provided to 'findAll'.`              | Missing table name or model.                       | Provide a valid table name or model as the first argument.               |\n| `Config must be a non-empty object.`                | Invalid or empty configuration object.             | Ensure the `config` parameter is a valid, non-empty object.              |\n\n---\n\n## 6. Best Practices\n\n1. **Use Specific Columns**:\n   - Specify required columns in the `columns` parameter to reduce data transfer and improve performance.\n\n2. **Implement Pagination**:\n   - Use `limitSkip` for large datasets to manage result sizes and improve query efficiency.\n\n3. **Test Complex Queries**:\n   - Preview queries with `.build()` to verify correctness before execution, especially for joins, subqueries, or CTEs.\n\n4. **Optimize Aggregates**:\n   - Pair `aggregates` with appropriate `groupBy` and `having` clauses to ensure accurate results.\n\n5. **Handle Recursive CTEs Carefully**:\n   - Ensure recursive CTEs have a proper termination condition to avoid infinite loops or performance issues.\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "3.Update.md",
          "id": 11,
          "name": "Update",
          "type": "file",
          "path": "crud-operations/update",
          "content": "\n# `@dbnx/mysql` Update Operation\n\nThe `update` function in `@dbnx/mysql` provides a flexible interface for performing MySQL `UPDATE` operations. It supports conditional updates with `CASE` expressions, joins, subqueries, sorting, limiting, and calculated fields, making it suitable for a wide range of database update scenarios.\n\n---\n\n## 1. Overview\n\nThe `update` function allows developers to modify records in a MySQL database with fine-grained control. It supports both simple updates (e.g., setting column values) and complex operations (e.g., conditional updates, joins, and subqueries). The `UpdateParamsType` defines the structure of the update parameters, enabling flexible query construction.\n\n---\n\n## 2. UpdateParamsType\n\n### Type Definition\n\nThe `UpdateParamsType` type specifies the properties for an update operation, including values to set, conditions, sorting, and more.\n\n```typescript\nexport type UpdateismicType<Tables extends string[]> = {\n  values?: {\n    [key: string]: string | number | null | {\n      case: {\n        when: string;  // Condition for WHEN clause\n        then: any;     // Value for THEN clause\n      }[];             // Array of WHEN/THEN conditions\n      default: any;    // Default value if no conditions match\n    };\n  };\n  sort?: { [P in Tables[number]]?: Record<string, 1 | -1> } | Record<string, 1 | -1> | string;\n  where: string;\n  defaultValues?: string[];\n  limit?: string | number;\n  joins?: JoinsType<Tables>;\n  fromSubQuery?: Record<string, string>;\n  setCalculations?: { [key: string]: string };\n};\n```\n\n### Key Parameters\n\n| Parameter          | Type                                      | Description                                                                 |\n|--------------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `values`           | `object`                                  | Columns and values to update. Supports direct values or `CASE` expressions. |\n| `sort`             | `object \\| string`                        | Sorting criteria (e.g., `{ age: 1 }` for ascending, `{ age: -1 }` for descending). |\n| `where`            | `string`                                  | Condition for selecting records to update (e.g., `\"id = 1\"`).               |\n| `defaultValues`    | `string[]`                                | Columns to set to their default values.                                    |\n| `limit`            | `string \\| number`                        | Maximum number of records to update.                                       |\n| `joins`            | `JoinsType<Tables>`                       | Join clauses for multi-table updates.                                      |\n| `fromSubQuery`     | `Record<string, string>`                  | Subquery for updating records based on another query.                      |\n| `setCalculations`  | `{ [key: string]: string }`               | Calculated values for columns (e.g., `\"price * quantity\"`).                 |\n\n---\n\n## 3. The `update` Function\n\n### Function Signatures\n\n```typescript\npublic update<tables extends string[]>(table: string, props: UpdateParamsType<tables>): DBnx;\npublic update<tables extends string[]>(model: typeof Model, props: UpdateParamsType<tables>): Promise<ResponseType>;\npublic update(...args: any): DBnx | Promise<ResponseType>;\n```\n\n### How It Works\n\n- **Table Name**: When a string is provided, the function targets the specified table.\n- **Model**: When a model is provided, the function uses the model’s table definition and executes the query immediately.\n- **Props**: The `UpdateParamsType` object defines the update logic, including values, conditions, and optional settings.\n\n### Return Types\n\n- **Chainable**: Returns a `DBnx` instance for query chaining (e.g., with `.build()` or `.execute()`) when used with a table name.\n- **Immediate Execution**: Returns a `Promise<ResponseType>` with the query result when used with a model or executed.\n\n---\n\n## 4. Usage Examples\n\n### Basic Update\n\nUpdate specific columns for records matching a condition.\n\n```typescript\nconst query = await db.update('users', {\n  values: {\n    name: 'John Doe',\n    age: 30,\n  },\n  where: 'id = 1',\n}).build();\nconsole.log(query);\n// SQL: UPDATE users SET name = 'John Doe', age = 30 WHERE id = 1;\n```\n\n```typescript\nconst result = await db.update('users', {\n  values: {\n    name: 'John Doe',\n    age: 30,\n  },\n  where: 'id = 1',\n}).execute();\nconsole.log(result); // Logs execution result\n```\n\n**Using a Model**:\n\n```typescript\nconst result = await UserModel.update({\n  values: {\n    name: 'John Doe',\n    age: 30,\n  },\n  where: 'id = 1',\n});\nconsole.log(result); // Logs execution result\n```\n\n```typescript\nconst result = await db.update(UserModel, {\n  values: {\n    name: 'John Doe',\n    age: 30,\n  },\n  where: 'id = 1',\n});\nconsole.log(result); // Logs execution result\n```\n\n### Conditional Update with CASE\n\nUse a `CASE` expression for conditional updates.\n\n```typescript\nconst query = await db.update('users', {\n  values: {\n    age: {\n      case: [\n        { when: \"status = 'active'\", then: 35 },\n        { when: \"status = 'inactive'\", then: 25 },\n      ],\n      default: 30,\n    },\n  },\n  where: 'id = 1',\n}).build();\nconsole.log(query);\n// SQL: UPDATE users SET age = CASE WHEN status = 'active' THEN 35 WHEN status = 'inactive' THEN 25 ELSE 30 END WHERE id = 1;\n```\n\n### Update with Sorting\n\nSort records before applying the update.\n\n```typescript\nconst query = await db.update('users', {\n  values: {\n    status: 'active',\n  },\n  where: 'age > 18',\n  sort: { name: 1 },\n}).build();\nconsole.log(query);\n// SQL: UPDATE users SET status = 'active' WHERE age > 18 ORDER BY name ASC;\n```\n\n### Update with Joins\n\nPerform updates involving multiple tables using joins.\n\n```typescript\nconst query = await db.update('orders', {\n  values: {\n    status: 'shipped',\n  },\n  where: \"orders.status = 'pending'\",\n  joins: {\n    type: 'INNER',\n    table: 'users',\n    on: 'orders.user_id = users.id',\n  },\n}).build();\nconsole.log(query);\n// SQL: UPDATE orders INNER JOIN users ON orders.user_id = users.id SET status = 'shipped' WHERE orders.status = 'pending';\n```\n\n### Update with Subquery\n\nUpdate records based on a subquery.\n\n```typescript\nconst query = await db.update('orders', {\n  values: {\n    status: 'shipped',\n  },\n  where: 'id IN (SELECT id FROM pending_orders)',\n  fromSubQuery: {\n    pending_orders: \"SELECT id FROM orders WHERE status = 'pending'\",\n  },\n}).build();\nconsole.log(query);\n// SQL: UPDATE orders SET status = 'shipped' WHERE id IN (SELECT id FROM orders WHERE status = 'pending');\n```\n\n---\n\n## 5. Advanced Use Cases\n\n### Handling Null Values\n\nSet columns to `NULL` during an update.\n\n```typescript\nconst query = await db.update('users', {\n  values: {\n    name: 'Jane Doe',\n    age: 28,\n    address: null,\n  },\n  where: 'id = 2',\n}).build();\nconsole.log(query);\n// SQL: UPDATE users SET name = 'Jane Doe', age = 28, address = NULL WHERE id = 2;\n```\n\n### Performing Calculations in Updates\n\nUse calculated values or `CASE` expressions for dynamic updates.\n\n```typescript\nconst query = await db.update('orders', {\n  values: {\n    total_price: {\n      case: [\n        { when: 'quantity > 10', then: 'price * quantity * 0.9' },\n        { when: 'quantity <= 10', then: 'price * quantity' },\n      ],\n      default: 'price * quantity',\n    },\n  },\n  where: 'id = 3',\n}).build();\nconsole.log(query);\n// SQL: UPDATE orders SET total_price = CASE WHEN quantity > 10 THEN price * quantity * 0.9 WHEN quantity <= 10 THEN price * quantity ELSE price * quantity END WHERE id = 3;\n```\n\n---\n"
        },
        {
          "originalPath": "4.Delete.md",
          "id": 12,
          "name": "Delete",
          "type": "file",
          "path": "crud-operations/delete",
          "content": "\n# `@dbnx/mysql` Delete Operation\n\nThe `delete` function in `@dbnx/mysql` provides a robust interface for performing MySQL `DELETE` operations. It supports customizable deletion with conditions, joins, sorting, and limits, making it suitable for both simple and complex use cases.\n\n---\n\n## 1. Setting Up the Database Handler\n\nBefore performing delete operations, initialize a `DBnx` instance and define a model to specify the table schema.\n\n### Example: User Model\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nconst db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '11224455',\n  database: 'world',\n  waitForConnections: true,\n  multipleStatements: true,\n  connectionLimit: 10,\n  queueLimit: 0,\n}).connect();\n\n// Define User model\nconst User = db.define('User', {\n  username: {\n    type: 'VARCHAR(50)',\n    allowNull: false,\n    unique: true,\n    defaultValue: null,\n  },\n  created_at: {\n    type: 'TIMESTAMP',\n    defaultValue: 'CURRENT_TIMESTAMP',\n  },\n});\n```\n\n---\n\n## 2. The `delete` Function\n\nThe `delete` function removes records from a specified table or model, supporting conditions, joins, sorting, and limits.\n\n### Function Signature\n\n```typescript\ndelete<Tables extends string[]>(\n  table: string | typeof Model,\n  params: DeleteParamsType<Tables>\n): DBnx | Promise<ResponseType>;\n```\n\n- **Table/Model**: Specify the table name (string) or model (e.g., `User`).\n- **Params**: Define deletion criteria using `DeleteParamsType`.\n\n### Parameters\n\n| Parameter | Type                     | Description                                                                 |\n|-----------|--------------------------|-----------------------------------------------------------------------------|\n| `table`   | `string \\| typeof Model` | Table name or model to delete from.                                        |\n| `params`  | `DeleteParamsType`       | Object specifying deletion conditions, joins, sorting, and limits.          |\n\n### Usage Examples\n\n#### Basic Deletion\n\nDelete records matching a condition.\n\n```typescript\nconst query = await db.delete('users', {\n  where: 'age > 30',\n}).build();\nconsole.log(query);\n// SQL: DELETE FROM users WHERE age > 30;\n```\n\n```typescript\nconst result = await db.delete('users', {\n  where: 'age > 30',\n}).execute();\nconsole.log(result); // Logs execution result\n```\n\n#### Deletion with Joins\n\nDelete records from a table using a join.\n\n```typescript\nconst query = await db.delete('orders', {\n  where: \"status = 'pending'\",\n  joins: {\n    type: 'INNER',\n    table: 'users',\n    on: 'orders.user_id = users.id',\n  },\n}).build();\nconsole.log(query);\n// SQL: DELETE orders FROM orders INNER JOIN users ON orders.user_id = users.id WHERE status = 'pending';\n```\n\n**Using a Model**:\n\n```typescript\nconst result = await db.delete(Orders, {\n  where: \"status = 'pending'\",\n  joins: {\n    type: 'INNER',\n    table: 'users',\n    on: 'orders.user_id = users.id',\n  },\n});\nconsole.log(result); // Logs execution result\n```\n\n**Using a Table with Execution**:\n\n```typescript\nconst result = await db.delete('orders', {\n  where: \"status = 'pending'\",\n  joins: {\n    type: 'INNER',\n    table: 'users',\n    on: 'orders.user_id = users.id',\n  },\n}).execute();\nconsole.log(result); // Logs execution result\n```\n\n#### Deletion with Limit\n\nRestrict the number of deleted records.\n\n```typescript\nconst query = await db.delete('users', {\n  where: \"status = 'inactive'\",\n  limit: 10,\n}).build();\nconsole.log(query);\n// SQL: DELETE FROM users WHERE status = 'inactive' LIMIT 10;\n```\n\n#### Deletion with Sorting\n\nSort records before deletion.\n\n```typescript\nconst query = await db.delete('products', {\n  where: 'stock = 0',\n  sort: { field: 'created_at', order: 'ASC' },\n}).build();\nconsole.log(query);\n// SQL: DELETE FROM products WHERE stock = 0 ORDER BY created_at ASC;\n```\n\n---\n\n## 3. Types and Definitions\n\n### DeleteParamsType\n\nDefines the parameters for the `delete` function.\n\n```typescript\nexport interface DeleteParamsType<Tables extends string[]> {\n  where: string;                    // Condition for selecting rows to delete\n  sort?: SortType<Tables>;          // Optional sorting criteria\n  limit?: string | number;          // Optional limit on number of deleted rows\n  joins?: JoinsType<Tables>;        // Optional JOIN clauses for multi-table deletion\n}\n```\n\n### JoinsType\n\nSpecifies join configurations for multi-table deletions.\n\n```typescript\nexport type JoinsType<Tables extends string[]> = {\n  type: 'INNER' | 'LEFT' | 'RIGHT' | 'FULL'; // Join type\n  table: string;                             // Table to join\n  on: string;                                // Join condition\n};\n```\n\n### SortType\n\nDefines sorting criteria.\n\n```typescript\nexport type SortType<Tables extends string[]> = {\n  field: string;  // Field to sort by\n  order: 'ASC' | 'DESC'; // Sorting direction\n};\n```\n\n---\n\n## 4. Best Practices\n\n1. **Always Use a WHERE Clause**:\n   - Omitting the `where` clause deletes all rows in the table. Always specify conditions to avoid unintentional data loss.\n\n2. **Use Limits for Safety**:\n   - Apply the `limit` option in production to prevent accidental bulk deletions that could impact performance or data integrity.\n\n3. **Leverage Joins for Multi-Table Operations**:\n   - Use `joins` to ensure deletions are coordinated across related tables, maintaining referential integrity.\n\n4. **Preview Queries**:\n   - Use the `.build()` method to inspect the generated SQL query before executing it to confirm the correct rows are targeted.\n\n5. **Test in a Safe Environment**:\n   - Test delete operations in a development or staging environment to avoid accidental data loss in production.\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "7.Advanced Usage",
      "name": "Advanced Usage",
      "path": "advanced-usage",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. SetQuery.md",
          "id": 13,
          "name": "SetQuery",
          "type": "file",
          "path": "advanced-usage/setquery",
          "content": "\n# `@dbnx/mysql` setQuery Method\n\nThe `setQuery` method in `@dbnx/mysql` allows you to overwrite the current SQL query with a new one. It provides logging to track query changes and avoid redundant updates, making it useful for debugging and query management.\n\n---\n\n## 1. Overview\n\nThe `setQuery` method updates the internal SQL query of a `DBnx` instance, replacing the existing query with a new one. It logs changes for transparency and supports method chaining, enabling seamless integration into query-building workflows.\n\n---\n\n## 2. Method Signature\n\n```typescript\nsetQuery(query: string): DBnx\n```\n\n---\n\n## 3. Parameters\n\n| Parameter | Type     | Description                              | Required |\n|-----------|----------|------------------------------------------|----------|\n| `query`   | `string` | The new SQL query to set.                | Yes      |\n\n---\n\n## 4. Returns\n\n- **`DBnx`**: The current `DBnx` instance, enabling method chaining.\n\n---\n\n## 5. Usage Example\n\n```typescript\n// Initialize DBnx instance\nconst db = new DBnx({ /* configuration */ }).connect();\n\n// Set a new query\ndb.setQuery('SELECT * FROM users');\n// Console: Query set to: SELECT * FROM users\n\n// Set the same query again\ndb.setQuery('SELECT * FROM users');\n// Console: Query remains the same: SELECT * FROM users\n\n// Set a different query\ndb.setQuery('SELECT * FROM products');\n// Console: Query set to: SELECT * FROM products\n\n// Chain with execution\nconst result = await db.setQuery('SELECT * FROM users WHERE id = 1').execute();\nconsole.log(result); // Logs query result\n```\n\n---\n"
        },
        {
          "originalPath": "Multiple Execute Query.md",
          "id": 14,
          "name": "Multiple Execute Query",
          "type": "file",
          "path": "advanced-usage/multiple-execute-query",
          "content": "\n# `@dbnx/mysql` executeMultiple() Method\n\nThe `executeMultiple()` method in `@dbnx/mysql` enables the execution of multiple database queries in sequence within a single transaction. This method supports chaining operations like `update`, `findAll`, `create`, `findOne`, and `delete`, providing a streamlined way to perform complex database operations.\n\n---\n\n## 1. Overview\n\nThe `executeMultiple()` method allows developers to chain multiple database operations (e.g., updates, inserts, queries, and deletions) and execute them sequentially in a single call. This approach ensures efficient query execution and simplifies transaction management, with built-in error handling and connection cleanup.\n\n---\n\n## 2. Setup Database Connection\n\nThe `DBnx` instance is initialized to establish a connection to the MySQL database.\n\n### Code\n\n```javascript\n// database.js\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nexport const db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '11224455',\n  database: 'world',\n  waitForConnections: true,\n  multipleStatements: true,\n  connectionLimit: 10,\n  queueLimit: 0,\n}).connect();\n```\n\n### Parameters\n\n| Parameter              | Type      | Description                                                                 |\n|------------------------|-----------|-----------------------------------------------------------------------------|\n| `host`                 | `string`  | MySQL server hostname or IP address.                                        |\n| `user`                 | `string`  | MySQL username.                                                             |\n| `password`             | `string`  | MySQL password.                                                             |\n| `database`             | `string`  | Database name.                                                              |\n| `waitForConnections`   | `boolean` | Wait for connections when the pool is full.                                 |\n| `multipleStatements`   | `boolean` | Allow multiple SQL statements in a single query.                            |\n| `connectionLimit`      | `number`  | Maximum number of connections in the pool.                                  |\n| `queueLimit`           | `number`  | Maximum number of queued connection requests (0 = no limit).                |\n\n---\n\n## 3. Using executeMultiple()\n\nThe `executeMultiple()` method executes a sequence of chained queries, such as updating records, retrieving data, inserting new records, and deleting records.\n\n### Example Code\n\n```javascript\n// executeQueries.js\nimport { db } from './database.js';\n\nasync function executeMultipleQueries() {\n  try {\n    const result = await db\n      .update('product', {\n        values: { title: 'SRAKIB brand' },\n        where: 'product_id = 1',\n      })\n      .findAll('product')\n      .create('product', {\n        title: 'test',\n      })\n      .findOne('product', {\n        where: 'product_id = 1',\n      })\n      .delete('product', {\n        where: 'product_id = 2',\n      })\n      .executeMultiple();\n\n    console.log('Multiple queries executed successfully:', result);\n  } catch (error) {\n    console.error('Error executing multiple queries:', error);\n  } finally {\n    await db.close(); // Close the database connection\n  }\n}\n\nexecuteMultipleQueries();\n```\n\n---\n\n## 4. Query Methods Breakdown\n\n### update\n\nUpdates existing records in a table.\n\n- **Signature**: `update(table: string, params: UpdateParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `params.values`: Object with column-value pairs to update.\n  - `params.where`: Condition for selecting records.\n\n### findAll\n\nRetrieves all records from a table.\n\n- **Signature**: `findAll(table: string, config?: FindAllParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `config`: Optional query configuration (e.g., filters, sorting).\n\n### create\n\nInserts a new record into a table.\n\n- **Signature**: `create(table: string, values: CreateParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `values`: Object with column-value pairs to insert.\n\n### findOne\n\nRetrieves a single record from a table.\n\n- **Signature**: `findOne(table: string, config?: FindOneParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `config.where`: Condition for selecting the record.\n\n### delete\n\nDeletes records from a table.\n\n- **Signature**: `delete(table: string, params: DeleteParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `params.where`: Condition for selecting records to delete.\n\n### executeMultiple\n\nExecutes all queued queries in sequence.\n\n- **Signature**: `executeMultiple(): Promise<ResponseType[]>`\n- **Returns**: An array of results from each query.\n\n---\n\n## 5. Error Handling\n\nWrap the query chain in a `try...catch` block to handle errors gracefully.\n\n### Example\n\n```javascript\ntry {\n  const result = await db\n    .update('product', { values: { title: 'SRAKIB brand' }, where: 'product_id = 1' })\n    .findAll('product')\n    .create('product', { title: 'test' })\n    .findOne('product', { where: 'product_id = 1' })\n    .delete('product', { where: 'product_id = 2' })\n    .executeMultiple();\n  console.log('Results:', result);\n} catch (error) {\n  console.error('Error executing query chain:', error);\n}\n```\n\n---\n\n## 6. Closing the Connection\n\nAlways close the database connection after executing queries to free up resources.\n\n```javascript\nawait db.close();\n```\n\n---\n\n## 7. Example Output\n\nUpon successful execution, the output will resemble:\n\n```plaintext\nMultiple queries executed successfully: [\n  { /* Update result */ },\n  { /* FindAll result */ },\n  { /* Create result */ },\n  { /* FindOne result */ },\n  { /* Delete result */ }\n]\n```\n\n---\n\n## 8. Best Practices\n\n1. **Use Transactions for Consistency**:\n   - Ensure all queries in the chain are executed within a transaction to maintain data integrity.\n\n2. **Validate Input Data**:\n   - Sanitize and validate input data (e.g., `values`, `where` conditions) to prevent SQL injection.\n\n3. **Preview Queries**:\n   - Use `.build()` to inspect generated SQL queries before execution, especially for complex chains.\n\n4. **Handle Errors Gracefully**:\n   - Implement robust error handling to capture and log issues without crashing the application.\n\n5. **Close Connections**:\n   - Always close the database connection in the `finally` block to avoid resource leaks.\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "8.API Reference",
      "name": "API Reference",
      "path": "api-reference",
      "type": "folder",
      "children": [
        {
          "originalPath": "crud",
          "name": "Crud",
          "path": "api-reference/crud",
          "type": "folder",
          "children": [
            {
              "originalPath": "Create.md",
              "id": 15,
              "name": "Create",
              "type": "file",
              "path": "api-reference/crud/create",
              "content": "# `@dbnx/mysql` executeMultiple() Method\n\nThe `executeMultiple()` method in `@dbnx/mysql` enables the execution of multiple database queries in sequence within a single transaction. This method supports chaining operations like `update`, `findAll`, `create`, `findOne`, and `delete`, providing a streamlined way to perform complex database operations.\n\n---\n\n## 1. Overview\n\nThe `executeMultiple()` method allows developers to chain multiple database operations (e.g., updates, inserts, queries, and deletions) and execute them sequentially in a single call. This approach ensures efficient query execution and simplifies transaction management, with built-in error handling and connection cleanup.\n\n---\n\n## 2. Setup Database Connection\n\nThe `DBnx` instance is initialized to establish a connection to the MySQL database.\n\n### Code\n\n```javascript\n// database.js\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nexport const db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '11224455',\n  database: 'world',\n  waitForConnections: true,\n  multipleStatements: true,\n  connectionLimit: 10,\n  queueLimit: 0,\n}).connect();\n```\n\n### Parameters\n\n| Parameter              | Type      | Description                                                                 |\n|------------------------|-----------|-----------------------------------------------------------------------------|\n| `host`                 | `string`  | MySQL server hostname or IP address.                                        |\n| `user`                 | `string`  | MySQL username.                                                             |\n| `password`             | `string`  | MySQL password.                                                             |\n| `database`             | `string`  | Database name.                                                              |\n| `waitForConnections`   | `boolean` | Wait for connections when the pool is full.                                 |\n| `multipleStatements`   | `boolean` | Allow multiple SQL statements in a single query.                            |\n| `connectionLimit`      | `number`  | Maximum number of connections in the pool.                                  |\n| `queueLimit`           | `number`  | Maximum number of queued connection requests (0 = no limit).                |\n\n---\n\n## 3. Using executeMultiple()\n\nThe `executeMultiple()` method executes a sequence of chained queries, such as updating records, retrieving data, inserting new records, and deleting records.\n\n### Example Code\n\n```javascript\n// executeQueries.js\nimport { db } from './database.js';\n\nasync function executeMultipleQueries() {\n  try {\n    const result = await db\n      .update('product', {\n        values: { title: 'SRAKIB brand' },\n        where: 'product_id = 1',\n      })\n      .findAll('product')\n      .create('product', {\n        title: 'test',\n      })\n      .findOne('product', {\n        where: 'product_id = 1',\n      })\n      .delete('product', {\n        where: 'product_id = 2',\n      })\n      .executeMultiple();\n\n    console.log('Multiple queries executed successfully:', result);\n  } catch (error) {\n    console.error('Error executing multiple queries:', error);\n  } finally {\n    await db.close(); // Close the database connection\n  }\n}\n\nexecuteMultipleQueries();\n```\n\n---\n\n## 4. Query Methods Breakdown\n\n### update\n\nUpdates existing records in a table.\n\n- **Signature**: `update(table: string, params: UpdateParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `params.values`: Object with column-value pairs to update.\n  - `params.where`: Condition for selecting records.\n\n### findAll\n\nRetrieves all records from a table.\n\n- **Signature**: `findAll(table: string, config?: FindAllParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `config`: Optional query configuration (e.g., filters, sorting).\n\n### create\n\nInserts a new record into a table.\n\n- **Signature**: `create(table: string, values: CreateParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `values`: Object with column-value pairs to insert.\n\n### findOne\n\nRetrieves a single record from a table.\n\n- **Signature**: `findOne(table: string, config?: FindOneParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `config.where`: Condition for selecting the record.\n\n### delete\n\nDeletes records from a table.\n\n- **Signature**: `delete(table: string, params: DeleteParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `params.where`: Condition for selecting records to delete.\n\n### executeMultiple\n\nExecutes all queued queries in sequence.\n\n- **Signature**: `executeMultiple(): Promise<ResponseType[]>`\n- **Returns**: An array of results from each query.\n\n---\n\n## 5. Error Handling\n\nWrap the query chain in a `try...catch` block to handle errors gracefully.\n\n### Example\n\n```javascript\ntry {\n  const result = await db\n    .update('product', { values: { title: 'SRAKIB brand' }, where: 'product_id = 1' })\n    .findAll('product')\n    .create('product', { title: 'test' })\n    .findOne('product', { where: 'product_id = 1' })\n    .delete('product', { where: 'product_id = 2' })\n    .executeMultiple();\n  console.log('Results:', result);\n} catch (error) {\n  console.error('Error executing query chain:', error);\n}\n```\n\n---\n\n## 6. Closing the Connection\n\nAlways close the database connection after executing queries to free up resources.\n\n```javascript\nawait db.close();\n```\n\n---\n\n## 7. Example Output\n\nUpon successful execution, the output will resemble:\n\n```plaintext\nMultiple queries executed successfully: [\n  { /* Update result */ },\n  { /* FindAll result */ },\n  { /* Create result */ },\n  { /* FindOne result */ },\n  { /* Delete result */ }\n]\n```\n\n---\n\n## 8. Best Practices\n\n1. **Use Transactions for Consistency**:\n   - Ensure all queries in the chain are executed within a transaction to maintain data integrity.\n\n2. **Validate Input Data**:\n   - Sanitize and validate input data (e.g., `values`, `where` conditions) to prevent SQL injection.\n\n3. **Preview Queries**:\n   - Use `.build()` to inspect generated SQL queries before execution, especially for complex chains.\n\n4. **Handle Errors Gracefully**:\n   - Implement robust error handling to capture and log issues without crashing the application.\n\n5. **Close Connections**:\n   - Always close the database connection in the `finally` block to avoid resource leaks.\n\n---\n"
            },
            {
              "originalPath": "Delete.md",
              "id": 16,
              "name": "Delete",
              "type": "file",
              "path": "api-reference/crud/delete",
              "content": "\n# `@dbnx/mysql` delete Method API Reference\n\nThe `delete` method in `@dbnx/mysql` enables the deletion of records from a MySQL database table or model based on specified conditions. It supports both table-based and model-based queries, with options for filtering, sorting, limiting, and joining tables.\n\n---\n\n## 1. Overview\n\nThe `delete` method removes records from a specified table or model, offering flexible configuration through the `DeleteParamsType` interface. It can be used with a raw table name for query building or with a model for immediate execution, supporting conditions, joins, sorting, and limits.\n\n---\n\n## 2. Method Signature\n\n```typescript\npublic delete<tables extends string[]>(table: string, props: DeleteParamsType<tables>): MySQLHandler;\npublic delete<tables extends string[]>(model: typeof Model, props: DeleteParamsType<tables>): Promise<ResponseType>;\npublic delete(...args: any): MySQLHandler | Promise<ResponseType>;\n```\n\n---\n\n## 3. Parameters\n\n| Parameter | Type                     | Description                                                                 | Required |\n|-----------|--------------------------|-----------------------------------------------------------------------------|----------|\n| `table`   | `string`                 | Name of the table to delete from (e.g., `'users'`).                         | Yes (if not using model) |\n| `model`   | `typeof Model`           | Model class for ORM-based deletion (e.g., `User`).                          | Yes (if not using table) |\n| `props`   | `DeleteParamsType`       | Configuration object specifying deletion conditions and options.            | Yes      |\n\n---\n\n## 4. Response\n\n- **Table Name**: Returns a `MySQLHandler` instance for query chaining (e.g., with `.build()` or `.execute()`).\n- **Model**: Returns a `Promise<ResponseType>` containing the result of the delete operation (e.g., number of affected rows).\n\n---\n\n## 5. DeleteParamsType\n\nThe `DeleteParamsType` interface defines the configuration for the delete operation.\n\n```typescript\nexport interface DeleteParamsType<Tables extends string[]> {\n  where: string;                    // Condition for selecting rows to delete\n  sort?: SortType<Tables>;          // Optional sorting criteria\n  limit?: string | number;          // Optional limit on number of deleted rows\n  joins?: JoinsType<Tables>;        // Optional JOIN clauses for multi-table deletion\n}\n```\n\n### Parameters\n\n| Parameter | Type                     | Description                                                                 |\n|-----------|--------------------------|-----------------------------------------------------------------------------|\n| `where`   | `string`                 | Condition for selecting records (e.g., `'age > 30'`).                       |\n| `sort`    | `SortType<Tables>`       | Sorting criteria (e.g., `{ name: 'ASC' }`).                                 |\n| `limit`   | `string \\| number`        | Maximum number of records to delete (e.g., `10`).                           |\n| `joins`   | `JoinsType<Tables>`      | Join conditions for multi-table deletions (e.g., `{ table: 'orders', on: 'users.id = orders.user_id' }`). |\n\n---\n\n## 6. Examples\n\n### Deleting Records Using a Table Name\n\nConstruct a delete query with sorting, limit, and joins.\n\n```typescript\nconst query = db.delete('users', {\n  where: 'age > 30',\n  sort: { name: 'ASC' },\n  limit: 10,\n  joins: { type: 'INNER', table: 'orders', on: 'users.id = orders.user_id' },\n}).build();\nconsole.log(query);\n// SQL: DELETE FROM users INNER JOIN orders ON users.id = orders.user_id WHERE age > 30 ORDER BY name ASC LIMIT 10;\n```\n\nExecute the query:\n\n```typescript\nconst result = await db.delete('users', {\n  where: 'age > 30',\n  sort: { name: 'ASC' },\n  limit: 10,\n}).execute();\nconsole.log(result); // Logs execution result\n```\n\n### Deleting Records Using a Model\n\nDelete records directly using a model.\n\n```typescript\nconst result = await User.delete({\n  where: 'age > 30',\n  sort: { name: 'ASC' },\n  limit: 10,\n});\nconsole.log(result); // Logs result of delete operation\n```\n\n---\n\n## 7. Errors\n\n| Error Message                                      | Cause                                              | Solution                                                                 |\n|----------------------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------|\n| `No arguments provided to 'delete'.`               | Missing table name or model.                       | Provide a valid table name or model as the first argument.               |\n| `Invalid first argument: must be a table name or a Model class.` | First argument is neither a string nor a model.    | Ensure the first argument is a valid table name or model class.          |\n| `Props must be a non-empty object.`                | Invalid or empty `props` object.                   | Provide a valid `DeleteParamsType` object with at least a `where` clause.|\n\n---\n\n## 8. Internal Methods\n\n- **`destroy`**: Constructs the `DELETE` SQL query based on the provided parameters.\n- **`parseJoins`**: Formats the `joins` parameter into SQL `JOIN` clauses.\n- **`parseSort`**: Formats the `sort` parameter into SQL `ORDER BY` clauses.\n\n---\n\n## 9. Use Cases\n\n- **Selective Deletion**: Delete specific records based on conditions (e.g., inactive users or outdated orders).\n- **Multi-Table Deletion**: Use `joins` to delete records from related tables while maintaining referential integrity.\n- **Controlled Deletion**: Apply `sort` and `limit` to delete records in a specific order or restrict the number of deletions.\n\n---\n"
            },
            {
              "originalPath": "Find.md",
              "id": 17,
              "name": "Find",
              "type": "file",
              "path": "api-reference/crud/find",
              "content": "\n# `@dbnx/mysql` API Reference: findAll, findOne, and Related Types\n\nThis API reference details the `findAll` and `findOne` methods, along with their supporting types (`JoinsType`, `SortType`, `OperatorType`, `FindOneParamsType`, and `FindAllParamsType`). These methods enable flexible querying of MySQL databases, supporting filtering, sorting, pagination, joins, subqueries, aggregates, and recursive CTEs.\n\n---\n\n## 1. findAll Method\n\n### Method Signature\n\n```typescript\npublic findAll<tables extends string[]>(table: string, config?: FindAllParamsType<tables>): MySQLHandler;\npublic findAll<tables extends string[]>(model: typeof Model, config?: FindAllParamsType<tables>): Promise<ResponseType>;\n```\n\n### Parameters\n\n| Parameter | Type                     | Description                                                                 | Required |\n|-----------|--------------------------|-----------------------------------------------------------------------------|----------|\n| `table`   | `string`                 | Name of the table to query (e.g., `'users'`).                               | Yes (if not using model) |\n| `model`   | `typeof Model`           | Model class for ORM-based queries (e.g., `User`).                           | Yes (if not using table) |\n| `config`  | `FindAllParamsType`      | Configuration object for customizing the query (e.g., filters, sorting).    | No       |\n\n### Returns\n\n- **Table Name**: Returns a `MySQLHandler` instance for query chaining (e.g., with `.build()` or `.execute()`).\n- **Model**: Returns a `Promise<ResponseType>` containing the query results.\n\n### Example\n\n```typescript\nconst results = await db.findAll('users', {\n  sort: { name: 1 },\n  limitSkip: { limit: 10, skip: 0 },\n  columns: ['name', 'email'],\n  where: 'status = \"active\"',\n}).execute();\nconsole.log(results); // Logs fetched records\n// SQL: SELECT name, email FROM users WHERE status = 'active' ORDER BY name ASC LIMIT 10 OFFSET 0;\n```\n\n**Using a Model**:\n\n```typescript\nconst results = await User.findAll({\n  sort: { name: 1 },\n  limitSkip: { limit: 10, skip: 0 },\n  columns: ['name', 'email'],\n  where: 'status = \"active\"',\n});\nconsole.log(results); // Logs fetched records\n```\n\n---\n\n## 2. findOne Method\n\n### Method Signature\n\n```typescript\npublic findOne<tables extends string[]>(table: string, config?: FindOneParamsType<tables>): MySQLHandler;\npublic findOne<tables extends string[]>(model: typeof Model, config?: FindOneParamsType<tables>): Promise<ResponseType>;\n```\n\n### Parameters\n\n| Parameter | Type                     | Description                                                                 | Required |\n|-----------|--------------------------|-----------------------------------------------------------------------------|----------|\n| `table`   | `string`                 | Name of the table to query (e.g., `'users'`).                               | Yes (if not using model) |\n| `model`   | `typeof Model`           | Model class for ORM-based queries (e.g., `User`).                           | Yes (if not using table) |\n| `config`  | `FindOneParamsType`      | Configuration object for customizing the query (e.g., filters, columns).    | No       |\n\n### Returns\n\n- **Table Name**: Returns a `MySQLHandler` instance for query chaining.\n- **Model**: Returns a `Promise<ResponseType>` containing the single record.\n\n### Example\n\n```typescript\nconst user = await db.findOne('users', {\n  where: 'id = 1',\n  columns: ['id', 'name', 'email'],\n}).execute();\nconsole.log(user); // Logs single record\n// SQL: SELECT id, name, email FROM users WHERE id = 1 LIMIT 1;\n```\n\n**Using a Model**:\n\n```typescript\nconst user = await User.findOne({\n  where: 'id = 1',\n  columns: ['id', 'name', 'email'],\n});\nconsole.log(user); // Logs single record\n```\n\n---\n\n## 3. JoinsType\n\n### Definition\n\n```typescript\nexport type JoinsType<Tables extends string[]> = Array<{\n  operator?: OperatorType | string;\n  type?: 'JOIN' | 'INNER JOIN' | 'OUTER JOIN' | 'CROSS JOIN' | 'RIGHT JOIN' | 'LEFT JOIN';\n} | {\n  on?: string;\n  table?: string;\n} | {\n  [key: string]: string;\n} | {\n  [P in Tables[number]]?: string;\n}>;\n```\n\n### Usage\n\nSpecifies join conditions for multi-table queries, including join type and operator.\n\n```typescript\nconst results = await db.findAll('users', {\n  joins: [\n    { type: 'INNER JOIN', table: 'profiles', on: 'users.id = profiles.user_id' },\n  ],\n  where: 'users.status = \"active\"',\n}).execute();\n// SQL: SELECT * FROM users INNER JOIN profiles ON users.id = profiles.user_id WHERE users.status = 'active';\n```\n\n---\n\n## 4. SortType\n\n### Definition\n\n```typescript\nexport type SortType<Tables extends string[]> = \n  | { [P in Tables[number]]?: Record<string, 1 | -1> }\n  | Record<string, 1 | -1>\n  | string;\n```\n\n### Usage\n\nDefines sorting criteria for query results. Use `1` for ascending and `-1` for descending.\n\n```typescript\nconst sortedResults = await db.findAll('products', {\n  sort: { price: -1 },\n}).execute();\n// SQL: SELECT * FROM products ORDER BY price DESC;\n```\n\n---\n\n## 5. OperatorType\n\n### Definition\n\n```typescript\nexport type OperatorType =\n  | '='\n  | '!='\n  | '<>'\n  | '<'\n  | '>'\n  | '<='\n  | '>='\n  | 'LIKE'\n  | 'IN'\n  | 'BETWEEN';\n```\n\n### Usage\n\nUsed in `where` clauses to define conditions.\n\n```typescript\nconst results = await db.findAll('orders', {\n  where: 'totalAmount > 100 AND status = \"completed\"',\n}).execute();\n// SQL: SELECT * FROM orders WHERE totalAmount > 100 AND status = 'completed';\n```\n\n---\n\n## 6. FindOneParamsType\n\n### Definition\n\n```typescript\nexport interface FindOneParamsType<Tables extends string[]> {\n  distinct?: boolean;\n  sort?: SortType<Tables>;\n  columns?: { [P in Tables[number]]?: string[] } | string | string[];\n  groupBy?: { [P in Tables[number]]?: string[] } | string | string[];\n  aggregates?: Array<{ [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string }>;\n  where?: string;\n  having?: string;\n  subQueries?: { query: string; as?: string }[];\n  joins?: JoinsType<Tables>;\n  recursiveCTE?: { baseCase: string; recursiveCase: string; alias: string };\n}\n```\n\n### Usage\n\nConfigures the `findOne` query with filters, sorting, and other options.\n\n```typescript\nconst user = await db.findOne('users', {\n  where: 'id = 1',\n  columns: ['id', 'name'],\n  joins: [{ type: 'LEFT JOIN', table: 'profiles', on: 'users.id = profiles.user_id' }],\n}).execute();\n// SQL: SELECT users.id, users.name FROM users LEFT JOIN profiles ON users.id = profiles.user_id WHERE id = 1 LIMIT 1;\n```\n\n---\n\n## 7. FindAllParamsType\n\n### Definition\n\n```typescript\nexport interface FindAllParamsType<Tables extends string[]> {\n  distinct?: boolean;\n  sort?: SortType<Tables>;\n  limitSkip?: { limit?: number; skip?: number };\n  columns?: { [P in Tables[number]]?: string[] } | string | string[];\n  groupBy?: { [P in Tables[number]]?: string[] } | string | string[];\n  aggregates?: Array<{ [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string }>;\n  where?: string;\n  having?: string;\n  subQueries?: { query: string; as?: string }[];\n  joins?: JoinsType<Tables>;\n  recursiveCTE?: { baseCase: string; recursiveCase: string; alias: string };\n}\n```\n\n### Usage\n\nConfigures the `findAll` query with pagination, filtering, and other options.\n\n```typescript\nconst results = await db.findAll('users', {\n  limitSkip: { limit: 5, skip: 10 },\n  where: 'status = \"active\"',\n  columns: ['id', 'name'],\n  sort: { name: 1 },\n  aggregates: [{ COUNT: 'id', alias: 'user_count' }],\n  groupBy: ['status'],\n  having: 'COUNT(id) > 2',\n}).execute();\n// SQL: SELECT users.id, users.name, COUNT(id) AS user_count FROM users WHERE status = 'active' GROUP BY status HAVING COUNT(id) > 2 ORDER BY name ASC LIMIT 5 OFFSET 10;\n```\n\n---\n"
            },
            {
              "originalPath": "Update.md",
              "id": 18,
              "name": "Update",
              "type": "file",
              "path": "api-reference/crud/update",
              "content": "\n# `@dbnx/mysql` update Method API Reference\n\nThe `update` method in `@dbnx/mysql` enables updating records in a MySQL database table or model based on specified conditions. It supports flexible configuration, including direct value updates, `CASE` expressions, joins, sorting, limits, and calculated fields, making it suitable for both simple and complex update operations.\n\n---\n\n## 1. Overview\n\nThe `update` method modifies existing records in a specified table or model, offering extensive customization through the `UpdateParamsType` interface. It supports both table-based queries (for query building) and model-based queries (for immediate execution), with options for conditional updates, joins, sorting, and more.\n\n---\n\n## 2. Method Signature\n\n```typescript\npublic update<tables extends string[]>(table: string, props: UpdateParamsType<tables>): MySQLHandler;\npublic update<tables extends string[]>(model: typeof Model, props: UpdateParamsType<tables>): Promise<ResponseType>;\npublic update(...args: any): MySQLHandler | Promise<ResponseType>;\n```\n\n---\n\n## 3. Parameters\n\n| Parameter | Type                     | Description                                                                 | Required |\n|-----------|--------------------------|-----------------------------------------------------------------------------|----------|\n| `table`   | `string`                 | Name of the table to update (e.g., `'users'`).                              | Yes (if not using model) |\n| `model`   | `typeof Model`           | Model class for ORM-based updates (e.g., `User`).                           | Yes (if not using table) |\n| `props`   | `UpdateParamsType`       | Configuration object specifying update values, conditions, and options.     | Yes      |\n\n---\n\n## 4. Response\n\n- **Table Name**: Returns a `MySQLHandler` instance for query chaining (e.g., with `.build()` or `.execute()`).\n- **Model**: Returns a `Promise<ResponseType>` containing the result of the update operation (e.g., number of affected rows).\n\n---\n\n## 5. UpdateParamsType\n\nThe `UpdateParamsType` interface defines the configuration for the update operation.\n\n```typescript\nexport type UpdateParamsType<Tables extends string[]> = {\n  values?: {\n    [key: string]: string | number | null | {\n      case: { when: string; then: any }[];\n      default: any;\n    };\n  };\n  sort?: { [P in Tables[number]]?: Record<string, 1 | -1> } | Record<string, 1 | -1> | string;\n  where: string;\n  defaultValues?: string[];\n  limit?: string | number;\n  joins?: JoinsType<Tables>;\n  fromSubQuery?: Record<string, string>;\n  setCalculations?: { [key: string]: string };\n};\n```\n\n### Parameters\n\n| Parameter          | Type                                      | Description                                                                 |\n|--------------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `values`           | `object`                                  | Columns and values to update (direct values or `CASE` expressions).         |\n| `sort`             | `object \\| string`                        | Sorting criteria (e.g., `{ name: 1 }` for ascending).                       |\n| `where`            | `string`                                  | Condition for selecting records (e.g., `'id = 5'`).                         |\n| `defaultValues`    | `string[]`                                | Columns to set to their default values.                                    |\n| `limit`            | `string \\| number`                        | Maximum number of records to update.                                       |\n| `joins`            | `JoinsType<Tables>`                       | Join conditions for multi-table updates.                                   |\n| `fromSubQuery`     | `Record<string, string>`                  | Subquery for updating records.                                             |\n| `setCalculations`  | `{ [key: string]: string }`               | Calculated values (e.g., `{ total_price: 'quantity * unit_price' }`).       |\n\n---\n\n## 6. Examples\n\n### Updating Records Using a Table Name\n\nConstruct an update query with sorting, limit, and joins.\n\n```typescript\nconst query = db.update('users', {\n  values: { age: 30, name: 'John' },\n  where: 'id = 5',\n  sort: { name: 'ASC' },\n  limit: 10,\n  joins: { type: 'INNER', table: 'orders', on: 'users.id = orders.user_id' },\n}).build();\nconsole.log(query);\n// SQL: UPDATE users INNER JOIN orders ON users.id = orders.user_id SET age = 30, name = 'John' WHERE id = 5 ORDER BY name ASC LIMIT 10;\n```\n\nExecute the query:\n\n```typescript\nconst result = await db.update('users', {\n  values: { age: 30, name: 'John' },\n  where: 'id = 5',\n}).execute();\nconsole.log(result); // Logs execution result\n```\n\n### Updating Records Using a Model\n\nUpdate records directly using a model.\n\n```typescript\nconst result = await User.update({\n  values: { age: 30, name: 'John' },\n  where: 'id = 5',\n  sort: { name: 'ASC' },\n  limit: 10,\n});\nconsole.log(result); // Logs result of update operation\n```\n\n### Using CASE Expressions\n\nPerform conditional updates with `CASE`.\n\n```typescript\nconst query = await db.update('users', {\n  values: {\n    age: {\n      case: [\n        { when: 'status = \"active\"', then: 35 },\n        { when: 'status = \"inactive\"', then: 25 },\n      ],\n      default: 30,\n    },\n  },\n  where: 'id = 5',\n}).build();\nconsole.log(query);\n// SQL: UPDATE users SET age = CASE WHEN status = 'active' THEN 35 WHEN status = 'inactive' THEN 25 ELSE 30 END WHERE id = 5;\n```\n\n### Using Joins and Calculations\n\nUpdate records with joins and calculated fields.\n\n```typescript\nconst query = await db.update('orders', {\n  values: { status: 'shipped' },\n  setCalculations: { total_price: 'quantity * unit_price' },\n  where: 'order_id = 100',\n  joins: { type: 'INNER', table: 'products', on: 'orders.product_id = products.id' },\n}).build();\nconsole.log(query);\n// SQL: UPDATE orders INNER JOIN products ON orders.product_id = products.id SET status = 'shipped', total_price = quantity * unit_price WHERE order_id = 100;\n```\n\n---\n\n## 7. Errors\n\n| Error Message                                      | Cause                                              | Solution                                                                 |\n|----------------------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------|\n| `No arguments provided to 'update'.`               | Missing table name or model.                       | Provide a valid table name or model as the first argument.               |\n| `Invalid first argument: must be a table name or a Model class.` | First argument is neither a string nor a model.    | Ensure the first argument is a valid table name or model class.          |\n| `Props must be a non-empty object.`                | Invalid or empty `props` object.                   | Provide a valid `UpdateParamsType` object with at least a `where` clause.|\n\n---\n\n## 8. Internal Methods\n\n- **`update`**: Constructs the SQL `UPDATE` query based on the provided parameters.\n- **`parseJoins`**: Formats the `joins` parameter into SQL `JOIN` clauses.\n- **`parseSort`**: Formats the `sort` parameter into SQL `ORDER BY` clauses.\n\n---\n\n## 9. Use Cases\n\n- **Simple Updates**: Update specific fields for records matching a condition (e.g., updating user details).\n- **Conditional Updates**: Use `CASE` expressions for dynamic updates based on conditions (e.g., setting different values for active vs. inactive users).\n- **Multi-Table Updates**: Use `joins` to update records across related tables (e.g., updating order status based on product data).\n- **Calculated Updates**: Use `setCalculations` for dynamic field updates (e.g., recalculating totals based on other columns).\n\n---\n"
            }
          ]
        }
      ]
    },
    {
      "originalPath": "81. .Utilities",
      "name": "Utilities",
      "path": "utilities",
      "type": "folder",
      "children": [
        {
          "originalPath": "1.Date Time.md",
          "id": 19,
          "name": "Date Time",
          "type": "file",
          "path": "utilities/date-time",
          "content": "\n## Functions\n\n### `mysql_datetime(date: Date | string): string`\n\nThis function takes a `Date` or `string` as input and formats it into MySQL's `DATETIME` format (`YYYY-MM-DD HH:mm:ss`).\n\n#### Parameters\n\n- `date`: A `Date` object or a string that can be parsed as a date.\n  - Example: `2024-11-24T14:30:00Z`, or `new Date()`.\n\n#### Returns\n\n- A string representing the date in MySQL `DATETIME` format: `YYYY-MM-DD HH:mm:ss`.\n\n#### Example Usage\n\n```javascript\nimport { mysql_datetime } from '@dbnx/mysql';\n\nconst date1 = mysql_datetime(new Date());\nconsole.log(date1);\n// Output: \"2024-11-24 14:30:00\"\n\nconst date2 = mysql_datetime('2024-11-24T14:30:00Z');\nconsole.log(date2);\n// Output: \"2024-11-24 14:30:00\"\n```\n\n---\n\n### `mysql_date(date: Date | string): string`\n\nThis function takes a `Date` or `string` as input and formats it into MySQL's `DATE` format (`YYYY-MM-DD`).\n\n#### Parameters\n\n- `date`: A `Date` object or a string that can be parsed as a date.\n  - Example: `2024-11-24T14:30:00Z`, or `new Date()`.\n\n#### Returns\n\n- A string representing the date in MySQL `DATE` format: `YYYY-MM-DD`.\n\n#### Example Usage\n\n```javascript\nimport { mysql_date } from '@dbnx/mysql';\n\nconst date1 = mysql_date(new Date());\nconsole.log(date1);\n// Output: \"2024-11-24\"\n\nconst date2 = mysql_date('2024-11-24T14:30:00Z');\nconsole.log(date2);\n// Output: \"2024-11-24\"\n```\n\n---\n\n### Notes\n\n- The `mysql_datetime` function ensures the date is always formatted in a consistent way, even for invalid input strings.\n- The `mysql_date` function provides a simpler date format, useful when only the date part (without time) is needed.\n"
        },
        {
          "originalPath": "2.Query Security Utilities.md",
          "id": 20,
          "name": "Query Security Utilities",
          "type": "file",
          "path": "utilities/query-security-utilities",
          "content": "\n---\n\n## **Function 1: `sanitize`**\n\n### **Purpose**\n\nSanitizes user input to make it safe for use in MySQL queries by escaping dangerous characters and converting `null` or `undefined` values to `NULL`.\n\n### **Usage**\n\n```typescript\nconst userInput = \"John's\"; // Untrusted user input\nconst sanitizedInput = sanitize(userInput); // Returns: 'John\\'s'\nconsole.log(sanitizedInput);\n```\n\n---\n\n## **Function 2: `escape`**\n\n### **Purpose**\n\nEscapes special characters in a string to neutralize SQL injection attempts. Handles `null`, `undefined`, `boolean`, and `number` inputs gracefully, returning safe representations for MySQL queries.\n\n### **Usage**\n\n```typescript\nconst dangerousInput = \"Robert'); DROP TABLE Students;--\";\nconst escapedValue = escape(dangerousInput);\n// Result: 'Robert\\'); DROP TABLE Students;--'\nconsole.log(escapedValue);\n```\n\n---\n\n## **Function 3: `format`**\n\n### **Purpose**\n\nFormats a query string by replacing placeholders (`?`) with sanitized and escaped values, ensuring secure parameterization of SQL queries.\n\n### **Definition**\n\n```typescript\n/**\n * Formats a query string by replacing placeholders (`?`) with escaped values.\n * @param query - The base SQL query with placeholders.\n * @param values - Array of values to replace placeholders.\n * @returns The formatted query string.\n */\nexport function format(query: string, values: any[]): string {\n    let i = 0;\n    return query.replace(/\\?/g, () => {\n        if (i >= values.length) {\n            throw new Error('Insufficient values provided for placeholders.');\n        }\n        const escapedValue = escape(values[i]);\n        i++;\n        return escapedValue;\n    });\n}\n```\n\n### **Usage**\n\n```typescript\nconst baseQuery = \"SELECT * FROM users WHERE username = ? AND status = ?\";\nconst params = [\"john_doe\", \"active\"];\nconst secureQuery = format(baseQuery, params);\n// Result: \"SELECT * FROM users WHERE username = 'john_doe' AND status = 'active'\"\nconsole.log(secureQuery);\n```\n\n---\n\n## **Enhanced Secure WHERE Clause**\n\nBuilds a secure `WHERE` clause for dynamic queries by sanitizing.\n\n```typescript\n\ndb.findAll('orders', {\n    where: sanitize('order_date BETWEEN \"2024-01-01\" AND \"2024-12-31\"'),\n    columns: ['id', 'customer_id', 'order_date'],\n});\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "82. Examples",
      "name": "Examples",
      "path": "examples",
      "type": "folder",
      "children": [
        {
          "originalPath": "1.Create Example.md",
          "id": 21,
          "name": "Create Example",
          "type": "file",
          "path": "examples/create-example",
          "content": "\n#### 1. Single Row Insert with Date Fields\n\n```typescript\n  const query = db.create('users', [{\n        id: 1,\n        name: 'John',\n        email: 'john@example.com',\n        avatar: null,\n        created_at: \"CURRENT_TIMESTAMP\"\n    }]);\nconsole.log(query.build())\n    //Output: INSERT INTO users (id, name, email, created_at) VALUES (1, 'John', 'john@example.com', CURRENT_TIMESTAMP)\n```\n\n#### 2. Multiple Row Insert with Date Fields\n\n```typescript\nconst query = db.create('users', [\n        {\n            id: 1,\n            name: 'John',\n            email: 'john@example.com'\n        },\n        {\n            id: 2,\n            name: 'Jane',\n            email: 'jane@example.com'\n        }\n]);\nconsole.log(query.build())\n//Output: INSERT INTO users (id, name, email) VALUES (1, 'John', 'john@example.com'), (2, 'Jane', 'jane@example.com')\n```\n\n#### 3. Insert with `ON DUPLICATE KEY UPDATE`\n\n```typescript\n\nconst user = db.create('users', [{\n     created_at: null,\n     username: 'dbnx',\n }], {\n     onDuplicateUpdateFields: ['name', 'email']\n }).build();\n// Output: INSERT INTO user (created_at, username) VALUES (NULL, 'dbnx') ON DUPLICATE KEY UPDATE name = VALUES(name), email = VALUES(email)      \n```\n\n#### 4. Insert with `INSERT IGNORE` to Prevent Duplicates\n\n```typescript\nconst query = db.create('users', {\n        id: 1, name: 'John', email: 'john@example.com'\n    },\n    {\n            uniqueColumn: 'id'\n}).build();\nconsole.log(query)\n// Output: INSERT IGNORE INTO users (id, name, email) VALUES (1, 'John', 'john@example.com')\n```\n"
        },
        {
          "originalPath": "2.Find Example.md",
          "id": 22,
          "name": "Find Example",
          "type": "file",
          "path": "examples/find-example",
          "content": "## `findOne`/`findAll`\n\n### **Beginner Level**\n\n1. **Select All Rows**\n\n   ```typescript\n   db.findAll('users', {});\n   ```\n\n2. **Select Specific Columns**\n\n   ```typescript\n   db.findAll('users', { columns: ['id', 'name'] });\n   ```\n\n3. **Add a WHERE Clause**\n\n   ```typescript\n   db.findAll('users', { where: 'age > 18' });\n   ```\n\n4. **Add Sorting**\n\n   ```typescript\n   db.findAll('users', { sort: { name: 1 } });\n   ```\n\n5. **Apply DISTINCT**\n\n   ```typescript\n   db.findAll('users', { distinct: true });\n   ```\n\n6. **Apply LIMIT and OFFSET**\n\n   ```typescript\n   db.findAll('users', { limitSkip: { limit: 5, skip: 10 } });\n   ```\n\n---\n\n### **Intermediate Level**\n\n7. **Group Results**\n\n   ```typescript\n   db.findAll('sales', {\n       groupBy: ['region'],\n       aggregates: [{ SUM: 'amount', alias: 'total_sales' }],\n   });\n   ```\n\n8. **Filter with HAVING**\n\n   ```typescript\n   db.findAll('sales', {\n       groupBy: ['region'],\n       aggregates: [{ SUM: 'amount', alias: 'total_sales' }],\n       having: 'SUM(amount) > 1000',\n   });\n   ```\n\n9. **Join Two Tables**\n\n   ```typescript\n   db.findAll('orders', {\n       joins: [\n           { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n       ],\n       columns: ['orders.id', 'customers.name'],\n   });\n   ```\n\n10. **Perform Aggregations**\n\n   ```typescript\n   db.findAll('products', {\n       aggregates: [{ COUNT: '*', alias: 'total_products' }],\n   });\n   ```\n\n11. **Use Multiple Aggregates**\n\n   ```typescript\n   db.findAll('sales', {\n       aggregates: [\n           { SUM: 'amount', alias: 'total_amount' },\n           { AVG: 'amount', alias: 'average_amount' },\n       ],\n   });\n   ```\n\n12. **Multiple WHERE Conditions**\n\n   ```typescript\n   db.findAll('users', { where: 'age > 18 AND active = 1' });\n   ```\n\n---\n\n### **Advanced Level**\n\n13. **Recursive CTE**\n\n   ```typescript\n   db.findAll('categories', {\n       recursiveCTE: {\n           baseCase: 'SELECT id, parent_id FROM categories WHERE parent_id IS NULL',\n           recursiveCase: 'SELECT c.id, c.parent_id FROM categories c INNER JOIN tree t ON c.parent_id = t.id',\n           alias: 'tree',\n       },\n       columns: ['id', 'parent_id'],\n   });\n   ```\n\n14. **Join with Aggregates**\n\n   ```typescript\n   db.findAll('orders', {\n       joins: [\n           { type: 'LEFT JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n       ],\n       aggregates: [{ COUNT: 'orders.id', alias: 'order_count' }],\n       groupBy: ['customers.id'],\n   });\n   ```\n\n15. **Subqueries**\n\n   ```typescript\n   db.findAll('products', {\n       subQueries: [\n           { query: 'SELECT MAX(price) FROM products', as: 'max_price' },\n       ],\n       columns: ['id', 'name'],\n   });\n   ```\n\n16. **Using Aggregates and Joins**\n\n   ```typescript\n   db.findAll('sales', {\n       joins: [{ type: 'INNER JOIN', on: 'sales.product_id = products.id', table: 'products' }],\n       aggregates: [{ SUM: 'sales.amount', alias: 'total_sales' }],\n       groupBy: ['products.category_id'],\n   });\n   ```\n\n17. **Nested Aggregates**\n\n   ```typescript\n   db.findAll('orders', {\n       groupBy: ['customer_id'],\n       aggregates: [{ COUNT: '*', alias: 'order_count' }],\n       having: 'COUNT(*) > (SELECT AVG(order_count) FROM orders GROUP BY customer_id)',\n   });\n   ```\n\n18. **Multiple Joins**\n\n   ```typescript\n   db.findAll('orders', {\n       joins: [\n           { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n           { type: 'LEFT JOIN', on: 'orders.product_id = products.id', table: 'products' },\n       ],\n       columns: ['orders.id', 'customers.name', 'products.name'],\n   });\n   ```\n\n---\n\n### **Advanced Examples with Complex Queries**\n\n19. **Combined Aggregates and Subqueries**\n\n   ```typescript\n   db.findAll('orders', {\n       aggregates: [\n           { SUM: 'total', alias: 'total_sales' },\n           { AVG: 'total', alias: 'average_order' },\n       ],\n       subQueries: [{ query: 'SELECT COUNT(*) FROM customers', as: 'customer_count' }],\n   });\n   ```\n\n20. **Dynamic WHERE and Joins**\n\n   ```typescript\n   db.findAll('orders', {\n       where: 'status = \"completed\"',\n       joins: [\n           { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n       ],\n   });\n   ```\n\n### **21. Filtering by a Date Range**\n\n```typescript\ndb.findAll('orders', {\n    where: 'order_date BETWEEN \"2024-01-01\" AND \"2024-12-31\"',\n    columns: ['id', 'customer_id', 'order_date'],\n});\n```\n\n---\n\n### **22. Filtering with `IN` Operator**\n\n```typescript\ndb.findAll('products', {\n    where: 'category_id IN (1, 2, 3)',\n    columns: ['id', 'name', 'category_id'],\n});\n```\n\n---\n\n### **23. Joining More Than Three Tables**\n\n```typescript\ndb.findAll('orders', {\n    joins: [\n        { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n        { type: 'LEFT JOIN', on: 'orders.product_id = products.id', table: 'products' },\n        { type: 'RIGHT JOIN', on: 'products.supplier_id = suppliers.id', table: 'suppliers' },\n    ],\n    columns: ['orders.id', 'customers.name', 'products.name', 'suppliers.name'],\n});\n```\n\n---\n\n### **24. Combining `UNION` in Subqueries**\n\n```typescript\ndb.findAll('employees', {\n    subQueries: [\n        { query: 'SELECT id, name FROM employees WHERE department_id = 1', as: 'sales_team' },\n        { query: 'SELECT id, name FROM employees WHERE department_id = 2', as: 'support_team' },\n    ],\n});\n```\n\n---\n\n### **25. Performing Window Functions (e.g., Ranking)**\n\n```typescript\ndb.findAll('employees', {\n    columns: [\n        'id', \n        'name', \n        { query: 'ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC)', as: 'rank' },\n    ],\n});\n```\n\n---\n\n### **26. Aggregating with a Custom Alias Logic**\n\n```typescript\ndb.findAll('sales', {\n    aggregates: [\n        { SUM: 'amount', alias: 'total_revenue' },\n        { MAX: 'amount', alias: 'highest_sale' },\n        { MIN: 'amount', alias: 'lowest_sale' },\n    ],\n});\n```\n\n---\n\n### **27. Joining with Multiple Conditions**\n\n```typescript\ndb.findAll('orders', {\n    joins: [\n        {\n            type: 'INNER JOIN',\n            on: 'orders.customer_id = customers.id AND orders.status = \"completed\"',\n            table: 'customers',\n        },\n    ],\n    columns: ['orders.id', 'customers.name'],\n});\n```\n\n---\n\n### **28. Including Raw SQL in `WHERE` or Joins**\n\n```typescript\ndb.findAll('products', {\n    where: 'price > (SELECT AVG(price) FROM products)',\n    columns: ['id', 'name', 'price'],\n});\n```\n\n---\n\n### **29. Using Multiple `HAVING` Conditions**\n\n```typescript\ndb.findAll('sales', {\n    groupBy: ['region'],\n    aggregates: [{ SUM: 'amount', alias: 'total_sales' }],\n    having: 'SUM(amount) > 1000 AND COUNT(*) > 10',\n});\n```\n\n---\n\n### **30. Recursive Hierarchy with Aggregates**\n\n```typescript\ndb.findAll('categories', {\n    recursiveCTE: {\n        baseCase: 'SELECT id, parent_id, name FROM categories WHERE parent_id IS NULL',\n        recursiveCase: 'SELECT c.id, c.parent_id, c.name FROM categories c INNER JOIN category_tree ct ON c.parent_id = ct.id',\n        alias: 'category_tree',\n    },\n    aggregates: [{ COUNT: 'id', alias: 'total_categories' }],\n    groupBy: ['parent_id'],\n});\n```\n\n---\n"
        },
        {
          "originalPath": "3.Update Example.md",
          "id": 23,
          "name": "Update Example",
          "type": "file",
          "path": "examples/update-example",
          "content": "\n---\n\n### **db.update('table_name', config)**\n\nThe `db.update` function allows you to perform an update on a table with a wide range of capabilities such as conditional updates, calculations, joins, and more. Below are various examples of how to use this function effectively.\n\n---\n\n### 1. **Simple Update**\n\nThis example demonstrates updating a single column with a constant value:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 60000 },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = 60000 WHERE id = 1;\n```\n\n---\n\n### 2. **Conditional Update with CASE WHEN**\n\nUse a `CASE` expression to conditionally update the column values:\n\n```typescript\nconst query = db.update('employees', {\n    values: {\n        salary: {\n            case: [\n                { when: \"position = 'Manager'\", then: 100000 },\n                { when: \"position = 'Developer'\", then: 80000 }\n            ],\n            default: 50000\n        }\n    },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = CASE WHEN position = 'Manager' THEN 100000\n//         WHEN position = 'Developer' THEN 80000 ELSE 50000 END WHERE id = 1;\n```\n\n---\n\n### 3. **Update with Calculation**\n\nHere, we apply a calculation to increase the salary by 10%:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 'salary * 1.1' },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = salary * 1.1 WHERE id = 1;\n```\n\n---\n\n### 4. **Update with Subquery in SET**\n\nThis example demonstrates updating a column using a subquery:\n\n```typescript\nconst query = db.update('orders', {\n    values: { total_amount: '(SELECT SUM(amount) FROM order_items WHERE order_id = orders.id)' },\n    where: 'status = \"pending\"'\n}).build();\nconsole.log(query);\n// Output: UPDATE orders SET total_amount = (SELECT SUM(amount) FROM order_items WHERE order_id = orders.id) WHERE status = 'pending';\n```\n\n---\n\n### 5. **Update Multiple Columns with Different Conditions**\n\nHere, we update multiple columns, each with its own condition:\n\n```typescript\nconst query = db.update('employees', {\n    values: {\n        salary: { case: [{ when: \"position = 'Manager'\", then: 120000 }], default: 50000 },\n        department: 'HR'\n    },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = CASE WHEN position = 'Manager' THEN 120000 ELSE 50000 END, department = 'HR' WHERE id = 1;\n```\n\n---\n\n### 6. **Update with NULL Values**\n\nSet columns to `NULL` for specific fields:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 70000, phone:null },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = 70000, phone = NULL WHERE id = 1;\n```\n\n---\n\n### 7. **Update with Default Values**\n\nHere we set certain columns to their default values:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 80000 },\n    defaultValues: ['address'],\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = 80000, address = DEFAULT WHERE id = 1;\n```\n\n---\n\n### 8. **Update with Joins**\n\nThis example demonstrates an update with a join between two tables:\n\n```typescript\nconst query = db.update('orders', {\n    values: { status: \"'completed'\" },\n    where: 'orders.id = 1',\n    joins: [\n        { type: 'INNER JOIN', table: 'customers', on: 'orders.customer_id = customers.id' }\n    ]\n}).build();\nconsole.log(query);\n// Output: UPDATE orders INNER JOIN customers ON orders.customer_id = customers.id SET status = 'completed' WHERE orders.id = 1;\n```\n\n---\n\n### 9. **Update with Sorting and Limit**\n\nUpdate the rows with sorting and limiting the number of rows to be updated:\n\n```typescript\nconst query = db.update('products', {\n    values: { price: 'price * 1.2' },\n    where: 'stock > 0',\n    sort: { name: -1 },\n    limit: 5\n}).build();\nconsole.log(query);\n// Output: UPDATE products SET price = price * 1.2 WHERE stock > 0 ORDER BY name DESC LIMIT 5;\n```\n\n---\n\n### 10. **Update with Multiple Joins**\n\nThis example demonstrates updating a table with multiple joins and complex conditions:\n\n```typescript\nconst query = db.update('orders', {\n    values: { total_amount: 'total_amount + (SELECT SUM(price) FROM order_items WHERE order_id = orders.id)' },\n    where: 'orders.status = \"pending\"',\n    joins: [\n        { type: 'INNER JOIN', table: 'order_items', on: 'orders.id = order_items.order_id' },\n        { type: 'LEFT JOIN', table: 'customers', on: 'orders.customer_id = customers.id' }\n    ]\n}).build();\nconsole.log(query);\n// Output: UPDATE orders INNER JOIN order_items ON orders.id = order_items.order_id LEFT JOIN customers ON orders.customer_id = customers.id\n//         SET total_amount = total_amount + (SELECT SUM(price) FROM order_items WHERE order_id = orders.id)\n//         WHERE orders.status = 'pending';\n```\n\n---\n"
        },
        {
          "originalPath": "4.Delete Example.md",
          "id": 24,
          "name": "Delete Example",
          "type": "file",
          "path": "examples/delete-example",
          "content": "### Delete Query Documentation Example for `db.delete()`\n\n---\n\n### 1. **Simple DELETE with WHERE Condition**\n\nDelete rows from the `employees` table where the `age` is greater than 60:\n\n```typescript\nconst result = await db.delete('employees', {\n    where: 'age > 60',\n    limit: 10\n}).build();\nconsole.log(result);\n// Output: DELETE FROM employees WHERE age > 60 LIMIT 10;\n```\n\n### 2. **DELETE with INNER JOIN**\n\nDelete rows from the `orders` table where the `status` is \"pending\" and join with the `customers` table based on the `customer_id`:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"pending\"',\n    joins: [\n        { type: 'INNER JOIN', table: 'customers', on: 'orders.customer_id = customers.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders INNER JOIN customers ON orders.customer_id = customers.id WHERE status = \"pending\";\n```\n\n### 3. **DELETE with LEFT JOIN**\n\nDelete rows from the `products` table where the `price` is lower than 100, while joining with the `categories` table using a `LEFT JOIN`:\n\n```typescript\nconst result = await db.delete('products', {\n    where: 'price < 100',\n    joins: [\n        { type: 'LEFT JOIN', table: 'categories', on: 'products.category_id = categories.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM products LEFT JOIN categories ON products.category_id = categories.id WHERE price < 100;\n```\n\n### 4. **DELETE with Sorting**\n\nDelete rows from the `orders` table where the `status` is \"shipped\" and sort the rows by `order_date` in descending order:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"shipped\"',\n    sort: { order_date: -1 }\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders WHERE status = \"shipped\" ORDER BY order_date DESC;\n```\n\n### 5. **DELETE with LIMIT**\n\nDelete only 5 rows from the `products` table where the `stock` is 0:\n\n```typescript\nconst result = await db.delete('products', {\n    where: 'stock = 0',\n    limit: 5\n}).build();\nconsole.log(result);\n// Output: DELETE FROM products WHERE stock = 0 LIMIT 5;\n```\n\n### 6. **DELETE with Multiple Joins**\n\nDelete rows from the `orders` table where the `status` is \"pending\", and join with both `customers` and `products` tables:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"pending\"',\n    joins: [\n        { type: 'INNER JOIN', table: 'customers', on: 'orders.customer_id = customers.id' },\n        { type: 'LEFT JOIN', table: 'products', on: 'orders.product_id = products.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders INNER JOIN customers ON orders.customer_id = customers.id LEFT JOIN products ON orders.product_id = products.id WHERE status = \"pending\";\n```\n\n### 7. **DELETE with WHERE, Sorting, and LIMIT**\n\nDelete rows from the `employees` table where the `position` is \"Intern\", sort by `hire_date` ascending, and limit to 10 rows:\n\n```typescript\nconst result = await db.delete('employees', {\n    where: 'position = \"Intern\"',\n    sort: { hire_date: 1 },\n    limit: 10\n}).build();\nconsole.log(result);\n// Output: DELETE FROM employees WHERE position = \"Intern\" ORDER BY hire_date ASC LIMIT 10;\n```\n\n### 8. **DELETE with WHERE and Complex Join**\n\nDelete rows from the `employees` table where the `salary` is greater than 50000, and join with `departments` and `projects` tables:\n\n```typescript\nconst result = await db.delete('employees', {\n    where: 'salary > 50000',\n    joins: [\n        { type: 'INNER JOIN', table: 'departments', on: 'employees.department_id = departments.id' },\n        { type: 'LEFT JOIN', table: 'projects', on: 'employees.project_id = projects.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM employees INNER JOIN departments ON employees.department_id = departments.id LEFT JOIN projects ON employees.project_id = projects.id WHERE salary > 50000;\n```\n\n### 9. **DELETE with RIGHT JOIN**\n\nDelete rows from the `orders` table where the `status` is \"cancelled\", and use a `RIGHT JOIN` with the `payments` table to identify orders with no payment:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"cancelled\"',\n    joins: [\n        { type: 'RIGHT JOIN', table: 'payments', on: 'orders.id = payments.order_id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders RIGHT JOIN payments ON orders.id = payments.order_id WHERE status = \"cancelled\";\n```\n\n### 10. **DELETE with Multiple Sorting Criteria**\n\nDelete rows from the `products` table where `stock` is less than 10, and sort by `price` in ascending order and `name` in descending order:\n\n```typescript\nconst result = await db.delete('products', {\n    where: 'stock < 10',\n    sort: { price: 1, name: -1 }\n}).build();\nconsole.log(result);\n// Output: DELETE FROM products WHERE stock < 10 ORDER BY price ASC, name DESC;\n```\n\n---\n\n### Notes\n\n- `where`: The condition for deleting rows (e.g., `age > 60` or `status = \"pending\"`).\n- `joins`: Array of JOIN operations for filtering data during deletion.\n- `limit`: The number of rows to delete.\n- `sort`: Sorting criteria to order the rows for deletion.\n- `table`: The name of the table from which rows will be deleted.\n"
        }
      ]
    }
  ],
  "files": [
    {
      "id": 1,
      "path": "getting-started/installation",
      "name": "Installation",
      "folder": "Getting Started",
      "content": "\n# `@dbnx/mysql`\n\nA lightweight MySQL client for Node.js, built on top of `mysql2`, providing a simple and secure way to interact with MySQL databases using prepared statements and connection pooling.\n\n---\n\n## 1. Installation\n\nInstall the `@dbnx/mysql` package and its dependency `mysql2` using npm or yarn.\n\n### Prerequisites\n\nInstall `mysql2`:\n\n```bash\nnpm install mysql2\n```\n\n### Install with npm\n\n```bash\nnpm install @dbnx/mysql\n```\n\n### Install with yarn\n\n```bash\nyarn add @dbnx/mysql\n```\n\n---\n\n## 2. Setup and Configuration\n\nImport the `@dbnx/mysql` package and initialize a database connection with your MySQL credentials.\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Database configuration\nconst dbConfig = {\n  host: 'localhost',\n  user: 'your-username',\n  password: 'your-password',\n  database: 'your-database-name',\n};\n\n// Initialize database instance\nconst dbInstance = new DBnx(dbConfig).connect();\n```\n\n---\n\n## 3. Usage Examples\n\nThe following examples demonstrate common database operations using `@dbnx/mysql`. All queries are executed asynchronously and support prepared statements for security.\n\n### Executing Raw SQL Queries\n\nRun a raw SQL query with parameterized inputs.\n\n```typescript\n(async () => {\n  const result = await dbInstance.execute('SELECT * FROM users WHERE age > ?', [25]);\n  console.log('Query Result:', result);\n})();\n```\n\n### Using Prepared Statements\n\nRetrieve data with a prepared statement for a specific user.\n\n```typescript\n(async () => {\n  const userId = 1;\n  const user = await dbInstance.execute('SELECT * FROM users WHERE id = ?', [userId]);\n  console.log('User Data:', user);\n})();\n```\n\n### Inserting Data\n\nInsert a new record into the database.\n\n```typescript\n(async () => {\n  const result = await dbInstance.execute(\n    'INSERT INTO users (name, email, age) VALUES (?, ?, ?)',\n    ['John Doe', 'john.doe@example.com', 30]\n  );\n  console.log('Insert Result:', result);\n})();\n```\n\n### Updating Data\n\nUpdate an existing record.\n\n```typescript\n(async () => {\n  const result = await dbInstance.execute('UPDATE users SET age = ? WHERE id = ?', [31, 1]);\n  console.log('Update Result:', result);\n})();\n```\n\n### Deleting Data\n\nDelete a record from the database.\n\n```typescript\n(async () => {\n  const result = await dbInstance.execute('DELETE FROM users WHERE id = ?', [1]);\n  console.log('Delete Result:', result);\n})();\n```\n\n---\n\n## 4. Closing the Connection\n\nClose the database connection when it is no longer needed to free up resources.\n\n```typescript\n(async () => {\n  try {\n    await dbInstance.close();\n    console.log('Database connection closed.');\n  } catch (error) {\n    console.error('Error closing connection:', error);\n  }\n})();\n```\n\n---\n\n## 5. Additional Notes\n\n### Error Handling\n\nAlways use `try-catch` blocks to handle errors gracefully during database operations.\n\n```typescript\n(async () => {\n  try {\n    const result = await dbInstance.execute('SELECT * FROM users WHERE id = ?', [1]);\n    console.log('Result:', result);\n  } catch (error) {\n    console.error('Database error:', error);\n  }\n})();\n```\n\n### Connection Pooling\n\nFor high-traffic applications, enable connection pooling to optimize performance. Configure the `connectionLimit` in the `dbConfig`.\n\n```typescript\nconst dbConfig = {\n  host: 'localhost',\n  user: 'your-username',\n  password: 'your-password',\n  database: 'your-database-name',\n  connectionLimit: 10, // Maximum number of connections in the pool\n};\n\nconst dbInstance = new DBnx(dbConfig).connect();\n```\n\n---\n"
    },
    {
      "id": 2,
      "path": "getting-started/configuration",
      "name": "Configuration",
      "folder": "Getting Started",
      "content": "\n# `@dbnx/mysql` Advanced Features\n\nThis section covers advanced usage of the `@dbnx/mysql` package, including initializing database connections, defining models, executing queries, and leveraging connection pooling. Built on `mysql2`, this package provides a robust and flexible interface for MySQL interactions in Node.js.\n\n---\n\n## 1. Initializing DBnx\n\nThe `DBnx` class is used to establish a MySQL database connection. It supports configuration via a configuration object or a MySQL connection URL, with optional connection pooling.\n\n### Initialization Example\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Database configuration\nconst dbConfig = {\n  host: 'localhost',              // MySQL server hostname (default: 'localhost')\n  user: 'root',                   // MySQL username (default: 'root')\n  password: '11224455',           // MySQL password\n  database: 'world',              // Database name\n  waitForConnections: true,       // Wait for connections when pool is full (default: true)\n  multipleStatements: true,       // Allow multiple SQL statements per query (default: true)\n  connectionLimit: 10,            // Maximum connections in pool (default: 10)\n  queueLimit: 0,                  // Maximum queued connection requests (default: 0, no limit)\n};\n\n// Initialize with connection pooling enabled\nconst db = new DBnx(dbConfig, true).connect((err, success) => {\n  if (err) console.error('Connection error:', err);\n  else console.log('Connected successfully');\n});\n```\n\n### Configuration Options\n\n| Option                | Type      | Description                                                                 | Default         |\n|-----------------------|-----------|-----------------------------------------------------------------------------|-----------------|\n| `host`                | `string`  | MySQL server hostname or IP address.                                        | `'localhost'`   |\n| `user`                | `string`  | MySQL username.                                                             | `'root'`        |\n| `password`            | `string`  | MySQL password.                                                             | `''`            |\n| `database`            | `string`  | Name of the database to connect to.                                         | `undefined`     |\n| `waitForConnections`  | `boolean` | Wait for a connection when the pool is full.                                | `true`          |\n| `multipleStatements`  | `boolean` | Allow multiple SQL statements in a single query.                            | `true`          |\n| `connectionLimit`     | `number`  | Maximum number of connections in the pool.                                  | `10`            |\n| `queueLimit`          | `number`  | Maximum number of queued connection requests (0 = no limit).                | `0`             |\n\n### Connection Pooling\n\nConnection pooling optimizes performance by reusing database connections. Enable or disable pooling using the second argument in the `DBnx` constructor:\n\n- `true`: Enable connection pooling (default).\n- `false`: Disable connection pooling.\n\nExample with pooling disabled:\n\n```typescript\nconst db = new DBnx(dbConfig, false).connect((err, success) => {\n  if (err) console.error('Connection error:', err);\n  else console.log('Connected successfully');\n});\n```\n\n### Connecting with a MySQL URL\n\nYou can initialize `DBnx` using a MySQL connection URL in the format:\n\n```bash\nmysql://user:password@host:port/database\n```\n\n- `user`: MySQL username.\n- `password`: MySQL password.\n- `host`: MySQL server hostname or IP.\n- `port`: MySQL port (default: `3306`).\n- `database`: Database name.\n\n#### Example\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// MySQL connection URL\nconst connectionUrl = 'mysql://root:11224455@localhost:3306/world';\n\n// Initialize with pooling enabled\nconst db = new DBnx(connectionUrl, true).connect((err, success) => {\n  if (err) console.error('Connection error:', err);\n  else console.log('Connected successfully');\n});\n```\n\n---\n\n## 2. Defining Models\n\nThe `Model` class allows you to define the structure of database tables, including fields, data types, constraints, and relationships.\n\n### Model Definition Example\n\n```typescript\nimport { Model } from '@dbnx/mysql';\nimport { db } from './server'; // Import initialized DBnx instance\n\n// Define 'User' model using db.define\nconst User = db.define('User', {\n  username: {\n    type: 'VARCHAR(50)',      // Field data type\n    allowNull: false,         // Field cannot be NULL\n    defaultValue: null,       // Default value\n    unique: true,             // Enforce unique values\n  },\n  created_at: {\n    type: 'TIMESTAMP',        // Field data type\n    defaultValue: 'CURRENT_TIMESTAMP', // Default to current timestamp\n  },\n}, {\n  // Table options (see below)\n});\n\n// Define 'Product' model using Model.init\nconst Product = Model.init('Product', {\n  product_id: {\n    type: 'BIGINT',           // Field data type\n    autoIncrement: true,      // Auto-incrementing ID\n    primaryKey: true,         // Primary key\n    unique: true,             // Enforce unique values\n  },\n  title: {\n    type: 'VARCHAR(255)',     // Field data type\n    defaultValue: null,       // Default value\n  },\n  created_at: {\n    type: 'TIMESTAMP',        // Field data type\n    defaultValue: 'CURRENT_TIMESTAMP', // Default to current timestamp\n  },\n  updated_at: {\n    type: 'TIMESTAMP',        // Field data type\n    allowNull: false,         // Field cannot be NULL\n    defaultValue: 'CURRENT_TIMESTAMP', // Default to current timestamp\n    onUpdate: 'CURRENT_TIMESTAMP', // Update on record change\n  },\n}, db, {\n  // Table options (see below)\n});\n```\n\n### Table Options\n\nTable options can be passed as the third argument to `db.define` or `Model.init`:\n\n```typescript\nexport type TableOptions = {\n  engine?: string;           // Database engine (e.g., 'InnoDB', 'MyISAM')\n  charset?: string;          // Character set (e.g., 'utf8mb4')\n  collation?: string;        // Collation (e.g., 'utf8mb4_unicode_ci')\n  auto_increment?: number;   // Starting value for auto-increment (default: 1)\n};\n```\n\n### Field Properties\n\nEach field in a model can include the following properties:\n\n| Property         | Type      | Description                                                                 |\n|------------------|-----------|-----------------------------------------------------------------------------|\n| `type`           | `string`  | SQL data type (e.g., `VARCHAR(50)`, `BIGINT`, `TIMESTAMP`).                 |\n| `defaultValue`   | `any`     | Default value for the field (e.g., `null`, `'CURRENT_TIMESTAMP'`).          |\n| `allowNull`      | `boolean` | Whether the field can be `NULL` (default: `true`).                          |\n| `unique`         | `boolean` | Enforce unique values for the field.                                       |\n| `primaryKey`     | `boolean` | Mark the field as the primary key.                                         |\n| `autoIncrement`  | `boolean` | Enable auto-increment for the field (e.g., for IDs).                        |\n| `references`     | `string`  | Foreign key reference to another table.                                    |\n| `onUpdate`       | `string`  | Behavior on update (e.g., `'CURRENT_TIMESTAMP'` for timestamps).            |\n| `modifyColumn`   | `string`  | Rename the column to another name.                                        |\n\n### Model Methods\n\n- **`db.define(tableName, fields, options)`**: Define a new model for a table.\n  - `tableName`: Name of the table.\n  - `fields`: Object defining the fields and their properties.\n  - `options`: Table options (e.g., engine, charset).\n\n- **`Model.init(tableName, fields, dbHandler, options)`**: Initialize a model and attach it to the `DBnx` instance.\n  - `tableName`: Name of the table.\n  - `fields`: Field definitions.\n  - `dbHandler`: Initialized `DBnx` instance.\n  - `options`: Table options.\n\n---\n\n## 3. Query Execution with DBnx\n\nExecute raw SQL queries using the `execute` method. Queries are asynchronous and support prepared statements for security.\n\n### Example\n\n```typescript\nconst fetchData = async () => {\n  try {\n    const result = await db.execute('SELECT * FROM users');\n    console.log('Query Result:', result);\n  } catch (error) {\n    console.error('Error executing query:', error);\n  }\n};\n\nfetchData();\n```\n\n- The `execute` method accepts an SQL string and optional parameters for prepared statements.\n- Always use `try-catch` for error handling.\n\n---\n\n## 4. Summary of Key Features\n\n- **Connection Pooling**: Efficiently manage multiple connections with customizable pool settings.\n- **Model Definition**: Define table structures with `db.define` or `Model.init`, supporting advanced field configurations.\n- **Flexible Querying**: Execute raw SQL queries with `execute` for full control.\n- **URL-Based Connections**: Simplify configuration with MySQL connection URLs.\n- **Type Safety**: Define fields with precise data types and constraints.\n\n---\n"
    },
    {
      "id": 3,
      "path": "getting-started/logger-function",
      "name": "Logger Function",
      "folder": "Getting Started",
      "content": "\n# `@dbnx/mysql` Constructor\n\nThe `DBnx` constructor initializes a MySQL database connection with flexible configuration options, supporting both single connections and connection pooling. It also allows custom logging for debugging and monitoring.\n\n---\n\n## Constructor Signatures\n\nThe `DBnx` constructor supports multiple signatures to accommodate different use cases:\n\n```typescript\nconstructor(dbConfig: ConnectionOptions | PoolOptions | string, usePool?: boolean, logger?: (log: any) => void)\nconstructor(dbConfig: ConnectionOptions | PoolOptions | string, logger?: (log: any) => void)\nconstructor(dbConfig: ConnectionOptions | PoolOptions | string)\n```\n\n---\n\n## Parameters\n\n| Parameter    | Type                                      | Description                                                                 | Default        |\n|--------------|-------------------------------------------|-----------------------------------------------------------------------------|----------------|\n| `dbConfig`   | `ConnectionOptions | PoolOptions | string` | Database configuration. Can be a configuration object or a MySQL connection URL. | -              |\n| `usePool`    | `boolean` (optional)                      | Enable connection pooling.                                                  | `false`        |\n| `logger`     | `(log: any) => void` (optional)           | Callback function for logging connection events and queries.                | `undefined`    |\n\n### `dbConfig` Details\n\n- **As an Object** (`ConnectionOptions | PoolOptions`):\n  - Includes properties like `host`, `user`, `password`, `database`, `connectionLimit`, etc.\n- **As a String**:\n  - A MySQL connection URL in the format: `mysql://user:password@host:port/database`.\n\n### `usePool`\n\n- `true`: Enables connection pooling for efficient management of multiple connections.\n- `false`: Uses a single connection (default).\n\n### `logger`\n\n- A function that receives log messages (e.g., connection events, query details) for debugging or monitoring.\n\n---\n\n## Example Usage\n\nInitialize a `DBnx` instance with connection pooling and custom logging:\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize with configuration object, pooling, and logging\nconst db = new DBnx(\n  {\n    host: 'localhost',              // MySQL server hostname\n    user: 'root',                   // MySQL username\n    password: '12345678',           // MySQL password\n    database: 'world',              // Database name\n    waitForConnections: true,       // Wait for connections when pool is full\n    multipleStatements: true,       // Allow multiple SQL statements\n    connectionLimit: 10,            // Maximum connections in pool\n    queueLimit: 0,                  // No limit on queued requests\n  },\n  true, // Enable connection pooling\n  (log) => console.log('Log:', log) // Custom logging\n).connect();\n```\n\n---\n\n## Key Features\n\n1. **Flexible Configuration**:\n   - Supports both configuration objects and MySQL connection URLs for easy setup.\n2. **Connection Pooling**:\n   - Optional pooling via the `usePool` parameter, optimizing performance for high-traffic applications.\n3. **Custom Logging**:\n   - Integrates with custom logging systems through the `logger` callback.\n4. **Dynamic Initialization**:\n   - Adapts to various use cases with optional parameters for pooling and logging.\n\n---\n\n## Advanced Configurations\n\n### Using a Connection URL\n\nInitialize with a MySQL connection URL and enable pooling:\n\n```typescript\nconst db = new DBnx(\n  'mysql://root:12345678@localhost:3306/world',\n  true, // Enable pooling\n  (log) => console.log('Log:', log)\n).connect();\n```\n\n### Single Connection without Logging\n\nInitialize a single connection without pooling or logging:\n\n```typescript\nconst db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '12345678',\n  database: 'world',\n}).connect();\n```\n\n### Single Connection with Logging\n\nInitialize a single connection with custom logging:\n\n```typescript\nconst db = new DBnx(\n  {\n    host: 'localhost',\n    user: 'root',\n    password: '12345678',\n    database: 'world',\n  },\n  (log) => console.log('Log:', log)\n).connect();\n```\n\n---\n"
    },
    {
      "id": 4,
      "path": "condition",
      "name": "Condition",
      "folder": ".",
      "content": "\n# `@dbnx/mysql` `dbnxCondition`\n\nThe `dbnxCondition` function generates SQL `WHERE` clause conditions from a filters object, supporting a wide range of operators and logical combinations. It is designed to create secure, dynamic SQL queries for use with the `@dbnx/mysql` package.\n\n---\n\n## 1. Importing the Function\n\nImport the `dbnxCondition` function or initialize a `DBnx` instance to use the `condition` method.\n\n```typescript\nimport { dbnxCondition } from '@dbnx/mysql';\n```\n\n### Initializing DBnx for Use with `condition`\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nexport const db = new DBnx({\n  host: 'localhost',              // Database host\n  user: 'root',                   // Database user\n  password: '11224455',           // Database password\n  database: 'world',              // Database name\n  waitForConnections: true,       // Wait for connections when pool is full\n  multipleStatements: true,       // Allow multiple SQL statements\n  connectionLimit: 10,            // Maximum connections in pool\n  queueLimit: 0,                  // No limit on queued requests\n}).connect()\n\n// Example usage with db.condition\nconst result = await db.findOne('users', {\n  where: db.condition({ name: 'dbnx' })\n}).execute();\nconsole.log(result);\n```\n\n---\n\n## 2. Function Signature\n\n```typescript\ndbnxCondition(filters: Filters, joinBy: 'AND' | 'OR' = 'AND'): string\n```\n\n### Parameters\n\n- **`filters`** (`Filters`): An object defining the conditions for the SQL query.\n- **`joinBy`** (`'AND' | 'OR'`, optional): Logical operator to combine top-level conditions. Defaults to `'AND'`.\n\n### Returns\n\n- A `string` representing the SQL `WHERE` clause condition.\n\n---\n\n## 3. Filters Type\n\n### FilterValue Type\n\nThe `FilterValue` type defines the possible values for conditions in the `filters` object:\n\n| Value Type                              | Description                                                                 |\n|-----------------------------------------|-----------------------------------------------------------------------------|\n| `string | number`                       | Equality check (e.g., `status = 'active'`).                                 |\n| `Array<string | number>`                | `IN` check (e.g., `tags IN ('electronics', 'home')`).                      |\n| `{ in: Array<string | number> }`        | Explicit `IN` check (same as array).                                        |\n| `{ notIn: Array<string | number> }`     | `NOT IN` check (e.g., `location NOT IN ('New York', 'California')`).       |\n| `{ between: [number, number] }`         | `BETWEEN` check (e.g., `price BETWEEN 1000 AND 5000`).                     |\n| `{ notBetween: [number, number] }`      | `NOT BETWEEN` check.                                                       |\n| `{ inRange: [number, number] }`         | Range check (alias for `BETWEEN`).                                         |\n| `{ like: string }`                      | `LIKE` check (e.g., `title LIKE '%phone%'`).                               |\n| `{ notLike: string }`                   | `NOT LIKE` check (e.g., `description NOT LIKE '%old%'`).                   |\n| `{ regexp: string }`                    | `REGEXP` check (e.g., `brand REGEXP '^Samsung'`).                          |\n| `{ isNull: boolean }`                   | `IS NULL` or `IS NOT NULL` check (e.g., `updatedAt IS NULL`).              |\n| `{ $or: FilterValue[] }`                | Logical OR condition (e.g., `(color LIKE 'red' OR color LIKE 'blue')`).    |\n| `{ $and: FilterValue[] }`               | Logical AND condition (e.g., `(category = 'electronics' AND brand = 'Samsung')`). |\n| `{ eq: string | number }`               | Equality check (e.g., `status = 'active'`).                                |\n| `{ neq: string | number }`              | Not equal check (e.g., `status != 'inactive'`).                            |\n| `{ gt: number }`                        | Greater than check (e.g., `price > 1000`).                                 |\n| `{ lt: number }`                        | Less than check (e.g., `price < 5000`).                                    |\n| `{ gte: number }`                       | Greater than or equal check (e.g., `price >= 1000`).                       |\n| `{ lte: number }`                       | Less than or equal check (e.g., `price <= 5000`).                          |\n\n### Filters Type\n\nThe `Filters` type represents the structure of the `filters` object, supporting both direct column filters and logical groupings:\n\n```typescript\ntype Filters = {\n  [key: string]: FilterValue; // Direct column filters\n} | {\n  $or?: Record<string, FilterValue>; // Logical OR conditions\n  $and?: Record<string, FilterValue>; // Logical AND conditions\n};\n```\n\n---\n\n## 4. Usage Example\n\nGenerate a complex SQL `WHERE` clause using `dbnxCondition`:\n\n```typescript\nimport { dbnxCondition, Filters } from '@dbnx/mysql';\n\n// Define filters\nconst filters: Filters = {\n  status: 'active',                       // Equality\n  price: { between: [1000, 5000] },      // Range\n  tags: ['electronics', 'home'],         // IN\n  location: { notIn: ['New York', 'California'] }, // NOT IN\n  stock: { inRange: [10, 50] },          // Range\n  updatedAt: { isNull: true },            // NULL check\n  title: { like: '%phone%' },            // Pattern matching\n  description: { notLike: '%old%' },     // Negative pattern\n  color: {\n    $or: [\n      { like: 'red' },\n      { like: 'blue' },\n    ],                                   // OR condition\n  },\n  $and: {\n    category: 'electronics',\n    brand: { regexp: '^Samsung' },       // Regular expression\n  },\n};\n\n// Generate SQL condition\nconst sqlCondition = dbnxCondition(filters, 'AND');\n\nconsole.log(sqlCondition);\n```\n\n### Output\n\n```sql\nstatus = 'active' AND \nprice BETWEEN 1000 AND 5000 AND \ntags IN ('electronics', 'home') AND \nlocation NOT IN ('New York', 'California') AND \nstock BETWEEN 10 AND 50 AND \nupdatedAt IS NULL AND \ntitle LIKE '%phone%' AND \ndescription NOT LIKE '%old%' AND \n(color LIKE 'red' OR color LIKE 'blue') AND \n(category = 'electronics' AND brand REGEXP '^Samsung')\n```\n\n### Integration with DBnx\n\nUse the generated condition in a query:\n\n```typescript\nconst result = await db.findOne('products', {\n  where: db.condition(filters)\n}).execute();\nconsole.log(result);\n```\n\n---\n\n## 5. Function Details\n\n1. **Supported Conditions**:\n   - Equality (`eq`, direct string/number values).\n   - Inequality (`neq`, `gt`, `lt`, `gte`, `lte`).\n   - List checks (`in`, `notIn`).\n   - Range checks (`between`, `notBetween`, `inRange`).\n   - Pattern matching (`like`, `notLike`, `regexp`).\n   - NULL checks (`isNull`).\n   - Logical groupings (`$and`, `$or`).\n\n2. **Logical Operators**:\n   - Top-level conditions are combined using `joinBy` (`AND` or `OR`).\n   - Nested conditions use `$and` or `$or` for complex logic.\n\n3. **Security**:\n   - Inputs are sanitized to prevent SQL injection, ensuring safe query generation.\n\n---\n\n## 6. Notes\n\n- Use `db.condition()` when working with an initialized `DBnx` instance, or `dbnxCondition` as a standalone function.\n- Combine multiple logical operators (`$and`, `$or`) for complex queries.\n- Ensure filter values match the expected column types to avoid SQL errors.\n- The function is designed for `WHERE` clauses but can be adapted for other SQL clauses with manual concatenation.\n\n---\n"
    },
    {
      "id": 5,
      "path": "model/create-model",
      "name": "Create Model",
      "folder": "Model",
      "content": "\n# `@dbnx/mysql` Dynamic Model\n\nThe `@dbnx/mysql` package provides a flexible and powerful way to define database models dynamically using the `Model` class. Models represent database tables, allowing you to specify column types, constraints, relationships, and table options. This documentation covers model definition, configuration, and common CRUD operations.\n\n---\n\n## 1. Dependencies\n\nTo define models, you need the following components from `@dbnx/mysql`:\n\n- **`DBnx`**: Manages database connections and executes SQL commands.\n- **`Model`**: Base class for defining table structures.\n- **`DataTypes`**: Utility for specifying column data types.\n\n### Example: Initialize DBnx\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nexport const db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '11224455',\n  database: 'world',\n  waitForConnections: true,    // Wait for connections when pool is full\n  multipleStatements: true,    // Allow multiple SQL statements\n  connectionLimit: 10,         // Maximum connections in pool\n  queueLimit: 0,               // No limit on queued requests\n}).connect();\n```\n\n---\n\n## 2. Model Definition\n\nModels are defined using either `Model.init` or `db.define`, specifying table name, column configurations, and optional table settings.\n\n### Example: Product Model\n\nDefine a `product` table using `Model.init`:\n\n```typescript\nimport { Model } from '@dbnx/mysql';\n\nconst Product = Model.init('product', {\n  product_id: {\n    type: 'BIGINT',\n    autoIncrement: true,\n    primaryKey: true,\n    unique: true,\n  },\n  title: {\n    type: 'VARCHAR(255)',\n    defaultValue: null,\n  },\n  brand: {\n    type: 'VARCHAR(255)',\n    defaultValue: 'hello',\n  },\n  created_at: {\n    type: 'TIMESTAMP',\n    defaultValue: 'CURRENT_TIMESTAMP',\n  },\n  updated_at: {\n    type: 'TIMESTAMP',\n    allowNull: false,\n    defaultValue: 'CURRENT_TIMESTAMP',\n    onUpdate: 'CURRENT_TIMESTAMP',\n  },\n}, db);\n```\n\n### Example: Users Model\n\nDefine a `users` table using `db.define` with advanced options:\n\n```typescript\nimport { DataTypes } from '@dbnx/mysql';\n\nconst Users = db.define('users', {\n  username: {\n    type: DataTypes.SMALLINT(),\n    defaultValue: null,\n    unique: true,\n  },\n  city: {\n    type: DataTypes.INT(),\n    allowNull: true,\n    references: {\n      model: 'city',\n      key: 'ID',\n      onDelete: 'SET NULL',\n      onUpdate: 'CASCADE',\n    },\n  },\n  status: {\n    type: DataTypes.ENUM(),\n    values: ['active', 'inactive'],\n  },\n  created_at: {\n    type: DataTypes.TIMESTAMP(),\n    onUpdate: 'CURRENT_TIMESTAMP',\n  },\n}, {\n  auto_increment: 100,\n  charset: 'utf8mb4',\n  collation: 'utf8mb4_unicode_ci',\n});\n```\n\n### Table Options\n\nTable options customize the table's properties:\n\n```typescript\ntype TableOptions = {\n  engine?: string;           // e.g., 'InnoDB', 'MyISAM'\n  charset?: string;          // e.g., 'utf8mb4'\n  collation?: string;        // e.g., 'utf8mb4_unicode_ci'\n  auto_increment?: number;   // Starting value for auto-increment (default: 1)\n};\n```\n\n### Column Options\n\nEach column in a model can include the following properties:\n\n| Property         | Type                                      | Description                                                                 |\n|------------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `type`           | `string`                                  | Data type (e.g., `VARCHAR(255)`, `BIGINT`, `TIMESTAMP`).                    |\n| `modifyColumn`   | `string`                                  | Rename the column in the database.                                         |\n| `onUpdate`       | `string \\| 'CURRENT_TIMESTAMP'`            | Action on update (e.g., `CURRENT_TIMESTAMP` for timestamps).                |\n| `allowNull`      | `boolean`                                 | Allow `NULL` values (default: `true`).                                     |\n| `primaryKey`     | `boolean`                                 | Mark as primary key.                                                       |\n| `autoIncrement`  | `boolean`                                 | Enable auto-increment.                                                     |\n| `defaultValue`   | `string | number \\| 'CURRENT_TIMESTAMP' \\| null` \\| Default value for the column.                                              |\n| `references`     | `object \\| string`                         | Foreign key configuration (model, key, `onDelete`, `onUpdate`).          |\n| `unique`         | `boolean`                                 | Enforce unique values.                                                     |\n| `values`         | `string[]`                                | Allowed values for `ENUM` types.                                           |\n\n```typescript\nexport type ColumnOptions = {\n  modifyColumn?: string;\n  type: string;\n  allowNull?: boolean;\n  primaryKey?: boolean;\n  autoIncrement?: boolean;\n  onUpdate?: string | 'CURRENT_TIMESTAMP';\n  defaultValue?: string | number | 'CURRENT_TIMESTAMP' | null;\n  references?: string | {\n    model: string | typeof Model;\n    onUpdate?: 'CASCADE' | 'SET NULL' | 'NO ACTION' | 'RESTRICT';\n    onDelete?: 'CASCADE' | 'SET NULL' | 'NO ACTION' | 'RESTRICT';\n    key: string;\n  };\n  unique?: boolean;\n  values?: readonly string[];\n};\n```\n\n### Return Properties\n\nA defined model provides the following properties:\n\n- **`ddlQuery`**: SQL `CREATE TABLE` statement.\n- **`database`**: SQL statement for table creation (alias for `ddlQuery`).\n- **`modelAttributes`**: Object containing column configurations.\n- **`tableOptions`**: Table settings (e.g., engine, charset).\n- **`dbInstance`**: Associated `DBnx` instance.\n- **`tableName`**: Name of the table.\n- **`dbTableIdentifier`**: Table identifier in the database.\n\n---\n\n## 3. Usage Examples\n\n### Changing a Column Name\n\nRename a column using `modifyColumn`:\n\n```typescript\nconst Product = Model.init('product', {\n  brand_name: {\n    modifyColumn: 'brand',       // Rename 'brand' to 'brand_name'\n    type: 'VARCHAR(255)',\n    defaultValue: 'hello',\n  },\n}, db);\n```\n\n### Creating a Table\n\nGenerate and execute the `CREATE TABLE` statement:\n\n```typescript\nconsole.log(Product.ddlQuery); // Output the SQL CREATE TABLE query\nawait Product.sync();           // Execute the CREATE TABLE query\n```\n\n### Adding Foreign Key Constraints\n\nDefine a foreign key relationship:\n\n```typescript\nconst Orders = db.define('orders', {\n  product_id: {\n    type: 'BIGINT',\n    allowNull: false,\n    references: {\n      model: Product,          // Reference the Product model\n      key: 'product_id',\n      onDelete: 'CASCADE',\n      onUpdate: 'CASCADE',\n    },\n  },\n});\n```\n\n**Alternative (using table name)**:\n\n```typescript\nconst Orders = db.define('orders', {\n  product_id: {\n    type: 'BIGINT',\n    allowNull: false,\n    references: {\n      model: 'product',        // Reference the product table\n      key: 'product_id',\n      onDelete: 'CASCADE',\n      onUpdate: 'CASCADE',\n    },\n  },\n});\n```\n\n### CRUD Operations\n\n#### Create\n\nInsert a new record:\n\n```typescript\n(async () => {\n  const result = await Users.create({\n    username: 'John Doe',\n    city: 1,\n    status: 'active',\n  });\n  console.log('Record created:', result);\n})();\n```\n\n#### Find All\n\nRetrieve multiple records with optional pagination:\n\n```typescript\n(async () => {\n  const records = await Users.findAll({\n    limitSkip: { limit: 10, skip: 0 },\n  });\n  console.log('Found records:', records);\n})();\n```\n\n#### Find One\n\nRetrieve a single record:\n\n```typescript\n(async () => {\n  const record = await Users.findOne();\n  console.log('Single record found:', record);\n})();\n```\n\n#### Update\n\nUpdate records based on a condition:\n\n```typescript\n(async () => {\n  const result = await Users.update({\n    where: `username = 'John Doe'`,\n    values: { status: 'inactive' },\n  });\n  console.log('Record updated:', result);\n})();\n```\n\n#### Delete\n\nDelete records based on a condition:\n\n```typescript\n(async () => {\n  const result = await Users.delete({\n    where: `username = 'John Doe'`,\n  });\n  console.log('Record deleted:', result);\n})();\n```\n\n### Retrieving Engine Options\n\nAccess table configuration options:\n\n```typescript\nconsole.log(Users.getEngineOptions());\n// Outputs: { engine: 'InnoDB', charset: 'utf8mb4', collation: 'utf8mb4_unicode_ci', auto_increment: 100 }\n```\n\n---\n"
    },
    {
      "id": 6,
      "path": "model/datatypes",
      "name": "DataTypes",
      "folder": "Model",
      "content": "\n# `@dbnx/mysql` Model Definition and DataTypes\n\nThe `@dbnx/mysql` package provides a robust interface for defining database models using the `db.define()` method and `DataTypes` utility. Models represent database tables, allowing you to specify column types, constraints, relationships, and default values. The `DataTypes` object simplifies schema design by mapping JavaScript methods to MySQL column types.\n\n---\n\n## 1. Defining Models\n\nUse the `db.define()` method to create a model, specifying the table name, column configurations, and optional table options.\n\n### Example: Users Model\n\n```javascript\nconst { DBnx, DataTypes } = require('@dbnx/mysql');\n\n// Initialize DBnx instance\nconst db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '11224455',\n  database: 'world',\n  waitForConnections: true,\n  multipleStatements: true,\n  connectionLimit: 10,\n  queueLimit: 0,\n}).connect();\n\nconst Users = db.define('users', {\n  username: {\n    type: DataTypes.STRING(150),\n    unique: true,\n    allowNull: false,\n    defaultValue: null,\n  },\n  city: {\n    type: DataTypes.INT(),\n    allowNull: true,\n    references: {\n      model: 'city',\n      key: 'ID',\n      onDelete: 'SET NULL',\n      onUpdate: 'CASCADE',\n    },\n  },\n  status: {\n    type: DataTypes.ENUM('active', 'inactive'),\n    defaultValue: 'inactive',\n  },\n  created_at: {\n    type: DataTypes.TIMESTAMP(),\n    onUpdate: 'CURRENT_TIMESTAMP',\n  },\n});\n```\n\n---\n\n## 2. DataTypes\n\nThe `DataTypes` object provides methods to define MySQL column types in a JavaScript-friendly way. Each method maps to a corresponding MySQL data type, with optional parameters for customization.\n\n### String Types\n\n- **`STRING(size = 250)`**: Variable-length string (`VARCHAR`).  \n  Example: `DataTypes.STRING(100)` → `VARCHAR(100)`\n\n- **`CHAR(size = 35)`**: Fixed-length string (`CHAR`).  \n  Example: `DataTypes.CHAR(10)` → `CHAR(10)`\n\n- **`TEXT(type = 'TEXT')`**: Large text field.  \n  Options: `'TINYTEXT'`, `'TEXT'`, `'MEDIUMTEXT'`, `'LONGTEXT'`.  \n  Example: `DataTypes.TEXT('MEDIUMTEXT')` → `MEDIUMTEXT`\n\n### Numeric Types\n\n- **`TINYINT(unsigned = false)`**: Tiny integer (1 byte).  \n  Example: `DataTypes.TINYINT(true)` → `TINYINT UNSIGNED`\n\n- **`SMALLINT(unsigned = false)`**: Small integer (2 bytes).  \n  Example: `DataTypes.SMALLINT()` → `SMALLINT`\n\n- **`INT(unsigned = false)`**: Standard integer (4 bytes).  \n  Example: `DataTypes.INT(true)` → `INT UNSIGNED`\n\n- **`BIGINT(unsigned = false)`**: Large integer (8 bytes).  \n  Example: `DataTypes.BIGINT()` → `BIGINT`\n\n- **`DECIMAL(precision = 10, scale = 0)`**: Fixed-point decimal.  \n  Example: `DataTypes.DECIMAL(12, 4)` → `DECIMAL(12, 4)`\n\n### Date and Time Types\n\n- **`TIMESTAMP()`**: Timestamp with optional auto-update.  \n  Example: `DataTypes.TIMESTAMP()` → `TIMESTAMP`\n\n- **`DATE()`**: Date without time.  \n  Example: `DataTypes.DATE()` → `DATE`\n\n### Enumerations\n\n- **`ENUM(...values)`**: Enum with specific values.  \n  Example: `DataTypes.ENUM('active', 'inactive')` → `ENUM('active', 'inactive')`\n\n### Binary Types\n\n- **`BINARY(size = 16)`**: Fixed-length binary data.  \n  Example: `DataTypes.BINARY(32)` → `BINARY(32)`\n\n- **`VARBINARY(size = 255)`**: Variable-length binary data.  \n  Example: `DataTypes.VARBINARY(100)` → `VARBINARY(100)`\n\n- **`BLOB(type = 'BLOB')`**: Binary large object.  \n  Options: `'TINYBLOB'`, `'BLOB'`, `'MEDIUMBLOB'`, `'LONGBLOB'`.  \n  Example: `DataTypes.BLOB('LONGBLOB')` → `LONGBLOB`\n\n### JSON Type\n\n- **`JSON()`**: JSON-formatted data.  \n  Example: `DataTypes.JSON()` → `JSON`\n\n### DataTypes Reference\n\n| Type                  | Description                                                                 | Example                              |\n|-----------------------|-----------------------------------------------------------------------------|--------------------------------------|\n| `STRING(size)`        | Variable-length string (`VARCHAR`). Default: 250.                           | `DataTypes.STRING(150)`             |\n| `CHAR(size)`          | Fixed-length string (`CHAR`). Default: 35.                                  | `DataTypes.CHAR(20)`                |\n| `TEXT(type)`          | Large text field (`TINYTEXT`, `TEXT`, `MEDIUMTEXT`, `LONGTEXT`).            | `DataTypes.TEXT('LONGTEXT')`        |\n| `TINYINT(unsigned)`   | Tiny integer (1 byte). Optional unsigned.                                   | `DataTypes.TINYINT(true)`           |\n| `SMALLINT(unsigned)`  | Small integer (2 bytes). Optional unsigned.                                 | `DataTypes.SMALLINT()`              |\n| `INT(unsigned)`       | Standard integer (4 bytes). Optional unsigned.                              | `DataTypes.INT(true)`               |\n| `BIGINT(unsigned)`    | Large integer (8 bytes). Optional unsigned.                                 | `DataTypes.BIGINT()`                |\n| `DECIMAL(p, s)`       | Fixed-point decimal with precision `p`, scale `s`. Default: `(10, 0)`.     | `DataTypes.DECIMAL(12, 4)`          |\n| `TIMESTAMP()`         | Timestamp with optional auto-update.                                       | `DataTypes.TIMESTAMP()`             |\n| `DATE()`              | Date without time.                                                         | `DataTypes.DATE()`                  |\n| `ENUM(...values)`     | Enum with specific values.                                                 | `DataTypes.ENUM('active', 'inactive')` |\n| `BINARY(size)`        | Fixed-length binary data. Default: 16.                                      | `DataTypes.BINARY(32)`              |\n| `VARBINARY(size)`     | Variable-length binary data. Default: 255.                                  | `DataTypes.VARBINARY(100)`          |\n| `BLOB(type)`          | Binary large object (`TINYBLOB`, `BLOB`, `MEDIUMBLOB`, `LONGBLOB`).         | `DataTypes.BLOB('LONGBLOB')`        |\n| `JSON()`              | JSON-formatted data.                                                       | `DataTypes.JSON()`                  |\n\n---\n\n## 3. Advanced Features\n\n### Relationships\n\nDefine foreign key relationships using the `references` field:\n\n```javascript\ncity: {\n  type: DataTypes.INT(),\n  allowNull: true,\n  references: {\n    model: 'city',\n    key: 'ID',\n    onDelete: 'SET NULL',\n    onUpdate: 'CASCADE',\n  },\n}\n```\n\n- **`model`**: Referenced table name or model.\n- **`key`**: Referenced column.\n- **`onDelete`**: Action on deletion (`CASCADE`, `SET NULL`, `NO ACTION`, `RESTRICT`).\n- **`onUpdate`**: Action on update (`CASCADE`, `SET NULL`, `NO ACTION`, `RESTRICT`).\n\n### Default Values\n\nSet default values for columns to ensure consistent data:\n\n```javascript\nstatus: {\n  type: DataTypes.ENUM('active', 'inactive'),\n  defaultValue: 'inactive',\n}\n```\n\n---\n\n## 4. Example: CRUD Operations\n\nPerform common database operations using the model.\n\n### Create a User\n\nInsert a new record:\n\n```javascript\nawait Users.create({\n  username: 'john_doe',\n  city: 1,\n  status: 'active',\n});\n```\n\n### Find Users\n\nRetrieve all records:\n\n```javascript\nconst allUsers = await Users.findAll();\n```\n\n### Update a User\n\nUpdate records based on a condition:\n\n```javascript\nawait Users.update({\n  values: { status: 'inactive' },\n  where: \"username = 'john_doe'\",\n});\n```\n\n### Delete a User\n\nDelete records based on a condition:\n\n```javascript\nawait Users.delete({\n  where: \"username = 'john_doe'\",\n});\n```\n\n---\n"
    },
    {
      "id": 7,
      "path": "model/synchronize-database-model",
      "name": "Synchronize Database Model",
      "folder": "Model",
      "content": "\n# `@dbnx/mysql` SYNC Database Model Documentation\n\nThis guide explains how to set up and synchronize a MySQL database using the `@dbnx/mysql` package in a Node.js application. It covers establishing a database connection, defining table models, and synchronizing the schema with raw SQL queries. The process is split into three key files: `database.js`, `models.js`, and `syncDatabase.js`.\n\n---\n\n## 1. Database Connection (`database.js`)\n\nThe `database.js` file establishes a connection to a MySQL database using the `DBnx` class from `@dbnx/mysql`.\n\n### Code\n\n```javascript\n// database.js\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nexport const db = new DBnx({\n  host: 'localhost',              // Database host\n  user: 'root',                   // Database user\n  password: '11224455',           // Database password\n  database: 'world',              // Database name\n  waitForConnections: true,       // Wait for connections when pool is full\n  multipleStatements: true,       // Allow multiple SQL statements\n  connectionLimit: 10,            // Maximum connections in pool\n  queueLimit: 0,                  // No limit on queued requests\n}).connect();\n```\n\n### Parameters\n\n| Parameter              | Type      | Description                                                                 | Default       |\n|------------------------|-----------|-----------------------------------------------------------------------------|---------------|\n| `host`                 | `string`  | MySQL server hostname or IP address.                                        | `'localhost'` |\n| `user`                 | `string`  | MySQL username.                                                             | `'root'`      |\n| `password`             | `string`  | MySQL password.                                                             | `''`          |\n| `database`             | `string`  | Name of the database to connect to.                                         | `undefined`   |\n| `waitForConnections`   | `boolean` | Wait for a connection when the pool is full.                                | `true`        |\n| `multipleStatements`   | `boolean` | Allow multiple SQL statements in a single query.                            | `true`        |\n| `connectionLimit`      | `number`  | Maximum number of connections in the pool.                                  | `10`          |\n| `queueLimit`           | `number`  | Maximum number of queued connection requests (0 = no limit).                | `0`           |\n\n### Methods\n\n- **`db.connect()`**: Establishes the database connection. Returns a promise that resolves when connected.\n- **`db.close()`**: Closes the database connection, freeing resources.\n\n---\n\n## 2. Model Definition (`models.js`)\n\nThe `models.js` file defines table schemas using the `db.define()` method. Models specify the structure of tables, including columns, data types, and constraints.\n\n### Code\n\n```javascript\n// models.js\nimport { db } from './database.js';\n\n// Define the UserModel for the 'users' table\nexport const UserModel = db.define('users', {\n  username: {\n    type: 'VARCHAR(50)',         // Variable-length string\n    allowNull: false,            // Cannot be NULL\n    unique: true,                // Enforce unique values\n    defaultValue: null,          // Default value\n  },\n  code: {\n    type: 'CHAR(3)',             // Fixed-length string\n    allowNull: true,             // Allow NULL values\n  },\n  created_at: {\n    type: 'TIMESTAMP',            // Timestamp column\n    defaultValue: 'CURRENT_TIMESTAMP', // Auto-set to current timestamp\n  },\n});\n```\n\n### Field Parameters\n\n| Parameter        | Type                                      | Description                                                                 |\n|------------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `type`           | `string`                                  | MySQL data type (e.g., `VARCHAR(50)`, `CHAR(3)`, `TIMESTAMP`).              |\n| `allowNull`      | `boolean`                                 | Allow `NULL` values (default: `true`).                                     |\n| `defaultValue`   | `string \\| number \\| 'CURRENT_TIMESTAMP' \\| null` | Default value for the column.                                              |\n| `unique`         | `boolean`                                 | Enforce unique values.                                                     |\n| `references`     | `object \\| string`                         | Foreign key configuration (e.g., `{ model: 'table', key: 'column' }`).     |\n\n---\n\n## 3. Database Synchronization (`syncDatabase.js`)\n\nThe `syncDatabase.js` file synchronizes the database schema by creating or updating tables based on defined models. It supports both non-destructive and force synchronization.\n\n### Basic Sync\n\nCreate tables if they don’t exist without modifying existing tables.\n\n```javascript\n// syncDatabase.js\nimport { UserModel, PostModel } from './models.js';\n\nasync function syncDatabase() {\n  try {\n    // Synchronize models (create tables if they don't exist)\n    await UserModel.sync(); // Sync users table\n    await PostModel.sync(); // Sync posts table\n    console.log('Database synchronized successfully.');\n  } catch (error) {\n    console.error('Error syncing database:', error);\n  } finally {\n    await db.close(); // Close database connection\n  }\n}\n\nsyncDatabase();\n```\n\n### Force Sync\n\nDrop and recreate tables, even if they exist.\n\n```javascript\n// syncDatabase.js\nimport { UserModel, PostModel } from './models.js';\n\nasync function syncDatabase() {\n  try {\n    // Force sync: Drop and recreate tables\n    await UserModel.sync(true); // Drop and recreate users table\n    await PostModel.sync(true); // Drop and recreate posts table\n    console.log('Database synchronized successfully.');\n  } catch (error) {\n    console.error('Error syncing database:', error);\n  } finally {\n    await db.close(); // Close database connection\n  }\n}\n\nsyncDatabase();\n```\n\n### Sync Methods\n\n- **`sync(force?: boolean)`**: Synchronizes the table schema.\n  - **`force: false`** (default): Creates the table if it doesn’t exist; no changes to existing tables.\n  - **`force: true`**: Drops the existing table and recreates it, potentially causing data loss.\n\n---\n\n## 4. Common Errors & Troubleshooting\n\n1. **Connection Errors**:\n   - **Cause**: Incorrect credentials, MySQL service not running, or network issues.\n   - **Solution**:\n     - Verify credentials in `database.js`.\n     - Check MySQL service: `sudo systemctl status mysql`.\n     - Ensure no firewall or permission issues block the connection.\n\n2. **Table Already Exists**:\n   - **Cause**: Attempting to create a table that already exists without `force: true`.\n   - **Solution**: Use `sync(true)` to drop and recreate the table, or ensure the table name is unique.\n\n3. **Type Mismatch**:\n   - **Cause**: Model data types (e.g., `VARCHAR(50)`) don’t match database constraints.\n   - **Solution**: Verify that model definitions align with MySQL requirements.\n\n4. **Missing Dependencies**:\n   - **Cause**: `@dbnx/mysql` or `mysql2` not installed.\n   - **Solution**: Install dependencies:\n\n```bash\nnpm install @dbnx/mysql mysql2\n```\n\n---\n"
    },
    {
      "id": 8,
      "path": "crud-operations/create",
      "name": "Create",
      "folder": "CRUD Operations",
      "content": "\n# `@dbnx/mysql` Create/Insert Operation\n\nThe `@dbnx/mysql` package provides a powerful `create` method for inserting records into a MySQL database. This method supports single and batch insertions, customizable conflict handling, and query generation for both model-based and direct table operations.\n\n---\n\n## 1. Creating a Model\n\nBefore performing insert operations, define a model using the `db.define()` method to specify the table schema.\n\n### Example: User Model\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nconst db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '11224455',\n  database: 'world',\n  waitForConnections: true,\n  multipleStatements: true,\n  connectionLimit: 10,\n  queueLimit: 0,\n}).connect();\n\n// Define User model\nconst User = db.define('User', {\n  username: {\n    type: 'VARCHAR(50)',\n    allowNull: false,\n    unique: true,\n    defaultValue: null,\n  },\n  created_at: {\n    type: 'TIMESTAMP',\n    defaultValue: 'CURRENT_TIMESTAMP',\n  },\n});\n```\n\n---\n\n## 2. Static Method: `create`\n\nThe static `create` method on a model inserts one or more records into the associated table.\n\n### Signature\n\n```typescript\nstatic async create(\n  values: CreateParamsType<[]>,\n  options?: InsertIntoOptionsType\n): Promise<ResponseType>\n```\n\n- **Single row**: `{ name: 'John', age: 30 }`\n- **Multiple rows**: `[{ name: 'Alice', age: 25 }, { name: 'Bob', age: 28 }]`\n\n### Parameters\n\n| Name      | Type                    | Description                                                                 |\n|-----------|-------------------------|-----------------------------------------------------------------------------|\n| `values`  | `CreateParamsType<[]>`  | Data to insert. Can be a single object or an array of objects.              |\n| `options` | `InsertIntoOptionsType` | Optional settings for uniqueness constraints or duplicate key handling.     |\n\n### Returns\n\n- A `Promise` resolving to a `ResponseType` object containing details like the number of inserted rows or any errors.\n\n### Usage Example\n\n```typescript\n// Single record\nconst result = await User.create(\n  { username: 'John Doe', email: 'john@example.com' },\n  { uniqueColumn: 'email' }\n);\nconsole.log(result); // Logs database response\n```\n\n```typescript\n// Using db.create with model\nconst result = await db.create(\n  User,\n  { username: 'John Doe', email: 'john@example.com' },\n  { uniqueColumn: 'email' }\n);\nconsole.log(result); // Logs database response\n```\n\n---\n\n## 3. Instance Method: `create`\n\nThe instance `create` method on a `DBnx` instance inserts data into a specified table, offering chainable query building.\n\n### Signature\n\n```typescript\ncreate(\n  table: string | typeof Model,\n  values: CreateParamsType<[]>,\n  options?: InsertIntoOptionsType\n): DBnx | Promise<ResponseType>\n```\n\n### Parameters\n\n| Name      | Type                    | Description                                                                 |\n|-----------|-------------------------|-----------------------------------------------------------------------------|\n| `table`   | `string \\| typeof Model` | Name of the table or model to insert data into.                            |\n| `values`  | `CreateParamsType<[]>`  | Data to insert. Can be a single object or an array of objects.              |\n| `options` | `InsertIntoOptionsType` | Optional settings for uniqueness or duplicate key handling.                 |\n\n### Returns\n\n- **Chainable**: Returns the `DBnx` instance for query chaining (e.g., with `.build()` or `.execute()`).\n- **Execution**: Returns a `Promise` resolving to a `ResponseType` when executed.\n\n### Usage Example\n\n```typescript\n// Single record insertion\nconst result = await db.create(\n  'users',\n  { username: 'Alice', age: 30 },\n  { onDuplicateUpdateFields: ['age'] }\n).execute();\nconsole.log(result); // Logs execution result\n```\n\n```typescript\n// View generated query\nconst query = await db.create(\n  'users',\n  { username: 'Alice', age: 30 },\n  { onDuplicateUpdateFields: ['age'] }\n).build();\nconsole.log(query); // Logs raw SQL query\n```\n\n---\n\n## 4. Options for `create`\n\nCustomize insert operations with the following options:\n\n| Option                     | Type                | Description                                                                 |\n|----------------------------|---------------------|-----------------------------------------------------------------------------|\n| `uniqueColumn`             | `string \\| null`     | Enforce uniqueness for the specified column.                               |\n| `onDuplicateUpdateFields`  | `string[]`          | Fields to update if a duplicate key conflict occurs.                        |\n\n---\n\n## 5. Types\n\n### CreateParamsType\n\nDefines the structure of the `values` parameter:\n\n```typescript\ntype CreateParamsType<columns extends any[]> =\n  | { [P in columns[number]]?: string[] }\n  | Record<string, string | number>\n  | { [P in columns[number]]?: string[] }[];\n```\n\n- **Single record**: `Record<string, string | number>` (e.g., `{ name: 'John', age: 30 }`).\n- **Multiple records**: Array of objects (e.g., `[{ name: 'Alice', age: 25 }, { name: 'Bob', age: 28 }]`).\n\n### InsertIntoOptionsType\n\nDefines optional settings for insert operations:\n\n```typescript\ntype InsertIntoOptionsType = {\n  uniqueColumn?: string | null;\n  onDuplicateUpdateFields?: string[];\n};\n```\n\n---\n\n## 6. Common Errors & Troubleshooting\n\n| Error Message                         | Cause                                           | Solution                                                                 |\n|---------------------------------------|-------------------------------------------------|--------------------------------------------------------------------------|\n| `Values must be a non-empty object.`  | Empty or invalid `values` parameter.            | Ensure `values` is a non-empty object or array of objects.               |\n| `Expected a table name and/or values.`| Missing table name or values.                   | Provide a valid table name/model and `values` object.                    |\n| `Duplicate entry for key 'PRIMARY'`   | Duplicate data violates a unique constraint.    | Use `onDuplicateUpdateFields` or adjust data to avoid conflicts.         |\n\n---\n\n## 7. Advanced Features\n\n### Batch Insert\n\nInsert multiple records efficiently to optimize performance for large datasets:\n\n```typescript\nconst result = await db.create(\n  'users',\n  [\n    { username: 'Alice', age: 30 },\n    { username: 'Bob', age: 25 },\n    { username: 'Charlie', age: 35 },\n  ]\n).execute();\nconsole.log(result); // Logs batch insertion result\n```\n\n### On Duplicate Key Updates\n\nUpdate specific fields when a duplicate key conflict occurs:\n\n```typescript\nconst result = await db.create(\n  'users',\n  { username: 'John', age: 30 },\n  { onDuplicateUpdateFields: ['age'] }\n).execute();\nconsole.log(result); // Logs result after updating 'age' on conflict\n```\n\n### Custom Conflict Handling\n\nUse `onDuplicateUpdateFields` to define which fields to update on duplicate key conflicts, providing fine-grained control over insertion behavior.\n\n---\n"
    },
    {
      "id": 9,
      "path": "crud-operations/find/findone",
      "name": "FindOne",
      "folder": "CRUD Operations/Find",
      "content": "\n# `@dbnx/mysql` findOne Function\n\nThe `findOne` function in `@dbnx/mysql` retrieves a single record from a MySQL database table or model. It supports flexible query configuration, including filtering, sorting, grouping, joins, subqueries, aggregates, and recursive common table expressions (CTEs). This makes it ideal for both simple and complex data retrieval tasks.\n\n---\n\n## 1. Overview\n\nThe `findOne` function is designed to fetch a single record from a database, offering extensive customization through the `FindOneParamsType` interface. It supports both table-based queries (using a table name) and model-based queries (using a model class), providing flexibility for raw SQL and ORM-style operations.\n\n---\n\n## 2. FindOneParamsType\n\n### Type Definition\n\nThe `FindOneParamsType` interface defines the configuration options for the `findOne` function.\n\n```typescript\nexport interface FindOneParamsType<Tables extends string[]> {\n  distinct?: boolean;\n  sort?: SortType<Tables>;\n  columns?: {\n    [P in Tables[number]]?: string[];\n  } | { extra?: string | string[] } | string | string[];\n  groupBy?: {\n    [P in Tables[number]]?: string[];\n  } | { extra?: string | string[] } | string | string[];\n  aggregates?: Array<{\n    [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string;\n  } | { alias?: string }>;\n  where?: string;\n  having?: string;\n  subQueries?: {\n    query: string;\n    as?: string;\n  }[];\n  joins?: JoinsType<Tables>;\n  recursiveCTE?: { baseCase: string; recursiveCase: string; alias: string };\n}\n```\n\n### Key Parameters\n\n| Parameter       | Type                                      | Description                                                                 |\n|-----------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `distinct`      | `boolean`                                 | Return distinct results if `true`.                                          |\n| `sort`          | `SortType<Tables>`                        | Sorting criteria (e.g., `{ age: 1 }` for ascending).                        |\n| `columns`       | `object \\| string \\| string[]`              | Columns to select (e.g., `{ users: ['id', 'name'] }` or `'id, name'`).     |\n| `groupBy`       | `object \\| string \\| string[]`              | Columns to group by (e.g., `{ users: ['status'] }`).                       |\n| `aggregates`    | `Array<object>`                           | Aggregate functions (e.g., `[{ COUNT: 'id' }]`).                            |\n| `where`         | `string`                                  | Filter condition (e.g., `\"status = 'active'\"`).                             |\n| `having`        | `string`                                  | Condition for grouped results (e.g., `\"COUNT(age) > 2\"`).                   |\n| `subQueries`    | `Array<{ query: string; as?: string }>`   | Subqueries for `FROM` or `WHERE` clauses.                                  |\n| `joins`         | `JoinsType<Tables>`                       | Join clauses for multi-table queries.                                      |\n| `recursiveCTE`  | `object`                                  | Recursive CTE configuration with base case, recursive case, and alias.     |\n\n---\n\n## 3. The `findOne` Function\n\n### Function Signatures\n\n```typescript\npublic findOne<tables extends string[]>(table: string, config?: FindOneParamsType<tables>): DBnx;\npublic findOne<tables extends string[]>(model: typeof Model, config?: FindOneParamsType<tables>): Promise<ResponseType>;\npublic findOne(...args: any): DBnx | Promise<ResponseType>;\n```\n\n### How It Works\n\n- **Table Name**: When a string is provided, the function generates a `SELECT` query for the specified table, supporting query chaining.\n- **Model**: When a model is provided, the function executes the query immediately using the model’s table definition.\n- **Config**: The `FindOneParamsType` object specifies filters, sorting, columns, and other query options.\n\n### Return Types\n\n- **Chainable**: Returns a `DBnx` instance for query chaining (e.g., with `.build()` or `.execute()`) when used with a table name.\n- **Immediate Execution**: Returns a `Promise<ResponseType>` with the query result when used with a model or executed.\n\n---\n\n## 4. Usage Examples\n\n### Basic Query\n\nRetrieve a single record based on a condition.\n\n```typescript\nconst query = await db.findOne('users', {\n  where: 'id = 1',\n}).build();\nconsole.log(query);\n// SQL: SELECT * FROM users WHERE id = 1 LIMIT 1;\n```\n\n```typescript\nconst result = await db.findOne('users', {\n  where: 'id = 1',\n}).execute();\nconsole.log(result); // Logs execution result\n```\n\n**Using a Model**:\n\n```typescript\nconst result = await db.findOne(UserModel, {\n  where: 'id = 1',\n});\nconsole.log(result); // Logs execution result\n```\n\n```typescript\nconst result = await UserModel.findOne({\n  where: 'id = 1',\n});\nconsole.log(result); // Logs execution result\n```\n\n### Query with Sorting\n\nSort results before selecting the first record.\n\n```typescript\nconst query = await db.findOne('users', {\n  where: \"status = 'active'\",\n  sort: { name: 1 },\n}).build();\nconsole.log(query);\n// SQL: SELECT * FROM users WHERE status = 'active' ORDER BY name ASC LIMIT 1;\n```\n\n### Query with Aggregates\n\nApply an aggregate function to the result.\n\n```typescript\nconst query = await db.findOne('orders', {\n  aggregates: [{ COUNT: 'id' }],\n  where: \"status = 'completed'\",\n}).build();\nconsole.log(query);\n// SQL: SELECT COUNT(id) FROM orders WHERE status = 'completed' LIMIT 1;\n```\n\n### Query with Joins\n\nRetrieve a record with data from joined tables.\n\n```typescript\nconst query = await db.findOne('users', {\n  joins: {\n    type: 'INNER',\n    table: 'orders',\n    on: 'users.id = orders.user_id',\n  },\n  where: \"users.status = 'active'\",\n}).build();\nconsole.log(query);\n// SQL: SELECT * FROM users INNER JOIN orders ON users.id = orders.user_id WHERE users.status = 'active' LIMIT 1;\n```\n\n### Query with Subqueries\n\nUse a subquery in the query.\n\n```typescript\nconst query = await db.findOne('users', {\n  subQueries: [{\n    query: \"SELECT id FROM users WHERE status = 'active'\",\n    as: 'active_users',\n  }],\n  where: 'id IN (SELECT id FROM active_users)',\n}).build();\nconsole.log(query);\n// SQL: SELECT * FROM users WHERE id IN (SELECT id FROM users WHERE status = 'active') LIMIT 1;\n```\n\n### Query with Recursive CTEs\n\nUse a recursive CTE for hierarchical or recursive data.\n\n```typescript\nconst query = await db.findOne('users', {\n  recursiveCTE: {\n    baseCase: \"SELECT id FROM users WHERE status = 'active'\",\n    recursiveCase: \"SELECT u.id FROM users u INNER JOIN users r ON u.id = r.id\",\n    alias: 'recursion',\n  },\n}).build();\nconsole.log(query);\n// SQL: WITH recursion AS (SELECT id FROM users WHERE status = 'active' UNION ALL SELECT u.id FROM users u INNER JOIN users r ON u.id = r.id) SELECT * FROM users WHERE id IN (SELECT id FROM recursion) LIMIT 1;\n```\n\n---\n\n## 5. Best Practices\n\n1. **Always Use a WHERE Clause**:\n   - Specify a `where` condition to avoid retrieving unintended records. Without a `where` clause, the first record in the table is returned.\n\n2. **Optimize Column Selection**:\n   - Use the `columns` parameter to select only necessary columns, improving query performance.\n\n3. **Test Subqueries and Joins**:\n   - Preview complex queries with `.build()` to ensure correctness before execution, especially when using subqueries or joins.\n\n4. **Use Aggregates Judiciously**:\n   - Ensure `aggregates` are paired with appropriate `groupBy` and `having` clauses to avoid unexpected results.\n\n5. **Handle Recursive CTEs Carefully**:\n   - Recursive CTEs can be resource-intensive. Test in a development environment and ensure the recursion terminates correctly.\n\n---\n"
    },
    {
      "id": 10,
      "path": "crud-operations/find/findall",
      "name": "FindAll",
      "folder": "CRUD Operations/Find",
      "content": "\n# `@dbnx/mysql` findAll Function\n\nThe `findAll` function in `@dbnx/mysql` retrieves multiple records from a MySQL database table or model. It supports flexible query configuration, including filtering, sorting, pagination, grouping, joins, subqueries, aggregates, and recursive common table expressions (CTEs). This makes it suitable for a wide range of data retrieval tasks.\n\n---\n\n## 1. Overview\n\nThe `findAll` function fetches multiple records from a database, offering extensive customization through the `FindAllParamsType` interface. It supports both table-based queries (using a table name) and model-based queries (using a model class), providing flexibility for raw SQL and ORM-style operations.\n\n---\n\n## 2. Method Signature\n\n```typescript\npublic findAll<tables extends string[]>(table: string, config?: FindAllParamsType<tables>): DBnx;\npublic findAll<tables extends string[]>(model: typeof Model, config?: FindAllParamsType<tables>): Promise<ResponseType>;\npublic findAll(...args: any): DBnx | Promise<ResponseType>;\n```\n\n### Parameters\n\n| Parameter | Type                     | Description                                                                 | Required |\n|-----------|--------------------------|-----------------------------------------------------------------------------|----------|\n| `table`   | `string`                 | Name of the table to query. Used for raw table-based queries.               | Yes (if not using model) |\n| `model`   | `typeof Model`           | Model class to query. Used for model-based queries.                         | Yes (if not using table) |\n| `config`  | `FindAllParamsType`      | Configuration object for customizing the query (e.g., filters, sorting).    | No       |\n\n### Returns\n\n- **Table Name**: Returns a `DBnx` instance for query chaining (e.g., with `.build()` or `.execute()`).\n- **Model**: Returns a `Promise<ResponseType>` with the query results.\n\n---\n\n## 3. FindAllParamsType\n\n### Type Definition\n\nThe `FindAllParamsType` interface defines the configuration options for the `findAll` function.\n\n```typescript\nexport interface FindAllParamsType<Tables extends string[]> {\n  distinct?: boolean;\n  sort?: SortType<Tables>;\n  limitSkip?: { limit?: number; skip?: number };\n  columns?: { [P in Tables[number]]?: string[] } | { extra?: string | string[] } | string | string[];\n  groupBy?: { [P in Tables[number]]?: string[] } | { extra?: string | string[] } | string | string[];\n  aggregates?: Array<{ [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string } | { alias?: string }>;\n  where?: string;\n  having?: string;\n  subQueries?: { query: string; as?: string }[];\n  joins?: JoinsType<Tables>;\n  recursiveCTE?: { baseCase: string; recursiveCase: string; alias: string };\n}\n```\n\n### Key Parameters\n\n| Parameter       | Type                                      | Description                                                                 |\n|-----------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `distinct`      | `boolean`                                 | Return distinct records if `true`.                                          |\n| `sort`          | `SortType<Tables>`                        | Sorting criteria (e.g., `{ name: 'ASC' }`).                                 |\n| `limitSkip`     | `{ limit?: number; skip?: number }`       | Pagination options for limiting and skipping records.                      |\n| `columns`       | `object \\| string \\| string[]`              | Columns to select (e.g., `{ users: ['id', 'name'] }` or `'id, name'`).     |\n| `groupBy`       | `object \\| string \\| string[]`              | Columns to group by (e.g., `{ users: ['status'] }`).                       |\n| `aggregates`    | `Array<object>`                           | Aggregate functions (e.g., `[{ COUNT: 'id' }]`).                            |\n| `where`         | `string`                                  | Filter condition (e.g., `\"age > 25\"`).                                     |\n| `having`        | `string`                                  | Condition for grouped results (e.g., `\"COUNT(id) > 2\"`).                   |\n| `subQueries`    | `Array<{ query: string; as?: string }>`   | Subqueries for `FROM` or `WHERE` clauses.                                  |\n| `joins`         | `JoinsType<Tables>`                       | Join clauses for multi-table queries.                                      |\n| `recursiveCTE`  | `object`                                  | Recursive CTE configuration with base case, recursive case, and alias.     |\n\n---\n\n## 4. Usage Examples\n\n### Using a Table Name\n\nQuery a table with pagination and sorting.\n\n```typescript\nconst handler = db.findAll('users', {\n  limitSkip: { limit: 10, skip: 0 },\n  sort: { name: 'ASC' },\n  columns: { users: ['id', 'name'] },\n});\n\nconst result = await handler.execute();\nconsole.log(result); // Logs query result\n```\n\n**Generated SQL**:\n\n```sql\nSELECT users.id, users.name FROM users ORDER BY name ASC LIMIT 10 OFFSET 0;\n```\n\n### Using a Model\n\nQuery a model with filtering.\n\n```typescript\nconst result = await User.findAll({\n  limitSkip: { limit: 5 },\n  where: 'age > 25',\n  columns: { users: ['id', 'name', 'age'] },\n});\nconsole.log(result); // Logs fetched data\n```\n\n**Generated SQL**:\n\n```sql\nSELECT users.id, users.name, users.age FROM users WHERE age > 25 LIMIT 5;\n```\n\n### Advanced Configuration\n\nQuery with joins, aggregates, and subqueries.\n\n```typescript\nconst handler = db.findAll('users', {\n  distinct: true,\n  limitSkip: { limit: 10, skip: 0 },\n  sort: { name: 'ASC' },\n  columns: { users: ['id', 'name'] },\n  where: 'age > 25',\n  joins: [{ type: 'INNER', table: 'orders', on: 'users.id = orders.user_id' }],\n  aggregates: [{ COUNT: 'orders.id', alias: 'order_count' }],\n  groupBy: { users: ['id', 'name'] },\n  having: 'COUNT(orders.id) > 1',\n  subQueries: [{ query: 'SELECT user_id FROM orders WHERE status = \"completed\"', as: 'completed_orders' }],\n});\n\nconst result = await handler.execute();\nconsole.log(result); // Logs query result\n```\n\n**Generated SQL**:\n\n```sql\nSELECT DISTINCT users.id, users.name, COUNT(orders.id) AS order_count\nFROM users\nINNER JOIN orders ON users.id = orders.user_id,\n(SELECT user_id FROM orders WHERE status = 'completed') AS completed_orders\nWHERE age > 25\nGROUP BY users.id, users.name\nHAVING COUNT(orders.id) > 1\nORDER BY name ASC\nLIMIT 10 OFFSET 0;\n```\n\n---\n\n## 5. Error Handling\n\n| Error Message                                      | Cause                                              | Solution                                                                 |\n|----------------------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------|\n| `No arguments provided to 'findAll'.`              | Missing table name or model.                       | Provide a valid table name or model as the first argument.               |\n| `Config must be a non-empty object.`                | Invalid or empty configuration object.             | Ensure the `config` parameter is a valid, non-empty object.              |\n\n---\n\n## 6. Best Practices\n\n1. **Use Specific Columns**:\n   - Specify required columns in the `columns` parameter to reduce data transfer and improve performance.\n\n2. **Implement Pagination**:\n   - Use `limitSkip` for large datasets to manage result sizes and improve query efficiency.\n\n3. **Test Complex Queries**:\n   - Preview queries with `.build()` to verify correctness before execution, especially for joins, subqueries, or CTEs.\n\n4. **Optimize Aggregates**:\n   - Pair `aggregates` with appropriate `groupBy` and `having` clauses to ensure accurate results.\n\n5. **Handle Recursive CTEs Carefully**:\n   - Ensure recursive CTEs have a proper termination condition to avoid infinite loops or performance issues.\n\n---\n"
    },
    {
      "id": 11,
      "path": "crud-operations/update",
      "name": "Update",
      "folder": "CRUD Operations",
      "content": "\n# `@dbnx/mysql` Update Operation\n\nThe `update` function in `@dbnx/mysql` provides a flexible interface for performing MySQL `UPDATE` operations. It supports conditional updates with `CASE` expressions, joins, subqueries, sorting, limiting, and calculated fields, making it suitable for a wide range of database update scenarios.\n\n---\n\n## 1. Overview\n\nThe `update` function allows developers to modify records in a MySQL database with fine-grained control. It supports both simple updates (e.g., setting column values) and complex operations (e.g., conditional updates, joins, and subqueries). The `UpdateParamsType` defines the structure of the update parameters, enabling flexible query construction.\n\n---\n\n## 2. UpdateParamsType\n\n### Type Definition\n\nThe `UpdateParamsType` type specifies the properties for an update operation, including values to set, conditions, sorting, and more.\n\n```typescript\nexport type UpdateismicType<Tables extends string[]> = {\n  values?: {\n    [key: string]: string | number | null | {\n      case: {\n        when: string;  // Condition for WHEN clause\n        then: any;     // Value for THEN clause\n      }[];             // Array of WHEN/THEN conditions\n      default: any;    // Default value if no conditions match\n    };\n  };\n  sort?: { [P in Tables[number]]?: Record<string, 1 | -1> } | Record<string, 1 | -1> | string;\n  where: string;\n  defaultValues?: string[];\n  limit?: string | number;\n  joins?: JoinsType<Tables>;\n  fromSubQuery?: Record<string, string>;\n  setCalculations?: { [key: string]: string };\n};\n```\n\n### Key Parameters\n\n| Parameter          | Type                                      | Description                                                                 |\n|--------------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `values`           | `object`                                  | Columns and values to update. Supports direct values or `CASE` expressions. |\n| `sort`             | `object \\| string`                        | Sorting criteria (e.g., `{ age: 1 }` for ascending, `{ age: -1 }` for descending). |\n| `where`            | `string`                                  | Condition for selecting records to update (e.g., `\"id = 1\"`).               |\n| `defaultValues`    | `string[]`                                | Columns to set to their default values.                                    |\n| `limit`            | `string \\| number`                        | Maximum number of records to update.                                       |\n| `joins`            | `JoinsType<Tables>`                       | Join clauses for multi-table updates.                                      |\n| `fromSubQuery`     | `Record<string, string>`                  | Subquery for updating records based on another query.                      |\n| `setCalculations`  | `{ [key: string]: string }`               | Calculated values for columns (e.g., `\"price * quantity\"`).                 |\n\n---\n\n## 3. The `update` Function\n\n### Function Signatures\n\n```typescript\npublic update<tables extends string[]>(table: string, props: UpdateParamsType<tables>): DBnx;\npublic update<tables extends string[]>(model: typeof Model, props: UpdateParamsType<tables>): Promise<ResponseType>;\npublic update(...args: any): DBnx | Promise<ResponseType>;\n```\n\n### How It Works\n\n- **Table Name**: When a string is provided, the function targets the specified table.\n- **Model**: When a model is provided, the function uses the model’s table definition and executes the query immediately.\n- **Props**: The `UpdateParamsType` object defines the update logic, including values, conditions, and optional settings.\n\n### Return Types\n\n- **Chainable**: Returns a `DBnx` instance for query chaining (e.g., with `.build()` or `.execute()`) when used with a table name.\n- **Immediate Execution**: Returns a `Promise<ResponseType>` with the query result when used with a model or executed.\n\n---\n\n## 4. Usage Examples\n\n### Basic Update\n\nUpdate specific columns for records matching a condition.\n\n```typescript\nconst query = await db.update('users', {\n  values: {\n    name: 'John Doe',\n    age: 30,\n  },\n  where: 'id = 1',\n}).build();\nconsole.log(query);\n// SQL: UPDATE users SET name = 'John Doe', age = 30 WHERE id = 1;\n```\n\n```typescript\nconst result = await db.update('users', {\n  values: {\n    name: 'John Doe',\n    age: 30,\n  },\n  where: 'id = 1',\n}).execute();\nconsole.log(result); // Logs execution result\n```\n\n**Using a Model**:\n\n```typescript\nconst result = await UserModel.update({\n  values: {\n    name: 'John Doe',\n    age: 30,\n  },\n  where: 'id = 1',\n});\nconsole.log(result); // Logs execution result\n```\n\n```typescript\nconst result = await db.update(UserModel, {\n  values: {\n    name: 'John Doe',\n    age: 30,\n  },\n  where: 'id = 1',\n});\nconsole.log(result); // Logs execution result\n```\n\n### Conditional Update with CASE\n\nUse a `CASE` expression for conditional updates.\n\n```typescript\nconst query = await db.update('users', {\n  values: {\n    age: {\n      case: [\n        { when: \"status = 'active'\", then: 35 },\n        { when: \"status = 'inactive'\", then: 25 },\n      ],\n      default: 30,\n    },\n  },\n  where: 'id = 1',\n}).build();\nconsole.log(query);\n// SQL: UPDATE users SET age = CASE WHEN status = 'active' THEN 35 WHEN status = 'inactive' THEN 25 ELSE 30 END WHERE id = 1;\n```\n\n### Update with Sorting\n\nSort records before applying the update.\n\n```typescript\nconst query = await db.update('users', {\n  values: {\n    status: 'active',\n  },\n  where: 'age > 18',\n  sort: { name: 1 },\n}).build();\nconsole.log(query);\n// SQL: UPDATE users SET status = 'active' WHERE age > 18 ORDER BY name ASC;\n```\n\n### Update with Joins\n\nPerform updates involving multiple tables using joins.\n\n```typescript\nconst query = await db.update('orders', {\n  values: {\n    status: 'shipped',\n  },\n  where: \"orders.status = 'pending'\",\n  joins: {\n    type: 'INNER',\n    table: 'users',\n    on: 'orders.user_id = users.id',\n  },\n}).build();\nconsole.log(query);\n// SQL: UPDATE orders INNER JOIN users ON orders.user_id = users.id SET status = 'shipped' WHERE orders.status = 'pending';\n```\n\n### Update with Subquery\n\nUpdate records based on a subquery.\n\n```typescript\nconst query = await db.update('orders', {\n  values: {\n    status: 'shipped',\n  },\n  where: 'id IN (SELECT id FROM pending_orders)',\n  fromSubQuery: {\n    pending_orders: \"SELECT id FROM orders WHERE status = 'pending'\",\n  },\n}).build();\nconsole.log(query);\n// SQL: UPDATE orders SET status = 'shipped' WHERE id IN (SELECT id FROM orders WHERE status = 'pending');\n```\n\n---\n\n## 5. Advanced Use Cases\n\n### Handling Null Values\n\nSet columns to `NULL` during an update.\n\n```typescript\nconst query = await db.update('users', {\n  values: {\n    name: 'Jane Doe',\n    age: 28,\n    address: null,\n  },\n  where: 'id = 2',\n}).build();\nconsole.log(query);\n// SQL: UPDATE users SET name = 'Jane Doe', age = 28, address = NULL WHERE id = 2;\n```\n\n### Performing Calculations in Updates\n\nUse calculated values or `CASE` expressions for dynamic updates.\n\n```typescript\nconst query = await db.update('orders', {\n  values: {\n    total_price: {\n      case: [\n        { when: 'quantity > 10', then: 'price * quantity * 0.9' },\n        { when: 'quantity <= 10', then: 'price * quantity' },\n      ],\n      default: 'price * quantity',\n    },\n  },\n  where: 'id = 3',\n}).build();\nconsole.log(query);\n// SQL: UPDATE orders SET total_price = CASE WHEN quantity > 10 THEN price * quantity * 0.9 WHEN quantity <= 10 THEN price * quantity ELSE price * quantity END WHERE id = 3;\n```\n\n---\n"
    },
    {
      "id": 12,
      "path": "crud-operations/delete",
      "name": "Delete",
      "folder": "CRUD Operations",
      "content": "\n# `@dbnx/mysql` Delete Operation\n\nThe `delete` function in `@dbnx/mysql` provides a robust interface for performing MySQL `DELETE` operations. It supports customizable deletion with conditions, joins, sorting, and limits, making it suitable for both simple and complex use cases.\n\n---\n\n## 1. Setting Up the Database Handler\n\nBefore performing delete operations, initialize a `DBnx` instance and define a model to specify the table schema.\n\n### Example: User Model\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nconst db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '11224455',\n  database: 'world',\n  waitForConnections: true,\n  multipleStatements: true,\n  connectionLimit: 10,\n  queueLimit: 0,\n}).connect();\n\n// Define User model\nconst User = db.define('User', {\n  username: {\n    type: 'VARCHAR(50)',\n    allowNull: false,\n    unique: true,\n    defaultValue: null,\n  },\n  created_at: {\n    type: 'TIMESTAMP',\n    defaultValue: 'CURRENT_TIMESTAMP',\n  },\n});\n```\n\n---\n\n## 2. The `delete` Function\n\nThe `delete` function removes records from a specified table or model, supporting conditions, joins, sorting, and limits.\n\n### Function Signature\n\n```typescript\ndelete<Tables extends string[]>(\n  table: string | typeof Model,\n  params: DeleteParamsType<Tables>\n): DBnx | Promise<ResponseType>;\n```\n\n- **Table/Model**: Specify the table name (string) or model (e.g., `User`).\n- **Params**: Define deletion criteria using `DeleteParamsType`.\n\n### Parameters\n\n| Parameter | Type                     | Description                                                                 |\n|-----------|--------------------------|-----------------------------------------------------------------------------|\n| `table`   | `string \\| typeof Model` | Table name or model to delete from.                                        |\n| `params`  | `DeleteParamsType`       | Object specifying deletion conditions, joins, sorting, and limits.          |\n\n### Usage Examples\n\n#### Basic Deletion\n\nDelete records matching a condition.\n\n```typescript\nconst query = await db.delete('users', {\n  where: 'age > 30',\n}).build();\nconsole.log(query);\n// SQL: DELETE FROM users WHERE age > 30;\n```\n\n```typescript\nconst result = await db.delete('users', {\n  where: 'age > 30',\n}).execute();\nconsole.log(result); // Logs execution result\n```\n\n#### Deletion with Joins\n\nDelete records from a table using a join.\n\n```typescript\nconst query = await db.delete('orders', {\n  where: \"status = 'pending'\",\n  joins: {\n    type: 'INNER',\n    table: 'users',\n    on: 'orders.user_id = users.id',\n  },\n}).build();\nconsole.log(query);\n// SQL: DELETE orders FROM orders INNER JOIN users ON orders.user_id = users.id WHERE status = 'pending';\n```\n\n**Using a Model**:\n\n```typescript\nconst result = await db.delete(Orders, {\n  where: \"status = 'pending'\",\n  joins: {\n    type: 'INNER',\n    table: 'users',\n    on: 'orders.user_id = users.id',\n  },\n});\nconsole.log(result); // Logs execution result\n```\n\n**Using a Table with Execution**:\n\n```typescript\nconst result = await db.delete('orders', {\n  where: \"status = 'pending'\",\n  joins: {\n    type: 'INNER',\n    table: 'users',\n    on: 'orders.user_id = users.id',\n  },\n}).execute();\nconsole.log(result); // Logs execution result\n```\n\n#### Deletion with Limit\n\nRestrict the number of deleted records.\n\n```typescript\nconst query = await db.delete('users', {\n  where: \"status = 'inactive'\",\n  limit: 10,\n}).build();\nconsole.log(query);\n// SQL: DELETE FROM users WHERE status = 'inactive' LIMIT 10;\n```\n\n#### Deletion with Sorting\n\nSort records before deletion.\n\n```typescript\nconst query = await db.delete('products', {\n  where: 'stock = 0',\n  sort: { field: 'created_at', order: 'ASC' },\n}).build();\nconsole.log(query);\n// SQL: DELETE FROM products WHERE stock = 0 ORDER BY created_at ASC;\n```\n\n---\n\n## 3. Types and Definitions\n\n### DeleteParamsType\n\nDefines the parameters for the `delete` function.\n\n```typescript\nexport interface DeleteParamsType<Tables extends string[]> {\n  where: string;                    // Condition for selecting rows to delete\n  sort?: SortType<Tables>;          // Optional sorting criteria\n  limit?: string | number;          // Optional limit on number of deleted rows\n  joins?: JoinsType<Tables>;        // Optional JOIN clauses for multi-table deletion\n}\n```\n\n### JoinsType\n\nSpecifies join configurations for multi-table deletions.\n\n```typescript\nexport type JoinsType<Tables extends string[]> = {\n  type: 'INNER' | 'LEFT' | 'RIGHT' | 'FULL'; // Join type\n  table: string;                             // Table to join\n  on: string;                                // Join condition\n};\n```\n\n### SortType\n\nDefines sorting criteria.\n\n```typescript\nexport type SortType<Tables extends string[]> = {\n  field: string;  // Field to sort by\n  order: 'ASC' | 'DESC'; // Sorting direction\n};\n```\n\n---\n\n## 4. Best Practices\n\n1. **Always Use a WHERE Clause**:\n   - Omitting the `where` clause deletes all rows in the table. Always specify conditions to avoid unintentional data loss.\n\n2. **Use Limits for Safety**:\n   - Apply the `limit` option in production to prevent accidental bulk deletions that could impact performance or data integrity.\n\n3. **Leverage Joins for Multi-Table Operations**:\n   - Use `joins` to ensure deletions are coordinated across related tables, maintaining referential integrity.\n\n4. **Preview Queries**:\n   - Use the `.build()` method to inspect the generated SQL query before executing it to confirm the correct rows are targeted.\n\n5. **Test in a Safe Environment**:\n   - Test delete operations in a development or staging environment to avoid accidental data loss in production.\n\n---\n"
    },
    {
      "id": 13,
      "path": "advanced-usage/setquery",
      "name": "SetQuery",
      "folder": "Advanced Usage",
      "content": "\n# `@dbnx/mysql` setQuery Method\n\nThe `setQuery` method in `@dbnx/mysql` allows you to overwrite the current SQL query with a new one. It provides logging to track query changes and avoid redundant updates, making it useful for debugging and query management.\n\n---\n\n## 1. Overview\n\nThe `setQuery` method updates the internal SQL query of a `DBnx` instance, replacing the existing query with a new one. It logs changes for transparency and supports method chaining, enabling seamless integration into query-building workflows.\n\n---\n\n## 2. Method Signature\n\n```typescript\nsetQuery(query: string): DBnx\n```\n\n---\n\n## 3. Parameters\n\n| Parameter | Type     | Description                              | Required |\n|-----------|----------|------------------------------------------|----------|\n| `query`   | `string` | The new SQL query to set.                | Yes      |\n\n---\n\n## 4. Returns\n\n- **`DBnx`**: The current `DBnx` instance, enabling method chaining.\n\n---\n\n## 5. Usage Example\n\n```typescript\n// Initialize DBnx instance\nconst db = new DBnx({ /* configuration */ }).connect();\n\n// Set a new query\ndb.setQuery('SELECT * FROM users');\n// Console: Query set to: SELECT * FROM users\n\n// Set the same query again\ndb.setQuery('SELECT * FROM users');\n// Console: Query remains the same: SELECT * FROM users\n\n// Set a different query\ndb.setQuery('SELECT * FROM products');\n// Console: Query set to: SELECT * FROM products\n\n// Chain with execution\nconst result = await db.setQuery('SELECT * FROM users WHERE id = 1').execute();\nconsole.log(result); // Logs query result\n```\n\n---\n"
    },
    {
      "id": 14,
      "path": "advanced-usage/multiple-execute-query",
      "name": "Multiple Execute Query",
      "folder": "Advanced Usage",
      "content": "\n# `@dbnx/mysql` executeMultiple() Method\n\nThe `executeMultiple()` method in `@dbnx/mysql` enables the execution of multiple database queries in sequence within a single transaction. This method supports chaining operations like `update`, `findAll`, `create`, `findOne`, and `delete`, providing a streamlined way to perform complex database operations.\n\n---\n\n## 1. Overview\n\nThe `executeMultiple()` method allows developers to chain multiple database operations (e.g., updates, inserts, queries, and deletions) and execute them sequentially in a single call. This approach ensures efficient query execution and simplifies transaction management, with built-in error handling and connection cleanup.\n\n---\n\n## 2. Setup Database Connection\n\nThe `DBnx` instance is initialized to establish a connection to the MySQL database.\n\n### Code\n\n```javascript\n// database.js\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nexport const db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '11224455',\n  database: 'world',\n  waitForConnections: true,\n  multipleStatements: true,\n  connectionLimit: 10,\n  queueLimit: 0,\n}).connect();\n```\n\n### Parameters\n\n| Parameter              | Type      | Description                                                                 |\n|------------------------|-----------|-----------------------------------------------------------------------------|\n| `host`                 | `string`  | MySQL server hostname or IP address.                                        |\n| `user`                 | `string`  | MySQL username.                                                             |\n| `password`             | `string`  | MySQL password.                                                             |\n| `database`             | `string`  | Database name.                                                              |\n| `waitForConnections`   | `boolean` | Wait for connections when the pool is full.                                 |\n| `multipleStatements`   | `boolean` | Allow multiple SQL statements in a single query.                            |\n| `connectionLimit`      | `number`  | Maximum number of connections in the pool.                                  |\n| `queueLimit`           | `number`  | Maximum number of queued connection requests (0 = no limit).                |\n\n---\n\n## 3. Using executeMultiple()\n\nThe `executeMultiple()` method executes a sequence of chained queries, such as updating records, retrieving data, inserting new records, and deleting records.\n\n### Example Code\n\n```javascript\n// executeQueries.js\nimport { db } from './database.js';\n\nasync function executeMultipleQueries() {\n  try {\n    const result = await db\n      .update('product', {\n        values: { title: 'SRAKIB brand' },\n        where: 'product_id = 1',\n      })\n      .findAll('product')\n      .create('product', {\n        title: 'test',\n      })\n      .findOne('product', {\n        where: 'product_id = 1',\n      })\n      .delete('product', {\n        where: 'product_id = 2',\n      })\n      .executeMultiple();\n\n    console.log('Multiple queries executed successfully:', result);\n  } catch (error) {\n    console.error('Error executing multiple queries:', error);\n  } finally {\n    await db.close(); // Close the database connection\n  }\n}\n\nexecuteMultipleQueries();\n```\n\n---\n\n## 4. Query Methods Breakdown\n\n### update\n\nUpdates existing records in a table.\n\n- **Signature**: `update(table: string, params: UpdateParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `params.values`: Object with column-value pairs to update.\n  - `params.where`: Condition for selecting records.\n\n### findAll\n\nRetrieves all records from a table.\n\n- **Signature**: `findAll(table: string, config?: FindAllParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `config`: Optional query configuration (e.g., filters, sorting).\n\n### create\n\nInserts a new record into a table.\n\n- **Signature**: `create(table: string, values: CreateParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `values`: Object with column-value pairs to insert.\n\n### findOne\n\nRetrieves a single record from a table.\n\n- **Signature**: `findOne(table: string, config?: FindOneParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `config.where`: Condition for selecting the record.\n\n### delete\n\nDeletes records from a table.\n\n- **Signature**: `delete(table: string, params: DeleteParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `params.where`: Condition for selecting records to delete.\n\n### executeMultiple\n\nExecutes all queued queries in sequence.\n\n- **Signature**: `executeMultiple(): Promise<ResponseType[]>`\n- **Returns**: An array of results from each query.\n\n---\n\n## 5. Error Handling\n\nWrap the query chain in a `try...catch` block to handle errors gracefully.\n\n### Example\n\n```javascript\ntry {\n  const result = await db\n    .update('product', { values: { title: 'SRAKIB brand' }, where: 'product_id = 1' })\n    .findAll('product')\n    .create('product', { title: 'test' })\n    .findOne('product', { where: 'product_id = 1' })\n    .delete('product', { where: 'product_id = 2' })\n    .executeMultiple();\n  console.log('Results:', result);\n} catch (error) {\n  console.error('Error executing query chain:', error);\n}\n```\n\n---\n\n## 6. Closing the Connection\n\nAlways close the database connection after executing queries to free up resources.\n\n```javascript\nawait db.close();\n```\n\n---\n\n## 7. Example Output\n\nUpon successful execution, the output will resemble:\n\n```plaintext\nMultiple queries executed successfully: [\n  { /* Update result */ },\n  { /* FindAll result */ },\n  { /* Create result */ },\n  { /* FindOne result */ },\n  { /* Delete result */ }\n]\n```\n\n---\n\n## 8. Best Practices\n\n1. **Use Transactions for Consistency**:\n   - Ensure all queries in the chain are executed within a transaction to maintain data integrity.\n\n2. **Validate Input Data**:\n   - Sanitize and validate input data (e.g., `values`, `where` conditions) to prevent SQL injection.\n\n3. **Preview Queries**:\n   - Use `.build()` to inspect generated SQL queries before execution, especially for complex chains.\n\n4. **Handle Errors Gracefully**:\n   - Implement robust error handling to capture and log issues without crashing the application.\n\n5. **Close Connections**:\n   - Always close the database connection in the `finally` block to avoid resource leaks.\n\n---\n"
    },
    {
      "id": 15,
      "path": "api-reference/crud/create",
      "name": "Create",
      "folder": "API Reference/Crud",
      "content": "# `@dbnx/mysql` executeMultiple() Method\n\nThe `executeMultiple()` method in `@dbnx/mysql` enables the execution of multiple database queries in sequence within a single transaction. This method supports chaining operations like `update`, `findAll`, `create`, `findOne`, and `delete`, providing a streamlined way to perform complex database operations.\n\n---\n\n## 1. Overview\n\nThe `executeMultiple()` method allows developers to chain multiple database operations (e.g., updates, inserts, queries, and deletions) and execute them sequentially in a single call. This approach ensures efficient query execution and simplifies transaction management, with built-in error handling and connection cleanup.\n\n---\n\n## 2. Setup Database Connection\n\nThe `DBnx` instance is initialized to establish a connection to the MySQL database.\n\n### Code\n\n```javascript\n// database.js\nimport { DBnx } from '@dbnx/mysql';\n\n// Initialize DBnx instance\nexport const db = new DBnx({\n  host: 'localhost',\n  user: 'root',\n  password: '11224455',\n  database: 'world',\n  waitForConnections: true,\n  multipleStatements: true,\n  connectionLimit: 10,\n  queueLimit: 0,\n}).connect();\n```\n\n### Parameters\n\n| Parameter              | Type      | Description                                                                 |\n|------------------------|-----------|-----------------------------------------------------------------------------|\n| `host`                 | `string`  | MySQL server hostname or IP address.                                        |\n| `user`                 | `string`  | MySQL username.                                                             |\n| `password`             | `string`  | MySQL password.                                                             |\n| `database`             | `string`  | Database name.                                                              |\n| `waitForConnections`   | `boolean` | Wait for connections when the pool is full.                                 |\n| `multipleStatements`   | `boolean` | Allow multiple SQL statements in a single query.                            |\n| `connectionLimit`      | `number`  | Maximum number of connections in the pool.                                  |\n| `queueLimit`           | `number`  | Maximum number of queued connection requests (0 = no limit).                |\n\n---\n\n## 3. Using executeMultiple()\n\nThe `executeMultiple()` method executes a sequence of chained queries, such as updating records, retrieving data, inserting new records, and deleting records.\n\n### Example Code\n\n```javascript\n// executeQueries.js\nimport { db } from './database.js';\n\nasync function executeMultipleQueries() {\n  try {\n    const result = await db\n      .update('product', {\n        values: { title: 'SRAKIB brand' },\n        where: 'product_id = 1',\n      })\n      .findAll('product')\n      .create('product', {\n        title: 'test',\n      })\n      .findOne('product', {\n        where: 'product_id = 1',\n      })\n      .delete('product', {\n        where: 'product_id = 2',\n      })\n      .executeMultiple();\n\n    console.log('Multiple queries executed successfully:', result);\n  } catch (error) {\n    console.error('Error executing multiple queries:', error);\n  } finally {\n    await db.close(); // Close the database connection\n  }\n}\n\nexecuteMultipleQueries();\n```\n\n---\n\n## 4. Query Methods Breakdown\n\n### update\n\nUpdates existing records in a table.\n\n- **Signature**: `update(table: string, params: UpdateParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `params.values`: Object with column-value pairs to update.\n  - `params.where`: Condition for selecting records.\n\n### findAll\n\nRetrieves all records from a table.\n\n- **Signature**: `findAll(table: string, config?: FindAllParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `config`: Optional query configuration (e.g., filters, sorting).\n\n### create\n\nInserts a new record into a table.\n\n- **Signature**: `create(table: string, values: CreateParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `values`: Object with column-value pairs to insert.\n\n### findOne\n\nRetrieves a single record from a table.\n\n- **Signature**: `findOne(table: string, config?: FindOneParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `config.where`: Condition for selecting the record.\n\n### delete\n\nDeletes records from a table.\n\n- **Signature**: `delete(table: string, params: DeleteParamsType): DBnx`\n- **Parameters**:\n  - `table`: Table name (e.g., `'product'`).\n  - `params.where`: Condition for selecting records to delete.\n\n### executeMultiple\n\nExecutes all queued queries in sequence.\n\n- **Signature**: `executeMultiple(): Promise<ResponseType[]>`\n- **Returns**: An array of results from each query.\n\n---\n\n## 5. Error Handling\n\nWrap the query chain in a `try...catch` block to handle errors gracefully.\n\n### Example\n\n```javascript\ntry {\n  const result = await db\n    .update('product', { values: { title: 'SRAKIB brand' }, where: 'product_id = 1' })\n    .findAll('product')\n    .create('product', { title: 'test' })\n    .findOne('product', { where: 'product_id = 1' })\n    .delete('product', { where: 'product_id = 2' })\n    .executeMultiple();\n  console.log('Results:', result);\n} catch (error) {\n  console.error('Error executing query chain:', error);\n}\n```\n\n---\n\n## 6. Closing the Connection\n\nAlways close the database connection after executing queries to free up resources.\n\n```javascript\nawait db.close();\n```\n\n---\n\n## 7. Example Output\n\nUpon successful execution, the output will resemble:\n\n```plaintext\nMultiple queries executed successfully: [\n  { /* Update result */ },\n  { /* FindAll result */ },\n  { /* Create result */ },\n  { /* FindOne result */ },\n  { /* Delete result */ }\n]\n```\n\n---\n\n## 8. Best Practices\n\n1. **Use Transactions for Consistency**:\n   - Ensure all queries in the chain are executed within a transaction to maintain data integrity.\n\n2. **Validate Input Data**:\n   - Sanitize and validate input data (e.g., `values`, `where` conditions) to prevent SQL injection.\n\n3. **Preview Queries**:\n   - Use `.build()` to inspect generated SQL queries before execution, especially for complex chains.\n\n4. **Handle Errors Gracefully**:\n   - Implement robust error handling to capture and log issues without crashing the application.\n\n5. **Close Connections**:\n   - Always close the database connection in the `finally` block to avoid resource leaks.\n\n---\n"
    },
    {
      "id": 16,
      "path": "api-reference/crud/delete",
      "name": "Delete",
      "folder": "API Reference/Crud",
      "content": "\n# `@dbnx/mysql` delete Method API Reference\n\nThe `delete` method in `@dbnx/mysql` enables the deletion of records from a MySQL database table or model based on specified conditions. It supports both table-based and model-based queries, with options for filtering, sorting, limiting, and joining tables.\n\n---\n\n## 1. Overview\n\nThe `delete` method removes records from a specified table or model, offering flexible configuration through the `DeleteParamsType` interface. It can be used with a raw table name for query building or with a model for immediate execution, supporting conditions, joins, sorting, and limits.\n\n---\n\n## 2. Method Signature\n\n```typescript\npublic delete<tables extends string[]>(table: string, props: DeleteParamsType<tables>): MySQLHandler;\npublic delete<tables extends string[]>(model: typeof Model, props: DeleteParamsType<tables>): Promise<ResponseType>;\npublic delete(...args: any): MySQLHandler | Promise<ResponseType>;\n```\n\n---\n\n## 3. Parameters\n\n| Parameter | Type                     | Description                                                                 | Required |\n|-----------|--------------------------|-----------------------------------------------------------------------------|----------|\n| `table`   | `string`                 | Name of the table to delete from (e.g., `'users'`).                         | Yes (if not using model) |\n| `model`   | `typeof Model`           | Model class for ORM-based deletion (e.g., `User`).                          | Yes (if not using table) |\n| `props`   | `DeleteParamsType`       | Configuration object specifying deletion conditions and options.            | Yes      |\n\n---\n\n## 4. Response\n\n- **Table Name**: Returns a `MySQLHandler` instance for query chaining (e.g., with `.build()` or `.execute()`).\n- **Model**: Returns a `Promise<ResponseType>` containing the result of the delete operation (e.g., number of affected rows).\n\n---\n\n## 5. DeleteParamsType\n\nThe `DeleteParamsType` interface defines the configuration for the delete operation.\n\n```typescript\nexport interface DeleteParamsType<Tables extends string[]> {\n  where: string;                    // Condition for selecting rows to delete\n  sort?: SortType<Tables>;          // Optional sorting criteria\n  limit?: string | number;          // Optional limit on number of deleted rows\n  joins?: JoinsType<Tables>;        // Optional JOIN clauses for multi-table deletion\n}\n```\n\n### Parameters\n\n| Parameter | Type                     | Description                                                                 |\n|-----------|--------------------------|-----------------------------------------------------------------------------|\n| `where`   | `string`                 | Condition for selecting records (e.g., `'age > 30'`).                       |\n| `sort`    | `SortType<Tables>`       | Sorting criteria (e.g., `{ name: 'ASC' }`).                                 |\n| `limit`   | `string \\| number`        | Maximum number of records to delete (e.g., `10`).                           |\n| `joins`   | `JoinsType<Tables>`      | Join conditions for multi-table deletions (e.g., `{ table: 'orders', on: 'users.id = orders.user_id' }`). |\n\n---\n\n## 6. Examples\n\n### Deleting Records Using a Table Name\n\nConstruct a delete query with sorting, limit, and joins.\n\n```typescript\nconst query = db.delete('users', {\n  where: 'age > 30',\n  sort: { name: 'ASC' },\n  limit: 10,\n  joins: { type: 'INNER', table: 'orders', on: 'users.id = orders.user_id' },\n}).build();\nconsole.log(query);\n// SQL: DELETE FROM users INNER JOIN orders ON users.id = orders.user_id WHERE age > 30 ORDER BY name ASC LIMIT 10;\n```\n\nExecute the query:\n\n```typescript\nconst result = await db.delete('users', {\n  where: 'age > 30',\n  sort: { name: 'ASC' },\n  limit: 10,\n}).execute();\nconsole.log(result); // Logs execution result\n```\n\n### Deleting Records Using a Model\n\nDelete records directly using a model.\n\n```typescript\nconst result = await User.delete({\n  where: 'age > 30',\n  sort: { name: 'ASC' },\n  limit: 10,\n});\nconsole.log(result); // Logs result of delete operation\n```\n\n---\n\n## 7. Errors\n\n| Error Message                                      | Cause                                              | Solution                                                                 |\n|----------------------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------|\n| `No arguments provided to 'delete'.`               | Missing table name or model.                       | Provide a valid table name or model as the first argument.               |\n| `Invalid first argument: must be a table name or a Model class.` | First argument is neither a string nor a model.    | Ensure the first argument is a valid table name or model class.          |\n| `Props must be a non-empty object.`                | Invalid or empty `props` object.                   | Provide a valid `DeleteParamsType` object with at least a `where` clause.|\n\n---\n\n## 8. Internal Methods\n\n- **`destroy`**: Constructs the `DELETE` SQL query based on the provided parameters.\n- **`parseJoins`**: Formats the `joins` parameter into SQL `JOIN` clauses.\n- **`parseSort`**: Formats the `sort` parameter into SQL `ORDER BY` clauses.\n\n---\n\n## 9. Use Cases\n\n- **Selective Deletion**: Delete specific records based on conditions (e.g., inactive users or outdated orders).\n- **Multi-Table Deletion**: Use `joins` to delete records from related tables while maintaining referential integrity.\n- **Controlled Deletion**: Apply `sort` and `limit` to delete records in a specific order or restrict the number of deletions.\n\n---\n"
    },
    {
      "id": 17,
      "path": "api-reference/crud/find",
      "name": "Find",
      "folder": "API Reference/Crud",
      "content": "\n# `@dbnx/mysql` API Reference: findAll, findOne, and Related Types\n\nThis API reference details the `findAll` and `findOne` methods, along with their supporting types (`JoinsType`, `SortType`, `OperatorType`, `FindOneParamsType`, and `FindAllParamsType`). These methods enable flexible querying of MySQL databases, supporting filtering, sorting, pagination, joins, subqueries, aggregates, and recursive CTEs.\n\n---\n\n## 1. findAll Method\n\n### Method Signature\n\n```typescript\npublic findAll<tables extends string[]>(table: string, config?: FindAllParamsType<tables>): MySQLHandler;\npublic findAll<tables extends string[]>(model: typeof Model, config?: FindAllParamsType<tables>): Promise<ResponseType>;\n```\n\n### Parameters\n\n| Parameter | Type                     | Description                                                                 | Required |\n|-----------|--------------------------|-----------------------------------------------------------------------------|----------|\n| `table`   | `string`                 | Name of the table to query (e.g., `'users'`).                               | Yes (if not using model) |\n| `model`   | `typeof Model`           | Model class for ORM-based queries (e.g., `User`).                           | Yes (if not using table) |\n| `config`  | `FindAllParamsType`      | Configuration object for customizing the query (e.g., filters, sorting).    | No       |\n\n### Returns\n\n- **Table Name**: Returns a `MySQLHandler` instance for query chaining (e.g., with `.build()` or `.execute()`).\n- **Model**: Returns a `Promise<ResponseType>` containing the query results.\n\n### Example\n\n```typescript\nconst results = await db.findAll('users', {\n  sort: { name: 1 },\n  limitSkip: { limit: 10, skip: 0 },\n  columns: ['name', 'email'],\n  where: 'status = \"active\"',\n}).execute();\nconsole.log(results); // Logs fetched records\n// SQL: SELECT name, email FROM users WHERE status = 'active' ORDER BY name ASC LIMIT 10 OFFSET 0;\n```\n\n**Using a Model**:\n\n```typescript\nconst results = await User.findAll({\n  sort: { name: 1 },\n  limitSkip: { limit: 10, skip: 0 },\n  columns: ['name', 'email'],\n  where: 'status = \"active\"',\n});\nconsole.log(results); // Logs fetched records\n```\n\n---\n\n## 2. findOne Method\n\n### Method Signature\n\n```typescript\npublic findOne<tables extends string[]>(table: string, config?: FindOneParamsType<tables>): MySQLHandler;\npublic findOne<tables extends string[]>(model: typeof Model, config?: FindOneParamsType<tables>): Promise<ResponseType>;\n```\n\n### Parameters\n\n| Parameter | Type                     | Description                                                                 | Required |\n|-----------|--------------------------|-----------------------------------------------------------------------------|----------|\n| `table`   | `string`                 | Name of the table to query (e.g., `'users'`).                               | Yes (if not using model) |\n| `model`   | `typeof Model`           | Model class for ORM-based queries (e.g., `User`).                           | Yes (if not using table) |\n| `config`  | `FindOneParamsType`      | Configuration object for customizing the query (e.g., filters, columns).    | No       |\n\n### Returns\n\n- **Table Name**: Returns a `MySQLHandler` instance for query chaining.\n- **Model**: Returns a `Promise<ResponseType>` containing the single record.\n\n### Example\n\n```typescript\nconst user = await db.findOne('users', {\n  where: 'id = 1',\n  columns: ['id', 'name', 'email'],\n}).execute();\nconsole.log(user); // Logs single record\n// SQL: SELECT id, name, email FROM users WHERE id = 1 LIMIT 1;\n```\n\n**Using a Model**:\n\n```typescript\nconst user = await User.findOne({\n  where: 'id = 1',\n  columns: ['id', 'name', 'email'],\n});\nconsole.log(user); // Logs single record\n```\n\n---\n\n## 3. JoinsType\n\n### Definition\n\n```typescript\nexport type JoinsType<Tables extends string[]> = Array<{\n  operator?: OperatorType | string;\n  type?: 'JOIN' | 'INNER JOIN' | 'OUTER JOIN' | 'CROSS JOIN' | 'RIGHT JOIN' | 'LEFT JOIN';\n} | {\n  on?: string;\n  table?: string;\n} | {\n  [key: string]: string;\n} | {\n  [P in Tables[number]]?: string;\n}>;\n```\n\n### Usage\n\nSpecifies join conditions for multi-table queries, including join type and operator.\n\n```typescript\nconst results = await db.findAll('users', {\n  joins: [\n    { type: 'INNER JOIN', table: 'profiles', on: 'users.id = profiles.user_id' },\n  ],\n  where: 'users.status = \"active\"',\n}).execute();\n// SQL: SELECT * FROM users INNER JOIN profiles ON users.id = profiles.user_id WHERE users.status = 'active';\n```\n\n---\n\n## 4. SortType\n\n### Definition\n\n```typescript\nexport type SortType<Tables extends string[]> = \n  | { [P in Tables[number]]?: Record<string, 1 | -1> }\n  | Record<string, 1 | -1>\n  | string;\n```\n\n### Usage\n\nDefines sorting criteria for query results. Use `1` for ascending and `-1` for descending.\n\n```typescript\nconst sortedResults = await db.findAll('products', {\n  sort: { price: -1 },\n}).execute();\n// SQL: SELECT * FROM products ORDER BY price DESC;\n```\n\n---\n\n## 5. OperatorType\n\n### Definition\n\n```typescript\nexport type OperatorType =\n  | '='\n  | '!='\n  | '<>'\n  | '<'\n  | '>'\n  | '<='\n  | '>='\n  | 'LIKE'\n  | 'IN'\n  | 'BETWEEN';\n```\n\n### Usage\n\nUsed in `where` clauses to define conditions.\n\n```typescript\nconst results = await db.findAll('orders', {\n  where: 'totalAmount > 100 AND status = \"completed\"',\n}).execute();\n// SQL: SELECT * FROM orders WHERE totalAmount > 100 AND status = 'completed';\n```\n\n---\n\n## 6. FindOneParamsType\n\n### Definition\n\n```typescript\nexport interface FindOneParamsType<Tables extends string[]> {\n  distinct?: boolean;\n  sort?: SortType<Tables>;\n  columns?: { [P in Tables[number]]?: string[] } | string | string[];\n  groupBy?: { [P in Tables[number]]?: string[] } | string | string[];\n  aggregates?: Array<{ [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string }>;\n  where?: string;\n  having?: string;\n  subQueries?: { query: string; as?: string }[];\n  joins?: JoinsType<Tables>;\n  recursiveCTE?: { baseCase: string; recursiveCase: string; alias: string };\n}\n```\n\n### Usage\n\nConfigures the `findOne` query with filters, sorting, and other options.\n\n```typescript\nconst user = await db.findOne('users', {\n  where: 'id = 1',\n  columns: ['id', 'name'],\n  joins: [{ type: 'LEFT JOIN', table: 'profiles', on: 'users.id = profiles.user_id' }],\n}).execute();\n// SQL: SELECT users.id, users.name FROM users LEFT JOIN profiles ON users.id = profiles.user_id WHERE id = 1 LIMIT 1;\n```\n\n---\n\n## 7. FindAllParamsType\n\n### Definition\n\n```typescript\nexport interface FindAllParamsType<Tables extends string[]> {\n  distinct?: boolean;\n  sort?: SortType<Tables>;\n  limitSkip?: { limit?: number; skip?: number };\n  columns?: { [P in Tables[number]]?: string[] } | string | string[];\n  groupBy?: { [P in Tables[number]]?: string[] } | string | string[];\n  aggregates?: Array<{ [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string }>;\n  where?: string;\n  having?: string;\n  subQueries?: { query: string; as?: string }[];\n  joins?: JoinsType<Tables>;\n  recursiveCTE?: { baseCase: string; recursiveCase: string; alias: string };\n}\n```\n\n### Usage\n\nConfigures the `findAll` query with pagination, filtering, and other options.\n\n```typescript\nconst results = await db.findAll('users', {\n  limitSkip: { limit: 5, skip: 10 },\n  where: 'status = \"active\"',\n  columns: ['id', 'name'],\n  sort: { name: 1 },\n  aggregates: [{ COUNT: 'id', alias: 'user_count' }],\n  groupBy: ['status'],\n  having: 'COUNT(id) > 2',\n}).execute();\n// SQL: SELECT users.id, users.name, COUNT(id) AS user_count FROM users WHERE status = 'active' GROUP BY status HAVING COUNT(id) > 2 ORDER BY name ASC LIMIT 5 OFFSET 10;\n```\n\n---\n"
    },
    {
      "id": 18,
      "path": "api-reference/crud/update",
      "name": "Update",
      "folder": "API Reference/Crud",
      "content": "\n# `@dbnx/mysql` update Method API Reference\n\nThe `update` method in `@dbnx/mysql` enables updating records in a MySQL database table or model based on specified conditions. It supports flexible configuration, including direct value updates, `CASE` expressions, joins, sorting, limits, and calculated fields, making it suitable for both simple and complex update operations.\n\n---\n\n## 1. Overview\n\nThe `update` method modifies existing records in a specified table or model, offering extensive customization through the `UpdateParamsType` interface. It supports both table-based queries (for query building) and model-based queries (for immediate execution), with options for conditional updates, joins, sorting, and more.\n\n---\n\n## 2. Method Signature\n\n```typescript\npublic update<tables extends string[]>(table: string, props: UpdateParamsType<tables>): MySQLHandler;\npublic update<tables extends string[]>(model: typeof Model, props: UpdateParamsType<tables>): Promise<ResponseType>;\npublic update(...args: any): MySQLHandler | Promise<ResponseType>;\n```\n\n---\n\n## 3. Parameters\n\n| Parameter | Type                     | Description                                                                 | Required |\n|-----------|--------------------------|-----------------------------------------------------------------------------|----------|\n| `table`   | `string`                 | Name of the table to update (e.g., `'users'`).                              | Yes (if not using model) |\n| `model`   | `typeof Model`           | Model class for ORM-based updates (e.g., `User`).                           | Yes (if not using table) |\n| `props`   | `UpdateParamsType`       | Configuration object specifying update values, conditions, and options.     | Yes      |\n\n---\n\n## 4. Response\n\n- **Table Name**: Returns a `MySQLHandler` instance for query chaining (e.g., with `.build()` or `.execute()`).\n- **Model**: Returns a `Promise<ResponseType>` containing the result of the update operation (e.g., number of affected rows).\n\n---\n\n## 5. UpdateParamsType\n\nThe `UpdateParamsType` interface defines the configuration for the update operation.\n\n```typescript\nexport type UpdateParamsType<Tables extends string[]> = {\n  values?: {\n    [key: string]: string | number | null | {\n      case: { when: string; then: any }[];\n      default: any;\n    };\n  };\n  sort?: { [P in Tables[number]]?: Record<string, 1 | -1> } | Record<string, 1 | -1> | string;\n  where: string;\n  defaultValues?: string[];\n  limit?: string | number;\n  joins?: JoinsType<Tables>;\n  fromSubQuery?: Record<string, string>;\n  setCalculations?: { [key: string]: string };\n};\n```\n\n### Parameters\n\n| Parameter          | Type                                      | Description                                                                 |\n|--------------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `values`           | `object`                                  | Columns and values to update (direct values or `CASE` expressions).         |\n| `sort`             | `object \\| string`                        | Sorting criteria (e.g., `{ name: 1 }` for ascending).                       |\n| `where`            | `string`                                  | Condition for selecting records (e.g., `'id = 5'`).                         |\n| `defaultValues`    | `string[]`                                | Columns to set to their default values.                                    |\n| `limit`            | `string \\| number`                        | Maximum number of records to update.                                       |\n| `joins`            | `JoinsType<Tables>`                       | Join conditions for multi-table updates.                                   |\n| `fromSubQuery`     | `Record<string, string>`                  | Subquery for updating records.                                             |\n| `setCalculations`  | `{ [key: string]: string }`               | Calculated values (e.g., `{ total_price: 'quantity * unit_price' }`).       |\n\n---\n\n## 6. Examples\n\n### Updating Records Using a Table Name\n\nConstruct an update query with sorting, limit, and joins.\n\n```typescript\nconst query = db.update('users', {\n  values: { age: 30, name: 'John' },\n  where: 'id = 5',\n  sort: { name: 'ASC' },\n  limit: 10,\n  joins: { type: 'INNER', table: 'orders', on: 'users.id = orders.user_id' },\n}).build();\nconsole.log(query);\n// SQL: UPDATE users INNER JOIN orders ON users.id = orders.user_id SET age = 30, name = 'John' WHERE id = 5 ORDER BY name ASC LIMIT 10;\n```\n\nExecute the query:\n\n```typescript\nconst result = await db.update('users', {\n  values: { age: 30, name: 'John' },\n  where: 'id = 5',\n}).execute();\nconsole.log(result); // Logs execution result\n```\n\n### Updating Records Using a Model\n\nUpdate records directly using a model.\n\n```typescript\nconst result = await User.update({\n  values: { age: 30, name: 'John' },\n  where: 'id = 5',\n  sort: { name: 'ASC' },\n  limit: 10,\n});\nconsole.log(result); // Logs result of update operation\n```\n\n### Using CASE Expressions\n\nPerform conditional updates with `CASE`.\n\n```typescript\nconst query = await db.update('users', {\n  values: {\n    age: {\n      case: [\n        { when: 'status = \"active\"', then: 35 },\n        { when: 'status = \"inactive\"', then: 25 },\n      ],\n      default: 30,\n    },\n  },\n  where: 'id = 5',\n}).build();\nconsole.log(query);\n// SQL: UPDATE users SET age = CASE WHEN status = 'active' THEN 35 WHEN status = 'inactive' THEN 25 ELSE 30 END WHERE id = 5;\n```\n\n### Using Joins and Calculations\n\nUpdate records with joins and calculated fields.\n\n```typescript\nconst query = await db.update('orders', {\n  values: { status: 'shipped' },\n  setCalculations: { total_price: 'quantity * unit_price' },\n  where: 'order_id = 100',\n  joins: { type: 'INNER', table: 'products', on: 'orders.product_id = products.id' },\n}).build();\nconsole.log(query);\n// SQL: UPDATE orders INNER JOIN products ON orders.product_id = products.id SET status = 'shipped', total_price = quantity * unit_price WHERE order_id = 100;\n```\n\n---\n\n## 7. Errors\n\n| Error Message                                      | Cause                                              | Solution                                                                 |\n|----------------------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------|\n| `No arguments provided to 'update'.`               | Missing table name or model.                       | Provide a valid table name or model as the first argument.               |\n| `Invalid first argument: must be a table name or a Model class.` | First argument is neither a string nor a model.    | Ensure the first argument is a valid table name or model class.          |\n| `Props must be a non-empty object.`                | Invalid or empty `props` object.                   | Provide a valid `UpdateParamsType` object with at least a `where` clause.|\n\n---\n\n## 8. Internal Methods\n\n- **`update`**: Constructs the SQL `UPDATE` query based on the provided parameters.\n- **`parseJoins`**: Formats the `joins` parameter into SQL `JOIN` clauses.\n- **`parseSort`**: Formats the `sort` parameter into SQL `ORDER BY` clauses.\n\n---\n\n## 9. Use Cases\n\n- **Simple Updates**: Update specific fields for records matching a condition (e.g., updating user details).\n- **Conditional Updates**: Use `CASE` expressions for dynamic updates based on conditions (e.g., setting different values for active vs. inactive users).\n- **Multi-Table Updates**: Use `joins` to update records across related tables (e.g., updating order status based on product data).\n- **Calculated Updates**: Use `setCalculations` for dynamic field updates (e.g., recalculating totals based on other columns).\n\n---\n"
    },
    {
      "id": 19,
      "path": "utilities/date-time",
      "name": "Date Time",
      "folder": "Utilities",
      "content": "\n## Functions\n\n### `mysql_datetime(date: Date | string): string`\n\nThis function takes a `Date` or `string` as input and formats it into MySQL's `DATETIME` format (`YYYY-MM-DD HH:mm:ss`).\n\n#### Parameters\n\n- `date`: A `Date` object or a string that can be parsed as a date.\n  - Example: `2024-11-24T14:30:00Z`, or `new Date()`.\n\n#### Returns\n\n- A string representing the date in MySQL `DATETIME` format: `YYYY-MM-DD HH:mm:ss`.\n\n#### Example Usage\n\n```javascript\nimport { mysql_datetime } from '@dbnx/mysql';\n\nconst date1 = mysql_datetime(new Date());\nconsole.log(date1);\n// Output: \"2024-11-24 14:30:00\"\n\nconst date2 = mysql_datetime('2024-11-24T14:30:00Z');\nconsole.log(date2);\n// Output: \"2024-11-24 14:30:00\"\n```\n\n---\n\n### `mysql_date(date: Date | string): string`\n\nThis function takes a `Date` or `string` as input and formats it into MySQL's `DATE` format (`YYYY-MM-DD`).\n\n#### Parameters\n\n- `date`: A `Date` object or a string that can be parsed as a date.\n  - Example: `2024-11-24T14:30:00Z`, or `new Date()`.\n\n#### Returns\n\n- A string representing the date in MySQL `DATE` format: `YYYY-MM-DD`.\n\n#### Example Usage\n\n```javascript\nimport { mysql_date } from '@dbnx/mysql';\n\nconst date1 = mysql_date(new Date());\nconsole.log(date1);\n// Output: \"2024-11-24\"\n\nconst date2 = mysql_date('2024-11-24T14:30:00Z');\nconsole.log(date2);\n// Output: \"2024-11-24\"\n```\n\n---\n\n### Notes\n\n- The `mysql_datetime` function ensures the date is always formatted in a consistent way, even for invalid input strings.\n- The `mysql_date` function provides a simpler date format, useful when only the date part (without time) is needed.\n"
    },
    {
      "id": 20,
      "path": "utilities/query-security-utilities",
      "name": "Query Security Utilities",
      "folder": "Utilities",
      "content": "\n---\n\n## **Function 1: `sanitize`**\n\n### **Purpose**\n\nSanitizes user input to make it safe for use in MySQL queries by escaping dangerous characters and converting `null` or `undefined` values to `NULL`.\n\n### **Usage**\n\n```typescript\nconst userInput = \"John's\"; // Untrusted user input\nconst sanitizedInput = sanitize(userInput); // Returns: 'John\\'s'\nconsole.log(sanitizedInput);\n```\n\n---\n\n## **Function 2: `escape`**\n\n### **Purpose**\n\nEscapes special characters in a string to neutralize SQL injection attempts. Handles `null`, `undefined`, `boolean`, and `number` inputs gracefully, returning safe representations for MySQL queries.\n\n### **Usage**\n\n```typescript\nconst dangerousInput = \"Robert'); DROP TABLE Students;--\";\nconst escapedValue = escape(dangerousInput);\n// Result: 'Robert\\'); DROP TABLE Students;--'\nconsole.log(escapedValue);\n```\n\n---\n\n## **Function 3: `format`**\n\n### **Purpose**\n\nFormats a query string by replacing placeholders (`?`) with sanitized and escaped values, ensuring secure parameterization of SQL queries.\n\n### **Definition**\n\n```typescript\n/**\n * Formats a query string by replacing placeholders (`?`) with escaped values.\n * @param query - The base SQL query with placeholders.\n * @param values - Array of values to replace placeholders.\n * @returns The formatted query string.\n */\nexport function format(query: string, values: any[]): string {\n    let i = 0;\n    return query.replace(/\\?/g, () => {\n        if (i >= values.length) {\n            throw new Error('Insufficient values provided for placeholders.');\n        }\n        const escapedValue = escape(values[i]);\n        i++;\n        return escapedValue;\n    });\n}\n```\n\n### **Usage**\n\n```typescript\nconst baseQuery = \"SELECT * FROM users WHERE username = ? AND status = ?\";\nconst params = [\"john_doe\", \"active\"];\nconst secureQuery = format(baseQuery, params);\n// Result: \"SELECT * FROM users WHERE username = 'john_doe' AND status = 'active'\"\nconsole.log(secureQuery);\n```\n\n---\n\n## **Enhanced Secure WHERE Clause**\n\nBuilds a secure `WHERE` clause for dynamic queries by sanitizing.\n\n```typescript\n\ndb.findAll('orders', {\n    where: sanitize('order_date BETWEEN \"2024-01-01\" AND \"2024-12-31\"'),\n    columns: ['id', 'customer_id', 'order_date'],\n});\n```\n\n---\n"
    },
    {
      "id": 21,
      "path": "examples/create-example",
      "name": "Create Example",
      "folder": "Examples",
      "content": "\n#### 1. Single Row Insert with Date Fields\n\n```typescript\n  const query = db.create('users', [{\n        id: 1,\n        name: 'John',\n        email: 'john@example.com',\n        avatar: null,\n        created_at: \"CURRENT_TIMESTAMP\"\n    }]);\nconsole.log(query.build())\n    //Output: INSERT INTO users (id, name, email, created_at) VALUES (1, 'John', 'john@example.com', CURRENT_TIMESTAMP)\n```\n\n#### 2. Multiple Row Insert with Date Fields\n\n```typescript\nconst query = db.create('users', [\n        {\n            id: 1,\n            name: 'John',\n            email: 'john@example.com'\n        },\n        {\n            id: 2,\n            name: 'Jane',\n            email: 'jane@example.com'\n        }\n]);\nconsole.log(query.build())\n//Output: INSERT INTO users (id, name, email) VALUES (1, 'John', 'john@example.com'), (2, 'Jane', 'jane@example.com')\n```\n\n#### 3. Insert with `ON DUPLICATE KEY UPDATE`\n\n```typescript\n\nconst user = db.create('users', [{\n     created_at: null,\n     username: 'dbnx',\n }], {\n     onDuplicateUpdateFields: ['name', 'email']\n }).build();\n// Output: INSERT INTO user (created_at, username) VALUES (NULL, 'dbnx') ON DUPLICATE KEY UPDATE name = VALUES(name), email = VALUES(email)      \n```\n\n#### 4. Insert with `INSERT IGNORE` to Prevent Duplicates\n\n```typescript\nconst query = db.create('users', {\n        id: 1, name: 'John', email: 'john@example.com'\n    },\n    {\n            uniqueColumn: 'id'\n}).build();\nconsole.log(query)\n// Output: INSERT IGNORE INTO users (id, name, email) VALUES (1, 'John', 'john@example.com')\n```\n"
    },
    {
      "id": 22,
      "path": "examples/find-example",
      "name": "Find Example",
      "folder": "Examples",
      "content": "## `findOne`/`findAll`\n\n### **Beginner Level**\n\n1. **Select All Rows**\n\n   ```typescript\n   db.findAll('users', {});\n   ```\n\n2. **Select Specific Columns**\n\n   ```typescript\n   db.findAll('users', { columns: ['id', 'name'] });\n   ```\n\n3. **Add a WHERE Clause**\n\n   ```typescript\n   db.findAll('users', { where: 'age > 18' });\n   ```\n\n4. **Add Sorting**\n\n   ```typescript\n   db.findAll('users', { sort: { name: 1 } });\n   ```\n\n5. **Apply DISTINCT**\n\n   ```typescript\n   db.findAll('users', { distinct: true });\n   ```\n\n6. **Apply LIMIT and OFFSET**\n\n   ```typescript\n   db.findAll('users', { limitSkip: { limit: 5, skip: 10 } });\n   ```\n\n---\n\n### **Intermediate Level**\n\n7. **Group Results**\n\n   ```typescript\n   db.findAll('sales', {\n       groupBy: ['region'],\n       aggregates: [{ SUM: 'amount', alias: 'total_sales' }],\n   });\n   ```\n\n8. **Filter with HAVING**\n\n   ```typescript\n   db.findAll('sales', {\n       groupBy: ['region'],\n       aggregates: [{ SUM: 'amount', alias: 'total_sales' }],\n       having: 'SUM(amount) > 1000',\n   });\n   ```\n\n9. **Join Two Tables**\n\n   ```typescript\n   db.findAll('orders', {\n       joins: [\n           { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n       ],\n       columns: ['orders.id', 'customers.name'],\n   });\n   ```\n\n10. **Perform Aggregations**\n\n   ```typescript\n   db.findAll('products', {\n       aggregates: [{ COUNT: '*', alias: 'total_products' }],\n   });\n   ```\n\n11. **Use Multiple Aggregates**\n\n   ```typescript\n   db.findAll('sales', {\n       aggregates: [\n           { SUM: 'amount', alias: 'total_amount' },\n           { AVG: 'amount', alias: 'average_amount' },\n       ],\n   });\n   ```\n\n12. **Multiple WHERE Conditions**\n\n   ```typescript\n   db.findAll('users', { where: 'age > 18 AND active = 1' });\n   ```\n\n---\n\n### **Advanced Level**\n\n13. **Recursive CTE**\n\n   ```typescript\n   db.findAll('categories', {\n       recursiveCTE: {\n           baseCase: 'SELECT id, parent_id FROM categories WHERE parent_id IS NULL',\n           recursiveCase: 'SELECT c.id, c.parent_id FROM categories c INNER JOIN tree t ON c.parent_id = t.id',\n           alias: 'tree',\n       },\n       columns: ['id', 'parent_id'],\n   });\n   ```\n\n14. **Join with Aggregates**\n\n   ```typescript\n   db.findAll('orders', {\n       joins: [\n           { type: 'LEFT JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n       ],\n       aggregates: [{ COUNT: 'orders.id', alias: 'order_count' }],\n       groupBy: ['customers.id'],\n   });\n   ```\n\n15. **Subqueries**\n\n   ```typescript\n   db.findAll('products', {\n       subQueries: [\n           { query: 'SELECT MAX(price) FROM products', as: 'max_price' },\n       ],\n       columns: ['id', 'name'],\n   });\n   ```\n\n16. **Using Aggregates and Joins**\n\n   ```typescript\n   db.findAll('sales', {\n       joins: [{ type: 'INNER JOIN', on: 'sales.product_id = products.id', table: 'products' }],\n       aggregates: [{ SUM: 'sales.amount', alias: 'total_sales' }],\n       groupBy: ['products.category_id'],\n   });\n   ```\n\n17. **Nested Aggregates**\n\n   ```typescript\n   db.findAll('orders', {\n       groupBy: ['customer_id'],\n       aggregates: [{ COUNT: '*', alias: 'order_count' }],\n       having: 'COUNT(*) > (SELECT AVG(order_count) FROM orders GROUP BY customer_id)',\n   });\n   ```\n\n18. **Multiple Joins**\n\n   ```typescript\n   db.findAll('orders', {\n       joins: [\n           { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n           { type: 'LEFT JOIN', on: 'orders.product_id = products.id', table: 'products' },\n       ],\n       columns: ['orders.id', 'customers.name', 'products.name'],\n   });\n   ```\n\n---\n\n### **Advanced Examples with Complex Queries**\n\n19. **Combined Aggregates and Subqueries**\n\n   ```typescript\n   db.findAll('orders', {\n       aggregates: [\n           { SUM: 'total', alias: 'total_sales' },\n           { AVG: 'total', alias: 'average_order' },\n       ],\n       subQueries: [{ query: 'SELECT COUNT(*) FROM customers', as: 'customer_count' }],\n   });\n   ```\n\n20. **Dynamic WHERE and Joins**\n\n   ```typescript\n   db.findAll('orders', {\n       where: 'status = \"completed\"',\n       joins: [\n           { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n       ],\n   });\n   ```\n\n### **21. Filtering by a Date Range**\n\n```typescript\ndb.findAll('orders', {\n    where: 'order_date BETWEEN \"2024-01-01\" AND \"2024-12-31\"',\n    columns: ['id', 'customer_id', 'order_date'],\n});\n```\n\n---\n\n### **22. Filtering with `IN` Operator**\n\n```typescript\ndb.findAll('products', {\n    where: 'category_id IN (1, 2, 3)',\n    columns: ['id', 'name', 'category_id'],\n});\n```\n\n---\n\n### **23. Joining More Than Three Tables**\n\n```typescript\ndb.findAll('orders', {\n    joins: [\n        { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n        { type: 'LEFT JOIN', on: 'orders.product_id = products.id', table: 'products' },\n        { type: 'RIGHT JOIN', on: 'products.supplier_id = suppliers.id', table: 'suppliers' },\n    ],\n    columns: ['orders.id', 'customers.name', 'products.name', 'suppliers.name'],\n});\n```\n\n---\n\n### **24. Combining `UNION` in Subqueries**\n\n```typescript\ndb.findAll('employees', {\n    subQueries: [\n        { query: 'SELECT id, name FROM employees WHERE department_id = 1', as: 'sales_team' },\n        { query: 'SELECT id, name FROM employees WHERE department_id = 2', as: 'support_team' },\n    ],\n});\n```\n\n---\n\n### **25. Performing Window Functions (e.g., Ranking)**\n\n```typescript\ndb.findAll('employees', {\n    columns: [\n        'id', \n        'name', \n        { query: 'ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC)', as: 'rank' },\n    ],\n});\n```\n\n---\n\n### **26. Aggregating with a Custom Alias Logic**\n\n```typescript\ndb.findAll('sales', {\n    aggregates: [\n        { SUM: 'amount', alias: 'total_revenue' },\n        { MAX: 'amount', alias: 'highest_sale' },\n        { MIN: 'amount', alias: 'lowest_sale' },\n    ],\n});\n```\n\n---\n\n### **27. Joining with Multiple Conditions**\n\n```typescript\ndb.findAll('orders', {\n    joins: [\n        {\n            type: 'INNER JOIN',\n            on: 'orders.customer_id = customers.id AND orders.status = \"completed\"',\n            table: 'customers',\n        },\n    ],\n    columns: ['orders.id', 'customers.name'],\n});\n```\n\n---\n\n### **28. Including Raw SQL in `WHERE` or Joins**\n\n```typescript\ndb.findAll('products', {\n    where: 'price > (SELECT AVG(price) FROM products)',\n    columns: ['id', 'name', 'price'],\n});\n```\n\n---\n\n### **29. Using Multiple `HAVING` Conditions**\n\n```typescript\ndb.findAll('sales', {\n    groupBy: ['region'],\n    aggregates: [{ SUM: 'amount', alias: 'total_sales' }],\n    having: 'SUM(amount) > 1000 AND COUNT(*) > 10',\n});\n```\n\n---\n\n### **30. Recursive Hierarchy with Aggregates**\n\n```typescript\ndb.findAll('categories', {\n    recursiveCTE: {\n        baseCase: 'SELECT id, parent_id, name FROM categories WHERE parent_id IS NULL',\n        recursiveCase: 'SELECT c.id, c.parent_id, c.name FROM categories c INNER JOIN category_tree ct ON c.parent_id = ct.id',\n        alias: 'category_tree',\n    },\n    aggregates: [{ COUNT: 'id', alias: 'total_categories' }],\n    groupBy: ['parent_id'],\n});\n```\n\n---\n"
    },
    {
      "id": 23,
      "path": "examples/update-example",
      "name": "Update Example",
      "folder": "Examples",
      "content": "\n---\n\n### **db.update('table_name', config)**\n\nThe `db.update` function allows you to perform an update on a table with a wide range of capabilities such as conditional updates, calculations, joins, and more. Below are various examples of how to use this function effectively.\n\n---\n\n### 1. **Simple Update**\n\nThis example demonstrates updating a single column with a constant value:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 60000 },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = 60000 WHERE id = 1;\n```\n\n---\n\n### 2. **Conditional Update with CASE WHEN**\n\nUse a `CASE` expression to conditionally update the column values:\n\n```typescript\nconst query = db.update('employees', {\n    values: {\n        salary: {\n            case: [\n                { when: \"position = 'Manager'\", then: 100000 },\n                { when: \"position = 'Developer'\", then: 80000 }\n            ],\n            default: 50000\n        }\n    },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = CASE WHEN position = 'Manager' THEN 100000\n//         WHEN position = 'Developer' THEN 80000 ELSE 50000 END WHERE id = 1;\n```\n\n---\n\n### 3. **Update with Calculation**\n\nHere, we apply a calculation to increase the salary by 10%:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 'salary * 1.1' },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = salary * 1.1 WHERE id = 1;\n```\n\n---\n\n### 4. **Update with Subquery in SET**\n\nThis example demonstrates updating a column using a subquery:\n\n```typescript\nconst query = db.update('orders', {\n    values: { total_amount: '(SELECT SUM(amount) FROM order_items WHERE order_id = orders.id)' },\n    where: 'status = \"pending\"'\n}).build();\nconsole.log(query);\n// Output: UPDATE orders SET total_amount = (SELECT SUM(amount) FROM order_items WHERE order_id = orders.id) WHERE status = 'pending';\n```\n\n---\n\n### 5. **Update Multiple Columns with Different Conditions**\n\nHere, we update multiple columns, each with its own condition:\n\n```typescript\nconst query = db.update('employees', {\n    values: {\n        salary: { case: [{ when: \"position = 'Manager'\", then: 120000 }], default: 50000 },\n        department: 'HR'\n    },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = CASE WHEN position = 'Manager' THEN 120000 ELSE 50000 END, department = 'HR' WHERE id = 1;\n```\n\n---\n\n### 6. **Update with NULL Values**\n\nSet columns to `NULL` for specific fields:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 70000, phone:null },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = 70000, phone = NULL WHERE id = 1;\n```\n\n---\n\n### 7. **Update with Default Values**\n\nHere we set certain columns to their default values:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 80000 },\n    defaultValues: ['address'],\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = 80000, address = DEFAULT WHERE id = 1;\n```\n\n---\n\n### 8. **Update with Joins**\n\nThis example demonstrates an update with a join between two tables:\n\n```typescript\nconst query = db.update('orders', {\n    values: { status: \"'completed'\" },\n    where: 'orders.id = 1',\n    joins: [\n        { type: 'INNER JOIN', table: 'customers', on: 'orders.customer_id = customers.id' }\n    ]\n}).build();\nconsole.log(query);\n// Output: UPDATE orders INNER JOIN customers ON orders.customer_id = customers.id SET status = 'completed' WHERE orders.id = 1;\n```\n\n---\n\n### 9. **Update with Sorting and Limit**\n\nUpdate the rows with sorting and limiting the number of rows to be updated:\n\n```typescript\nconst query = db.update('products', {\n    values: { price: 'price * 1.2' },\n    where: 'stock > 0',\n    sort: { name: -1 },\n    limit: 5\n}).build();\nconsole.log(query);\n// Output: UPDATE products SET price = price * 1.2 WHERE stock > 0 ORDER BY name DESC LIMIT 5;\n```\n\n---\n\n### 10. **Update with Multiple Joins**\n\nThis example demonstrates updating a table with multiple joins and complex conditions:\n\n```typescript\nconst query = db.update('orders', {\n    values: { total_amount: 'total_amount + (SELECT SUM(price) FROM order_items WHERE order_id = orders.id)' },\n    where: 'orders.status = \"pending\"',\n    joins: [\n        { type: 'INNER JOIN', table: 'order_items', on: 'orders.id = order_items.order_id' },\n        { type: 'LEFT JOIN', table: 'customers', on: 'orders.customer_id = customers.id' }\n    ]\n}).build();\nconsole.log(query);\n// Output: UPDATE orders INNER JOIN order_items ON orders.id = order_items.order_id LEFT JOIN customers ON orders.customer_id = customers.id\n//         SET total_amount = total_amount + (SELECT SUM(price) FROM order_items WHERE order_id = orders.id)\n//         WHERE orders.status = 'pending';\n```\n\n---\n"
    },
    {
      "id": 24,
      "path": "examples/delete-example",
      "name": "Delete Example",
      "folder": "Examples",
      "content": "### Delete Query Documentation Example for `db.delete()`\n\n---\n\n### 1. **Simple DELETE with WHERE Condition**\n\nDelete rows from the `employees` table where the `age` is greater than 60:\n\n```typescript\nconst result = await db.delete('employees', {\n    where: 'age > 60',\n    limit: 10\n}).build();\nconsole.log(result);\n// Output: DELETE FROM employees WHERE age > 60 LIMIT 10;\n```\n\n### 2. **DELETE with INNER JOIN**\n\nDelete rows from the `orders` table where the `status` is \"pending\" and join with the `customers` table based on the `customer_id`:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"pending\"',\n    joins: [\n        { type: 'INNER JOIN', table: 'customers', on: 'orders.customer_id = customers.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders INNER JOIN customers ON orders.customer_id = customers.id WHERE status = \"pending\";\n```\n\n### 3. **DELETE with LEFT JOIN**\n\nDelete rows from the `products` table where the `price` is lower than 100, while joining with the `categories` table using a `LEFT JOIN`:\n\n```typescript\nconst result = await db.delete('products', {\n    where: 'price < 100',\n    joins: [\n        { type: 'LEFT JOIN', table: 'categories', on: 'products.category_id = categories.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM products LEFT JOIN categories ON products.category_id = categories.id WHERE price < 100;\n```\n\n### 4. **DELETE with Sorting**\n\nDelete rows from the `orders` table where the `status` is \"shipped\" and sort the rows by `order_date` in descending order:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"shipped\"',\n    sort: { order_date: -1 }\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders WHERE status = \"shipped\" ORDER BY order_date DESC;\n```\n\n### 5. **DELETE with LIMIT**\n\nDelete only 5 rows from the `products` table where the `stock` is 0:\n\n```typescript\nconst result = await db.delete('products', {\n    where: 'stock = 0',\n    limit: 5\n}).build();\nconsole.log(result);\n// Output: DELETE FROM products WHERE stock = 0 LIMIT 5;\n```\n\n### 6. **DELETE with Multiple Joins**\n\nDelete rows from the `orders` table where the `status` is \"pending\", and join with both `customers` and `products` tables:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"pending\"',\n    joins: [\n        { type: 'INNER JOIN', table: 'customers', on: 'orders.customer_id = customers.id' },\n        { type: 'LEFT JOIN', table: 'products', on: 'orders.product_id = products.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders INNER JOIN customers ON orders.customer_id = customers.id LEFT JOIN products ON orders.product_id = products.id WHERE status = \"pending\";\n```\n\n### 7. **DELETE with WHERE, Sorting, and LIMIT**\n\nDelete rows from the `employees` table where the `position` is \"Intern\", sort by `hire_date` ascending, and limit to 10 rows:\n\n```typescript\nconst result = await db.delete('employees', {\n    where: 'position = \"Intern\"',\n    sort: { hire_date: 1 },\n    limit: 10\n}).build();\nconsole.log(result);\n// Output: DELETE FROM employees WHERE position = \"Intern\" ORDER BY hire_date ASC LIMIT 10;\n```\n\n### 8. **DELETE with WHERE and Complex Join**\n\nDelete rows from the `employees` table where the `salary` is greater than 50000, and join with `departments` and `projects` tables:\n\n```typescript\nconst result = await db.delete('employees', {\n    where: 'salary > 50000',\n    joins: [\n        { type: 'INNER JOIN', table: 'departments', on: 'employees.department_id = departments.id' },\n        { type: 'LEFT JOIN', table: 'projects', on: 'employees.project_id = projects.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM employees INNER JOIN departments ON employees.department_id = departments.id LEFT JOIN projects ON employees.project_id = projects.id WHERE salary > 50000;\n```\n\n### 9. **DELETE with RIGHT JOIN**\n\nDelete rows from the `orders` table where the `status` is \"cancelled\", and use a `RIGHT JOIN` with the `payments` table to identify orders with no payment:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"cancelled\"',\n    joins: [\n        { type: 'RIGHT JOIN', table: 'payments', on: 'orders.id = payments.order_id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders RIGHT JOIN payments ON orders.id = payments.order_id WHERE status = \"cancelled\";\n```\n\n### 10. **DELETE with Multiple Sorting Criteria**\n\nDelete rows from the `products` table where `stock` is less than 10, and sort by `price` in ascending order and `name` in descending order:\n\n```typescript\nconst result = await db.delete('products', {\n    where: 'stock < 10',\n    sort: { price: 1, name: -1 }\n}).build();\nconsole.log(result);\n// Output: DELETE FROM products WHERE stock < 10 ORDER BY price ASC, name DESC;\n```\n\n---\n\n### Notes\n\n- `where`: The condition for deleting rows (e.g., `age > 60` or `status = \"pending\"`).\n- `joins`: Array of JOIN operations for filtering data during deletion.\n- `limit`: The number of rows to delete.\n- `sort`: Sorting criteria to order the rows for deletion.\n- `table`: The name of the table from which rows will be deleted.\n"
    }
  ]
}