{
  "structure": [
    {
      "originalPath": "1. Release Note",
      "name": "Release Note",
      "path": "release-note",
      "type": "folder",
      "children": [
        {
          "originalPath": "198.v1.0.23.md",
          "id": 1,
          "name": "V1.0.23",
          "type": "file",
          "path": "release-note/v1023",
          "content": "\n---\n\n### Release Notes: Version 1.0.23\n\n**Date Released:** December 31, 2024\n\n#### New Features\n\n1. **Enhanced SQL Query Builder**  \n   - **Filter Enhancements:** The `dbnxCondition` function now supports more flexible filter conditions, including `IN`, `NOT IN`, `BETWEEN`, `NOT BETWEEN`, `IN RANGE`, `LIKE`, `NOT LIKE`, `REGEXP`, and logical conditions like `$or`, `$and`.\n   - **Pattern Matching Improvements:** Enhanced pattern handling for SQL `LIKE`, `NOT LIKE`, and `REGEXP` operators with proper sanitization and escape handling.\n   - **Null Checks:** Added support for `IS NULL` and `IS NOT NULL` conditions in SQL queries.\n   - **Improved Range Checks:** Added `inRange` and `BETWEEN` checks with clearer handling of number ranges.\n\n2. **Refined Data Sanitization:**  \n   - `sanitize()` method now automatically escapes special characters to protect against SQL injection and ensures safe query generation.\n\n3. **Better Logical Operations:**  \n   - The `$and` and `$or` operators are now more easily managed, allowing complex filter combinations for better flexibility in query construction.\n\n#### Bug Fixes\n\n- Fixed issue where `IN` and `NOT IN` conditions were not being sanitized correctly for arrays of values.\n- Resolved an issue with `BETWEEN` and `NOT BETWEEN` conditions where boundary values were not properly escaped.\n\n#### Documentation Updates\n\n- The type definitions for `FilterValue` and `Filters` have been updated to reflect new features and filter conditions.\n- Added examples for common use cases of the `dbnxCondition` function.\n- Improved inline comments and documentation for SQL generation, especially for pattern matching and range-based filters.\n\n#### Example Update\n\nHereâ€™s an updated example showcasing the use of the new filter conditions:\n\n```typescript\nconst filters: Filters = {\n    status: \"active\",\n    price: { between: [1000, 5000] },\n    tags: [\"electronics\", \"home\"],\n    location: { notIn: [\"New York\", \"California\"] },\n    stock: { inRange: [10, 50] },\n    updatedAt: { isNull: true },\n    title: { like: \"%phone%\" },\n    discount: {\n        eq: 34\n    },\n    description: { notLike: \"%old%\" },\n    color: {\n        $or: [\n            { like: \"red\" },\n            { like: \"blue\" },\n        ],\n    },\n    $and: {\n        category: \"electronics\",\n        brand: { regexp: \"^Samsung\" },\n    },\n};\n```\n\n---\n"
        },
        {
          "originalPath": "199.v1.0.16.md",
          "id": 2,
          "name": "V1.0.16",
          "type": "file",
          "path": "release-note/v1016",
          "content": "### Release Notes - Version 1.0.16\n\n#### New Features\n\n1. **Logger Functionality**:\n   - Introduced enhanced `logger_execute` functionality for more detailed logging throughout the application. This allows developers to track and log various database interactions (e.g., connections, queries, table manipulations) with clear and meaningful messages.\n   - Example Logs:\n     - `âœ¨ Creating model: \\`modelName\\``\n     - `ðŸ”„ Starting model synchronization...`\n     - `âŒ Error initializing model: \\`modelName\\`: Error message`\n\n   This feature improves debugging and enhances the overall visibility of database operations.\n\n2. **Updated `getConfig` Function**:\n   - The `getConfig` function has been updated to handle multiple configurations for both pool and connection-based instances.\n   - Returns:\n     - ConnectionConfig or PoolConfig, if available.\n     - If no config is available, it parses the MySQL URL string and returns the configuration parsed from the URL.\n\n   This improvement provides flexibility and ensures better configuration management for both single connections and connection pools.\n\n   **Example Usage**:\n\n   ```ts\n   const config = db.getConfig();\n   console.log(config); // Logs the current connection or pool config\n   ```\n\n3. **Version 1.0.16 Update**:\n   - This release marks the addition of the logging feature, improvements to the `getConfig` function, and several internal fixes that improve performance and stability.\n   - Version 1.0.16 includes stability enhancements related to table synchronization and handling dynamic queries for different table configurations.\n\n#### Updates & Enhancements\n\n1. **Enhanced Table Synchronization**:\n   - Improved synchronization of models with the database, including the ability to modify or add columns based on the current model schema.\n   - Logs are added for each significant change during model synchronization, including:\n     - `ðŸ› ï¸ Synchronizing model: \\`tableName\\``\n     - `ðŸ”„ Starting model synchronization...`\n\n2. **Error Handling**:\n   - Detailed error logging has been implemented across all database operations to ensure that errors are caught, logged, and handled appropriately.\n   - This allows for better traceability and quick identification of issues during execution.\n\n3. **Database Configuration**:\n   - A more flexible approach to handling configurations for database connections (single or pool-based) using either `ConnectionOptions` or `PoolOptions` as input parameters.\n   - Support for parsing MySQL URLs directly into configurations for easier management.\n\n#### Example Usage\n\n```ts\n// Logger function to log a message\nthis.dbInstance.logger_execute('ðŸ”„ Starting model synchronization...');\nthis.dbInstance.logger_execute('ðŸ› ï¸ Synchronizing model: `myTable`');\n\n// Accessing and logging database configuration\nconst config = this.dbInstance.getConfig();\nconsole.log(config); // Logs current configuration (connection or pool)\n\n// Initialize model\nMyModel.init('myDatabase.myTable', modelAttributes, dbInstance, options);\n```\n\n---\n\n#### Bug Fixes\n\n- Fixed issues with table synchronization when a column exists but doesn't match the model schema.\n- Minor improvements to logging formatting to ensure consistency across all database operations.\n\n#### Known Issues\n\n- None reported at this time.\n\n---\n"
        },
        {
          "originalPath": "200.v1.0.3.md",
          "id": 3,
          "name": "V1.0.3",
          "type": "file",
          "path": "release-note/v103",
          "content": "### Release Notes for `@dbnx/mysql` v1.0.3  \n\n#### **Release Date:**  \n\nDecember 5, 2024  \n\n---\n\n### **Initial Version - 1.0.3**\n\n#### **Key Features:**  \n\n1. **Database Connection Management:**  \n   - Seamlessly connect to MySQL databases with easy configuration.  \n   - Support for both single connection and connection pooling for optimized performance.  \n\n2. **Query Execution:**  \n   - Execute raw SQL queries with support for prepared statements to prevent SQL injection.  \n   - Parameterized queries for secure and efficient database operations.  \n\n3. **CRUD Operations:**  \n   - Built-in support for `CREATE`, `READ`, `UPDATE`, and `DELETE` (CRUD) queries using simple methods.  \n   - Flexible query methods for dynamic operations.\n\n4. **Error Handling:**  \n   - Clear and descriptive error messages for easier debugging.  \n   - Graceful connection recovery for transient errors.  \n\n5. **Async/Await Support:**  \n   - Fully asynchronous API to integrate with modern Node.js applications.  \n\n6. **Connection Pooling:**  \n   - Built-in connection pooling to handle multiple concurrent requests efficiently.  \n\n7. **Lightweight and Performant:**  \n   - Minimal overhead for high-performance database operations.  \n\n8. **Well-Documented API:**  \n   - Comprehensive method documentation for developers to quickly get started.\n\n---\n\n#### **Bug Fixes:**  \n\n- N/A (Initial Release).  \n\n---\n\n#### **Known Issues:**  \n\n- None reported as of this version.  \n\n---\n\n#### **How to Install:**  \n\n```bash\nnpm install @dbnx/mysql\n```\n\n---\n\n#### **Future Plans:**  \n\n- Add support for transaction management.  \n- Introduce query builders for enhanced usability.  \n- Provide TypeScript decorators for models in upcoming releases.  \n\n**Contributions and Feedback:**  \nWe welcome feedback, bug reports, and feature requests!  \nPlease share your thoughts on our [GitHub repository](https://github.com/SRAKIB17/dbnx-mysql).  \n\n---\n\nEnjoy seamless MySQL integration with `@dbnx/mysql`! ðŸš€\n"
        }
      ]
    },
    {
      "originalPath": "10.Utilities",
      "name": "Utilities",
      "path": "utilities",
      "type": "folder",
      "children": [
        {
          "originalPath": "1.Date Time.md",
          "id": 4,
          "name": "Date Time",
          "type": "file",
          "path": "utilities/date-time",
          "content": "\n## Functions\n\n### `mysql_datetime(date: Date | string): string`\n\nThis function takes a `Date` or `string` as input and formats it into MySQL's `DATETIME` format (`YYYY-MM-DD HH:mm:ss`).\n\n#### Parameters\n\n- `date`: A `Date` object or a string that can be parsed as a date.\n  - Example: `2024-11-24T14:30:00Z`, or `new Date()`.\n\n#### Returns\n\n- A string representing the date in MySQL `DATETIME` format: `YYYY-MM-DD HH:mm:ss`.\n\n#### Example Usage\n\n```javascript\nimport { mysql_datetime } from '@dbnx/mysql';\n\nconst date1 = mysql_datetime(new Date());\nconsole.log(date1);\n// Output: \"2024-11-24 14:30:00\"\n\nconst date2 = mysql_datetime('2024-11-24T14:30:00Z');\nconsole.log(date2);\n// Output: \"2024-11-24 14:30:00\"\n```\n\n---\n\n### `mysql_date(date: Date | string): string`\n\nThis function takes a `Date` or `string` as input and formats it into MySQL's `DATE` format (`YYYY-MM-DD`).\n\n#### Parameters\n\n- `date`: A `Date` object or a string that can be parsed as a date.\n  - Example: `2024-11-24T14:30:00Z`, or `new Date()`.\n\n#### Returns\n\n- A string representing the date in MySQL `DATE` format: `YYYY-MM-DD`.\n\n#### Example Usage\n\n```javascript\nimport { mysql_date } from '@dbnx/mysql';\n\nconst date1 = mysql_date(new Date());\nconsole.log(date1);\n// Output: \"2024-11-24\"\n\nconst date2 = mysql_date('2024-11-24T14:30:00Z');\nconsole.log(date2);\n// Output: \"2024-11-24\"\n```\n\n---\n\n### Notes\n\n- The `mysql_datetime` function ensures the date is always formatted in a consistent way, even for invalid input strings.\n- The `mysql_date` function provides a simpler date format, useful when only the date part (without time) is needed.\n"
        },
        {
          "originalPath": "2.Query Security Utilities.md",
          "id": 5,
          "name": "Query Security Utilities",
          "type": "file",
          "path": "utilities/query-security-utilities",
          "content": "\n---\n\n## **Function 1: `sanitize`**\n\n### **Purpose**\n\nSanitizes user input to make it safe for use in MySQL queries by escaping dangerous characters and converting `null` or `undefined` values to `NULL`.\n\n### **Usage**\n\n```typescript\nconst userInput = \"John's\"; // Untrusted user input\nconst sanitizedInput = sanitize(userInput); // Returns: 'John\\'s'\nconsole.log(sanitizedInput);\n```\n\n---\n\n## **Function 2: `escape`**\n\n### **Purpose**\n\nEscapes special characters in a string to neutralize SQL injection attempts. Handles `null`, `undefined`, `boolean`, and `number` inputs gracefully, returning safe representations for MySQL queries.\n\n### **Usage**\n\n```typescript\nconst dangerousInput = \"Robert'); DROP TABLE Students;--\";\nconst escapedValue = escape(dangerousInput);\n// Result: 'Robert\\'); DROP TABLE Students;--'\nconsole.log(escapedValue);\n```\n\n---\n\n## **Function 3: `format`**\n\n### **Purpose**\n\nFormats a query string by replacing placeholders (`?`) with sanitized and escaped values, ensuring secure parameterization of SQL queries.\n\n### **Definition**\n\n```typescript\n/**\n * Formats a query string by replacing placeholders (`?`) with escaped values.\n * @param query - The base SQL query with placeholders.\n * @param values - Array of values to replace placeholders.\n * @returns The formatted query string.\n */\nexport function format(query: string, values: any[]): string {\n    let i = 0;\n    return query.replace(/\\?/g, () => {\n        if (i >= values.length) {\n            throw new Error('Insufficient values provided for placeholders.');\n        }\n        const escapedValue = escape(values[i]);\n        i++;\n        return escapedValue;\n    });\n}\n```\n\n### **Usage**\n\n```typescript\nconst baseQuery = \"SELECT * FROM users WHERE username = ? AND status = ?\";\nconst params = [\"john_doe\", \"active\"];\nconst secureQuery = format(baseQuery, params);\n// Result: \"SELECT * FROM users WHERE username = 'john_doe' AND status = 'active'\"\nconsole.log(secureQuery);\n```\n\n---\n\n## **Enhanced Secure WHERE Clause**\n\nBuilds a secure `WHERE` clause for dynamic queries by sanitizing.\n\n```typescript\n\ndb.findAll('orders', {\n    where: sanitize('order_date BETWEEN \"2024-01-01\" AND \"2024-12-31\"'),\n    columns: ['id', 'customer_id', 'order_date'],\n});\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "11. Examples",
      "name": "Examples",
      "path": "examples",
      "type": "folder",
      "children": [
        {
          "originalPath": "1.Create Example.md",
          "id": 6,
          "name": "Create Example",
          "type": "file",
          "path": "examples/create-example",
          "content": "\n#### 1. Single Row Insert with Date Fields\n\n```typescript\n  const query = db.create('users', [{\n        id: 1,\n        name: 'John',\n        email: 'john@example.com',\n        avatar: null,\n        created_at: \"CURRENT_TIMESTAMP\"\n    }]);\nconsole.log(query.build())\n    //Output: INSERT INTO users (id, name, email, created_at) VALUES (1, 'John', 'john@example.com', CURRENT_TIMESTAMP)\n```\n\n#### 2. Multiple Row Insert with Date Fields\n\n```typescript\nconst query = db.create('users', [\n        {\n            id: 1,\n            name: 'John',\n            email: 'john@example.com'\n        },\n        {\n            id: 2,\n            name: 'Jane',\n            email: 'jane@example.com'\n        }\n]);\nconsole.log(query.build())\n//Output: INSERT INTO users (id, name, email) VALUES (1, 'John', 'john@example.com'), (2, 'Jane', 'jane@example.com')\n```\n\n#### 3. Insert with `ON DUPLICATE KEY UPDATE`\n\n```typescript\n\nconst user = db.create('users', [{\n     created_at: null,\n     username: 'dbnx',\n }], {\n     onDuplicateUpdateFields: ['name', 'email']\n }).build();\n// Output: INSERT INTO user (created_at, username) VALUES (NULL, 'dbnx') ON DUPLICATE KEY UPDATE name = VALUES(name), email = VALUES(email)      \n```\n\n#### 4. Insert with `INSERT IGNORE` to Prevent Duplicates\n\n```typescript\nconst query = db.create('users', {\n        id: 1, name: 'John', email: 'john@example.com'\n    },\n    {\n            uniqueColumn: 'id'\n}).build();\nconsole.log(query)\n// Output: INSERT IGNORE INTO users (id, name, email) VALUES (1, 'John', 'john@example.com')\n```\n"
        },
        {
          "originalPath": "2.Find Example.md",
          "id": 7,
          "name": "Find Example",
          "type": "file",
          "path": "examples/find-example",
          "content": "## `findOne`/`findAll`\n\n### **Beginner Level**\n\n1. **Select All Rows**\n\n   ```typescript\n   db.findAll('users', {});\n   ```\n\n2. **Select Specific Columns**\n\n   ```typescript\n   db.findAll('users', { columns: ['id', 'name'] });\n   ```\n\n3. **Add a WHERE Clause**\n\n   ```typescript\n   db.findAll('users', { where: 'age > 18' });\n   ```\n\n4. **Add Sorting**\n\n   ```typescript\n   db.findAll('users', { sort: { name: 1 } });\n   ```\n\n5. **Apply DISTINCT**\n\n   ```typescript\n   db.findAll('users', { distinct: true });\n   ```\n\n6. **Apply LIMIT and OFFSET**\n\n   ```typescript\n   db.findAll('users', { limitSkip: { limit: 5, skip: 10 } });\n   ```\n\n---\n\n### **Intermediate Level**\n\n7. **Group Results**\n\n   ```typescript\n   db.findAll('sales', {\n       groupBy: ['region'],\n       aggregates: [{ SUM: 'amount', alias: 'total_sales' }],\n   });\n   ```\n\n8. **Filter with HAVING**\n\n   ```typescript\n   db.findAll('sales', {\n       groupBy: ['region'],\n       aggregates: [{ SUM: 'amount', alias: 'total_sales' }],\n       having: 'SUM(amount) > 1000',\n   });\n   ```\n\n9. **Join Two Tables**\n\n   ```typescript\n   db.findAll('orders', {\n       joins: [\n           { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n       ],\n       columns: ['orders.id', 'customers.name'],\n   });\n   ```\n\n10. **Perform Aggregations**\n\n   ```typescript\n   db.findAll('products', {\n       aggregates: [{ COUNT: '*', alias: 'total_products' }],\n   });\n   ```\n\n11. **Use Multiple Aggregates**\n\n   ```typescript\n   db.findAll('sales', {\n       aggregates: [\n           { SUM: 'amount', alias: 'total_amount' },\n           { AVG: 'amount', alias: 'average_amount' },\n       ],\n   });\n   ```\n\n12. **Multiple WHERE Conditions**\n\n   ```typescript\n   db.findAll('users', { where: 'age > 18 AND active = 1' });\n   ```\n\n---\n\n### **Advanced Level**\n\n13. **Recursive CTE**\n\n   ```typescript\n   db.findAll('categories', {\n       recursiveCTE: {\n           baseCase: 'SELECT id, parent_id FROM categories WHERE parent_id IS NULL',\n           recursiveCase: 'SELECT c.id, c.parent_id FROM categories c INNER JOIN tree t ON c.parent_id = t.id',\n           alias: 'tree',\n       },\n       columns: ['id', 'parent_id'],\n   });\n   ```\n\n14. **Join with Aggregates**\n\n   ```typescript\n   db.findAll('orders', {\n       joins: [\n           { type: 'LEFT JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n       ],\n       aggregates: [{ COUNT: 'orders.id', alias: 'order_count' }],\n       groupBy: ['customers.id'],\n   });\n   ```\n\n15. **Subqueries**\n\n   ```typescript\n   db.findAll('products', {\n       subQueries: [\n           { query: 'SELECT MAX(price) FROM products', as: 'max_price' },\n       ],\n       columns: ['id', 'name'],\n   });\n   ```\n\n16. **Using Aggregates and Joins**\n\n   ```typescript\n   db.findAll('sales', {\n       joins: [{ type: 'INNER JOIN', on: 'sales.product_id = products.id', table: 'products' }],\n       aggregates: [{ SUM: 'sales.amount', alias: 'total_sales' }],\n       groupBy: ['products.category_id'],\n   });\n   ```\n\n17. **Nested Aggregates**\n\n   ```typescript\n   db.findAll('orders', {\n       groupBy: ['customer_id'],\n       aggregates: [{ COUNT: '*', alias: 'order_count' }],\n       having: 'COUNT(*) > (SELECT AVG(order_count) FROM orders GROUP BY customer_id)',\n   });\n   ```\n\n18. **Multiple Joins**\n\n   ```typescript\n   db.findAll('orders', {\n       joins: [\n           { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n           { type: 'LEFT JOIN', on: 'orders.product_id = products.id', table: 'products' },\n       ],\n       columns: ['orders.id', 'customers.name', 'products.name'],\n   });\n   ```\n\n---\n\n### **Advanced Examples with Complex Queries**\n\n19. **Combined Aggregates and Subqueries**\n\n   ```typescript\n   db.findAll('orders', {\n       aggregates: [\n           { SUM: 'total', alias: 'total_sales' },\n           { AVG: 'total', alias: 'average_order' },\n       ],\n       subQueries: [{ query: 'SELECT COUNT(*) FROM customers', as: 'customer_count' }],\n   });\n   ```\n\n20. **Dynamic WHERE and Joins**\n\n   ```typescript\n   db.findAll('orders', {\n       where: 'status = \"completed\"',\n       joins: [\n           { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n       ],\n   });\n   ```\n\n### **21. Filtering by a Date Range**\n\n```typescript\ndb.findAll('orders', {\n    where: 'order_date BETWEEN \"2024-01-01\" AND \"2024-12-31\"',\n    columns: ['id', 'customer_id', 'order_date'],\n});\n```\n\n---\n\n### **22. Filtering with `IN` Operator**\n\n```typescript\ndb.findAll('products', {\n    where: 'category_id IN (1, 2, 3)',\n    columns: ['id', 'name', 'category_id'],\n});\n```\n\n---\n\n### **23. Joining More Than Three Tables**\n\n```typescript\ndb.findAll('orders', {\n    joins: [\n        { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n        { type: 'LEFT JOIN', on: 'orders.product_id = products.id', table: 'products' },\n        { type: 'RIGHT JOIN', on: 'products.supplier_id = suppliers.id', table: 'suppliers' },\n    ],\n    columns: ['orders.id', 'customers.name', 'products.name', 'suppliers.name'],\n});\n```\n\n---\n\n### **24. Combining `UNION` in Subqueries**\n\n```typescript\ndb.findAll('employees', {\n    subQueries: [\n        { query: 'SELECT id, name FROM employees WHERE department_id = 1', as: 'sales_team' },\n        { query: 'SELECT id, name FROM employees WHERE department_id = 2', as: 'support_team' },\n    ],\n});\n```\n\n---\n\n### **25. Performing Window Functions (e.g., Ranking)**\n\n```typescript\ndb.findAll('employees', {\n    columns: [\n        'id', \n        'name', \n        { query: 'ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC)', as: 'rank' },\n    ],\n});\n```\n\n---\n\n### **26. Aggregating with a Custom Alias Logic**\n\n```typescript\ndb.findAll('sales', {\n    aggregates: [\n        { SUM: 'amount', alias: 'total_revenue' },\n        { MAX: 'amount', alias: 'highest_sale' },\n        { MIN: 'amount', alias: 'lowest_sale' },\n    ],\n});\n```\n\n---\n\n### **27. Joining with Multiple Conditions**\n\n```typescript\ndb.findAll('orders', {\n    joins: [\n        {\n            type: 'INNER JOIN',\n            on: 'orders.customer_id = customers.id AND orders.status = \"completed\"',\n            table: 'customers',\n        },\n    ],\n    columns: ['orders.id', 'customers.name'],\n});\n```\n\n---\n\n### **28. Including Raw SQL in `WHERE` or Joins**\n\n```typescript\ndb.findAll('products', {\n    where: 'price > (SELECT AVG(price) FROM products)',\n    columns: ['id', 'name', 'price'],\n});\n```\n\n---\n\n### **29. Using Multiple `HAVING` Conditions**\n\n```typescript\ndb.findAll('sales', {\n    groupBy: ['region'],\n    aggregates: [{ SUM: 'amount', alias: 'total_sales' }],\n    having: 'SUM(amount) > 1000 AND COUNT(*) > 10',\n});\n```\n\n---\n\n### **30. Recursive Hierarchy with Aggregates**\n\n```typescript\ndb.findAll('categories', {\n    recursiveCTE: {\n        baseCase: 'SELECT id, parent_id, name FROM categories WHERE parent_id IS NULL',\n        recursiveCase: 'SELECT c.id, c.parent_id, c.name FROM categories c INNER JOIN category_tree ct ON c.parent_id = ct.id',\n        alias: 'category_tree',\n    },\n    aggregates: [{ COUNT: 'id', alias: 'total_categories' }],\n    groupBy: ['parent_id'],\n});\n```\n\n---\n"
        },
        {
          "originalPath": "3.Update Example.md",
          "id": 8,
          "name": "Update Example",
          "type": "file",
          "path": "examples/update-example",
          "content": "\n---\n\n### **db.update('table_name', config)**\n\nThe `db.update` function allows you to perform an update on a table with a wide range of capabilities such as conditional updates, calculations, joins, and more. Below are various examples of how to use this function effectively.\n\n---\n\n### 1. **Simple Update**\n\nThis example demonstrates updating a single column with a constant value:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 60000 },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = 60000 WHERE id = 1;\n```\n\n---\n\n### 2. **Conditional Update with CASE WHEN**\n\nUse a `CASE` expression to conditionally update the column values:\n\n```typescript\nconst query = db.update('employees', {\n    values: {\n        salary: {\n            case: [\n                { when: \"position = 'Manager'\", then: 100000 },\n                { when: \"position = 'Developer'\", then: 80000 }\n            ],\n            default: 50000\n        }\n    },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = CASE WHEN position = 'Manager' THEN 100000\n//         WHEN position = 'Developer' THEN 80000 ELSE 50000 END WHERE id = 1;\n```\n\n---\n\n### 3. **Update with Calculation**\n\nHere, we apply a calculation to increase the salary by 10%:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 'salary * 1.1' },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = salary * 1.1 WHERE id = 1;\n```\n\n---\n\n### 4. **Update with Subquery in SET**\n\nThis example demonstrates updating a column using a subquery:\n\n```typescript\nconst query = db.update('orders', {\n    values: { total_amount: '(SELECT SUM(amount) FROM order_items WHERE order_id = orders.id)' },\n    where: 'status = \"pending\"'\n}).build();\nconsole.log(query);\n// Output: UPDATE orders SET total_amount = (SELECT SUM(amount) FROM order_items WHERE order_id = orders.id) WHERE status = 'pending';\n```\n\n---\n\n### 5. **Update Multiple Columns with Different Conditions**\n\nHere, we update multiple columns, each with its own condition:\n\n```typescript\nconst query = db.update('employees', {\n    values: {\n        salary: { case: [{ when: \"position = 'Manager'\", then: 120000 }], default: 50000 },\n        department: 'HR'\n    },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = CASE WHEN position = 'Manager' THEN 120000 ELSE 50000 END, department = 'HR' WHERE id = 1;\n```\n\n---\n\n### 6. **Update with NULL Values**\n\nSet columns to `NULL` for specific fields:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 70000, phone:null },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = 70000, phone = NULL WHERE id = 1;\n```\n\n---\n\n### 7. **Update with Default Values**\n\nHere we set certain columns to their default values:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 80000 },\n    defaultValues: ['address'],\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = 80000, address = DEFAULT WHERE id = 1;\n```\n\n---\n\n### 8. **Update with Joins**\n\nThis example demonstrates an update with a join between two tables:\n\n```typescript\nconst query = db.update('orders', {\n    values: { status: \"'completed'\" },\n    where: 'orders.id = 1',\n    joins: [\n        { type: 'INNER JOIN', table: 'customers', on: 'orders.customer_id = customers.id' }\n    ]\n}).build();\nconsole.log(query);\n// Output: UPDATE orders INNER JOIN customers ON orders.customer_id = customers.id SET status = 'completed' WHERE orders.id = 1;\n```\n\n---\n\n### 9. **Update with Sorting and Limit**\n\nUpdate the rows with sorting and limiting the number of rows to be updated:\n\n```typescript\nconst query = db.update('products', {\n    values: { price: 'price * 1.2' },\n    where: 'stock > 0',\n    sort: { name: -1 },\n    limit: 5\n}).build();\nconsole.log(query);\n// Output: UPDATE products SET price = price * 1.2 WHERE stock > 0 ORDER BY name DESC LIMIT 5;\n```\n\n---\n\n### 10. **Update with Multiple Joins**\n\nThis example demonstrates updating a table with multiple joins and complex conditions:\n\n```typescript\nconst query = db.update('orders', {\n    values: { total_amount: 'total_amount + (SELECT SUM(price) FROM order_items WHERE order_id = orders.id)' },\n    where: 'orders.status = \"pending\"',\n    joins: [\n        { type: 'INNER JOIN', table: 'order_items', on: 'orders.id = order_items.order_id' },\n        { type: 'LEFT JOIN', table: 'customers', on: 'orders.customer_id = customers.id' }\n    ]\n}).build();\nconsole.log(query);\n// Output: UPDATE orders INNER JOIN order_items ON orders.id = order_items.order_id LEFT JOIN customers ON orders.customer_id = customers.id\n//         SET total_amount = total_amount + (SELECT SUM(price) FROM order_items WHERE order_id = orders.id)\n//         WHERE orders.status = 'pending';\n```\n\n---\n"
        },
        {
          "originalPath": "4.Delete Example.md",
          "id": 9,
          "name": "Delete Example",
          "type": "file",
          "path": "examples/delete-example",
          "content": "### Delete Query Documentation Example for `db.delete()`\n\n---\n\n### 1. **Simple DELETE with WHERE Condition**\n\nDelete rows from the `employees` table where the `age` is greater than 60:\n\n```typescript\nconst result = await db.delete('employees', {\n    where: 'age > 60',\n    limit: 10\n}).build();\nconsole.log(result);\n// Output: DELETE FROM employees WHERE age > 60 LIMIT 10;\n```\n\n### 2. **DELETE with INNER JOIN**\n\nDelete rows from the `orders` table where the `status` is \"pending\" and join with the `customers` table based on the `customer_id`:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"pending\"',\n    joins: [\n        { type: 'INNER JOIN', table: 'customers', on: 'orders.customer_id = customers.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders INNER JOIN customers ON orders.customer_id = customers.id WHERE status = \"pending\";\n```\n\n### 3. **DELETE with LEFT JOIN**\n\nDelete rows from the `products` table where the `price` is lower than 100, while joining with the `categories` table using a `LEFT JOIN`:\n\n```typescript\nconst result = await db.delete('products', {\n    where: 'price < 100',\n    joins: [\n        { type: 'LEFT JOIN', table: 'categories', on: 'products.category_id = categories.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM products LEFT JOIN categories ON products.category_id = categories.id WHERE price < 100;\n```\n\n### 4. **DELETE with Sorting**\n\nDelete rows from the `orders` table where the `status` is \"shipped\" and sort the rows by `order_date` in descending order:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"shipped\"',\n    sort: { order_date: -1 }\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders WHERE status = \"shipped\" ORDER BY order_date DESC;\n```\n\n### 5. **DELETE with LIMIT**\n\nDelete only 5 rows from the `products` table where the `stock` is 0:\n\n```typescript\nconst result = await db.delete('products', {\n    where: 'stock = 0',\n    limit: 5\n}).build();\nconsole.log(result);\n// Output: DELETE FROM products WHERE stock = 0 LIMIT 5;\n```\n\n### 6. **DELETE with Multiple Joins**\n\nDelete rows from the `orders` table where the `status` is \"pending\", and join with both `customers` and `products` tables:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"pending\"',\n    joins: [\n        { type: 'INNER JOIN', table: 'customers', on: 'orders.customer_id = customers.id' },\n        { type: 'LEFT JOIN', table: 'products', on: 'orders.product_id = products.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders INNER JOIN customers ON orders.customer_id = customers.id LEFT JOIN products ON orders.product_id = products.id WHERE status = \"pending\";\n```\n\n### 7. **DELETE with WHERE, Sorting, and LIMIT**\n\nDelete rows from the `employees` table where the `position` is \"Intern\", sort by `hire_date` ascending, and limit to 10 rows:\n\n```typescript\nconst result = await db.delete('employees', {\n    where: 'position = \"Intern\"',\n    sort: { hire_date: 1 },\n    limit: 10\n}).build();\nconsole.log(result);\n// Output: DELETE FROM employees WHERE position = \"Intern\" ORDER BY hire_date ASC LIMIT 10;\n```\n\n### 8. **DELETE with WHERE and Complex Join**\n\nDelete rows from the `employees` table where the `salary` is greater than 50000, and join with `departments` and `projects` tables:\n\n```typescript\nconst result = await db.delete('employees', {\n    where: 'salary > 50000',\n    joins: [\n        { type: 'INNER JOIN', table: 'departments', on: 'employees.department_id = departments.id' },\n        { type: 'LEFT JOIN', table: 'projects', on: 'employees.project_id = projects.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM employees INNER JOIN departments ON employees.department_id = departments.id LEFT JOIN projects ON employees.project_id = projects.id WHERE salary > 50000;\n```\n\n### 9. **DELETE with RIGHT JOIN**\n\nDelete rows from the `orders` table where the `status` is \"cancelled\", and use a `RIGHT JOIN` with the `payments` table to identify orders with no payment:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"cancelled\"',\n    joins: [\n        { type: 'RIGHT JOIN', table: 'payments', on: 'orders.id = payments.order_id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders RIGHT JOIN payments ON orders.id = payments.order_id WHERE status = \"cancelled\";\n```\n\n### 10. **DELETE with Multiple Sorting Criteria**\n\nDelete rows from the `products` table where `stock` is less than 10, and sort by `price` in ascending order and `name` in descending order:\n\n```typescript\nconst result = await db.delete('products', {\n    where: 'stock < 10',\n    sort: { price: 1, name: -1 }\n}).build();\nconsole.log(result);\n// Output: DELETE FROM products WHERE stock < 10 ORDER BY price ASC, name DESC;\n```\n\n---\n\n### Notes\n\n- `where`: The condition for deleting rows (e.g., `age > 60` or `status = \"pending\"`).\n- `joins`: Array of JOIN operations for filtering data during deletion.\n- `limit`: The number of rows to delete.\n- `sort`: Sorting criteria to order the rows for deletion.\n- `table`: The name of the table from which rows will be deleted.\n"
        }
      ]
    },
    {
      "originalPath": "3.Getting Started",
      "name": "Getting Started",
      "path": "getting-started",
      "type": "folder",
      "children": [
        {
          "originalPath": "1.Installation.md",
          "id": 10,
          "name": "Installation",
          "type": "file",
          "path": "getting-started/installation",
          "content": "\n---\n\n### 1. **Installation**\n\nUse `npm` or `yarn` to install the `@dbnx/mysql` package:\n\n#### Pre-require\n\nInstall **mysql2**\n\n```bash\nnpm i mysql2\n```\n\n#### Install with npm\n\n```bash\nnpm install @dbnx/mysql\n```\n\n#### Install with yarn\n\n```bash\nyarn add @dbnx/mysql\n```\n\n---\n\n### 2. **Setup and Configuration**\n\n#### Import and Initialize\n\nAfter installation, you can import the package and initialize a database connection.\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Database connection configuration\nconst dbConfig = {\n    host: \"localhost\",\n    user: \"your-username\",\n    password: \"your-password\",\n    database: \"your-database-name\"\n};\n\n// Create a DB instance\nconst dbInstance = new DBnx(dbConfig);\n\n// Test connection\n(async () => {\n    try {\n        await dbInstance.connect();\n        console.log(\"Database connected successfully!\");\n    } catch (error) {\n        console.error(\"Failed to connect to the database:\", error);\n    }\n})();\n```\n\n---\n\n### 3. **Usage Examples**\n\n#### Execute Raw SQL Query\n\n```typescript\n(async () => {\n    const result = await dbInstance.execute(\"SELECT * FROM users WHERE age > ?\", [25]);\n    console.log(\"Query Result:\", result);\n})();\n```\n\n#### Use Prepared Statements\n\n```typescript\n(async () => {\n    const userId = 1;\n    const user = await dbInstance.execute(\"SELECT * FROM users WHERE id = ?\", [userId]);\n    console.log(\"User Data:\", user);\n})();\n```\n\n#### Insert Data\n\n```typescript\n(async () => {\n    const result = await dbInstance.execute(\n        \"INSERT INTO users (name, email, age) VALUES (?, ?, ?)\",\n        [\"John Doe\", \"john.doe@example.com\", 30]\n    );\n    console.log(\"Insert Result:\", result);\n})();\n```\n\n#### Update Data\n\n```typescript\n(async () => {\n    const result = await dbInstance.execute(\n        \"UPDATE users SET age = ? WHERE id = ?\",\n        [31, 1]\n    );\n    console.log(\"Update Result:\", result);\n})();\n```\n\n#### Delete Data\n\n```typescript\n(async () => {\n    const result = await dbInstance.execute(\n        \"DELETE FROM users WHERE id = ?\",\n        [1]\n    );\n    console.log(\"Delete Result:\", result);\n})();\n```\n\n---\n\n### 4. **Closing the Connection**\n\nAlways close the connection when done:\n\n```typescript\n(async () => {\n    try {\n        await dbInstance.close();\n        console.log(\"Database connection closed.\");\n    } catch (error) {\n        console.error(\"Error closing the database connection:\", error);\n    }\n})();\n```\n\n---\n\n### 5. **Additional Notes**\n\n- **Error Handling:** Use `try-catch` blocks for robust error handling.\n- **Pooling:** `@dbnx/mysql` supports connection pooling. Configure pooling in the `DBnx` instance for better performance with high traffic.\n  \n  ```typescript\n  const dbConfig = {\n      host: \"localhost\",\n      user: \"your-username\",\n      password: \"your-password\",\n      database: \"your-database-name\",\n      connectionLimit: 10 // Enable connection pooling\n  };\n  ```\n"
        },
        {
          "originalPath": "2.Configuration.md",
          "id": 11,
          "name": "Configuration",
          "type": "file",
          "path": "getting-started/configuration",
          "content": "\n---\n\n### **1. Initializing DBnx:**\n\nTo use DBnx for MySQL, you need to initialize the database connection using the `DBnx` class. The connection accepts configuration options and an optional boolean to enable or disable connection pooling.\n\n#### **Initialization Example:**\n\n```typescript\nimport { DBnx } from \"@dbnx/mysql\";\n\n// Database connection configuration\nexport const db = new DBnx(\n    {\n        host: 'localhost',               // MySQL server hostname (default: 'localhost')\n        user: 'root',                    // Database username (default: 'root')\n        password: '11224455',            // Database password\n        database: 'world',               // The database name you want to connect to\n        waitForConnections: true,        // Whether to wait for connections (default: true)\n        multipleStatements: true,       // Enable multiple SQL statements per query (default: true)\n        connectionLimit: 10,             // Connection pool size (default: 10)\n        queueLimit: 0,                   // Maximum number of queued connection requests (default: 0)\n    },\n    true  // Connection pooling: `true` to enable, `false` to disable (default: true)\n);\ndb.connect((err, success) => {\n    console.log(err)\n})\n```\n\n### **Configuration Options:**\n\n- `host`: **string** â€“ The MySQL server hostname (default: `'localhost'`).\n- `user`: **string** â€“ The MySQL username (default: `'root'`).\n- `password`: **string** â€“ The password for the MySQL user.\n- `database`: **string** â€“ The name of the database to use.\n- `waitForConnections`: **boolean** â€“ Whether to wait for a connection when the pool is full (default: `true`).\n- `multipleStatements`: **boolean** â€“ Whether to allow multiple SQL statements in a query (default: `true`).\n- `connectionLimit`: **number** â€“ The maximum number of connections in the pool (default: `10`).\n- `queueLimit`: **number** â€“ The maximum number of queued connection requests (default: `0` â€“ no limit).\n\n#### **Connection Pooling:**\n\nWhen initializing `DBnx`, you can enable connection pooling by passing `true` as the second argument in the constructor. Connection pooling allows efficient handling of multiple concurrent database connections by reusing connections instead of creating new ones every time.\n\n- `true` â€“ Use connection pooling (default behavior).\n- `false` â€“ Disable connection pooling.\n\n---\n\n### **Connecting with a MySQL URL:**\n\nA MySQL connection URL typically follows this format:\n\n```bash\nmysql://user:password@host:port/database\n```\n\nWhere:\n\n- `user`: The username for MySQL\n- `password`: The password for MySQL\n- `host`: The MySQL server hostname or IP address\n- `port`: The MySQL port (default is `3306`)\n- `database`: The name of the database to connect to\n\n### **Example with DBnx:**\n\n```typescript\nimport { DBnx } from \"@dbnx/mysql\";\n// MySQL connection URL\nconst connectionUrl = 'mysql://root:11224455@localhost:3306/world';\n// Initialize DBnx with the URL and optional connection pooling setting\nexport const db = new DBnx(connectionUrl, true); // true for pooling enabled\ndb.connect((err, success) => {\n    console.log(err)\n})\n```\n\n### **Explanation:**\n\n1. **`connectionUrl`:**  \n   The URL string `'mysql://root:11224455@localhost:3306/world'` connects to a MySQL database:\n   - `root`: Username\n   - `11224455`: Password\n   - `localhost`: Hostname of the MySQL server\n   - `3306`: Port (default MySQL port)\n   - `world`: Database name\n\n2. **Initializing DBnx with Connection URL:**\n   You pass the URL directly to the `DBnx` constructor. The second argument `true` is used to enable connection pooling. If you do not need pooling, you can pass `false` or omit it entirely.\n\n3. **Making Queries:**  \n   After initializing the connection, you can use `db.execute()` to run SQL queries. In the example, we are fetching all rows from the `users` table.\n\n---\n\n### **2. Defining Models:**\n\nDBnx provides a way to define models for database tables using the `Model` class. The models are used to define the structure of your tables, including fields, data types, and relationships.\n\n#### **Model Definition Example:**\n\n```typescript\nimport { Model } from \"@dbnx/mysql\";\nimport { db } from \"./server\";  // Import the initialized DB handler\n\n// Defining a 'User' model\nconst User = db.define('User', {\n    username: {\n        type: \"VARCHAR(50)\",          // The type of the field\n        allowNull: false,            // Field cannot be NULL\n        defaultValue: null,          // Default value if no value is provided\n        unique: true,                // Ensures this field is unique\n    },\n    created_at: {\n        type: \"TIMESTAMP\",           // The type of the field\n        defaultValue: \"CURRENT_TIMESTAMP\", // Default value of the field\n    },\n},{\n    //table options\n});\n\n// Defining a 'Product' model\nconst Product = Model.init('Product', {\n    product_id: {\n        type: \"BIGINT\",              // Data type for product_id\n        autoIncrement: true,        // Auto-increment the product ID\n        primaryKey: true,           // Marks this field as the primary key\n        unique: true,               // Ensures uniqueness of product_id\n    },\n\n    title: {\n        type: \"VARCHAR(255)\",        // Title of the product\n        defaultValue: null,          // Default value for title\n    },\n\n    created_at: {\n        type: \"TIMESTAMP\",           // Timestamp when the product is created\n        defaultValue: \"CURRENT_TIMESTAMP\", // Default value of the field\n    },\n\n    updated_at: {\n        type: 'TIMESTAMP',           // Timestamp when the product was last updated\n        allowNull: false,            // This field cannot be null\n        defaultValue: 'CURRENT_TIMESTAMP', // Default value\n        onUpdate: 'CURRENT_TIMESTAMP' // Automatically update the field on record change\n    }\n}, db,{\n    //options\n});\n```\n\n#### options\n\n```typescript\nexport type TableOptions = {\n    engine?: Engine;\n    charset?: Charset;\n    collation?: Collation;\n    auto_increment?: number; // default 1 , if you pass number value then start from input number.\n};\n```\n\n### **Model Methods:**\n\n1. **`db.define()`** â€“ Defines a new model/table within the database. The first argument is the name of the table, and the second argument is an object with field definitions.\n2. **`Model.init()`** â€“ Initializes an existing model with a given structure and attaches it to the `dbHandler`.\n\n### **Field Properties:**\n\nEach field in a model can have the following properties:\n\n- `type`: **string** â€“ The SQL data type (e.g., `VARCHAR`, `TIMESTAMP`, `BIGINT`).\n- `defaultValue`: **any** â€“ The default value for the field.\n- `allowNull`: **boolean** â€“ Whether the field allows `NULL` values (default is `true`).\n- `unique`: **boolean** â€“ Ensures that the field contains unique values.\n- `primaryKey`: **boolean** â€“ Marks the field as the primary key for the table.\n- `autoIncrement`: **boolean** â€“ Auto-increments the field's value, commonly used for primary keys.\n- `references`: **string** â€“ Specifies a foreign key reference to another table.\n- `onUpdate`: **string** â€“ Specifies how the field should update (commonly used with `TIMESTAMP`).\n\n---\n\n### **3. Query Execution with DBnx:**\n\nYou can use the `query` method to execute raw SQL queries against the connected database.\n\n```typescript\nconst fetchData = async () => {\n    try {\n        const result = await db.execute('SELECT * FROM users');\n        console.log(result);  // Logs the result of the query\n    } catch (error) {\n        console.error('Error fetching data:', error);\n    }\n};\n\nfetchData();\n```\n\n- The `execute` method accepts an SQL string and returns the result of the query.\n\n---\n\n### **4. Summary of Key Features:**\n\n- **Connection Pooling**: Automatically managed and easily configurable for efficient connection management.\n- **Model Definition**: Use `define()` or `init()` to define database models with strong type checking.\n- **Customizable Field Definitions**: Set field types, constraints, default values, and relationships.\n- **Advanced Query Support**: Execute raw SQL queries directly using `execute()` for more control.\n\n---\n"
        },
        {
          "originalPath": "3.Logger Function.md",
          "id": 12,
          "name": "Logger Function",
          "type": "file",
          "path": "getting-started/logger-function",
          "content": "\n---\n\n#### **Constructor**\n\nThe constructor initializes the database connection with flexible options to suit various configurations. It supports the following signatures:\n\n```typescript\nconstructor(dbConfig: ConnectionOptions | PoolOptions | string, usePool?: boolean, logger?: (log: any) => void)\nconstructor(dbConfig: ConnectionOptions | PoolOptions | string, logger?: (log: any) => void)\nconstructor(dbConfig: ConnectionOptions | PoolOptions | string)\n```\n\n- **Parameters**:\n  1. **`dbConfig`** (`ConnectionOptions | PoolOptions | string`)  \n     - Configuration options for the database. Can be:\n       - An object containing MySQL connection or pool options.\n       - A connection URL string (e.g., `\"mysql://user:pass@host/db\"`).\n  2. **`usePool`** (`boolean`, optional)  \n     - Indicates whether to use a connection pool. Defaults to `false` if not provided.\n  3. **`logger`** (`(log: any) => void`, optional)  \n     - A callback function for logging. Useful for debugging connection events and queries.\n\n---\n\n#### **Example Usage**\n\n```typescript\nimport { DBnx } from \"@dbnx/mysql\";\n\n// Instantiate the DBnx class\nexport const db = new DBnx(\n    {\n        host: 'localhost',       // Host address\n        user: 'root',            // MySQL username\n        password: '12345678',    // Password for the user\n        database: 'world',       // Name of the database\n        waitForConnections: true, // Connection pool options\n        multipleStatements: true, // Enable multi-statement execution\n        connectionLimit: 10,     // Max number of simultaneous connections\n        queueLimit: 0,           // No limit on queued requests\n    },\n    true, // Enable connection pooling\n    (log) => console.log(log) // Logging callback\n);\n\n// Establish a connection\ndb.connect();\n```\n\n---\n\n#### **Constructor Internals**\n\nThe constructor supports dynamic argument parsing to handle the different initialization patterns:\n\n1. **`this.#logger`**:  \n   - Set to the second argument if itâ€™s a function.  \n   - Otherwise, the third argument is used.\n\n2. **`this.#usePool`**:  \n   - Set to the second argument if itâ€™s a boolean.  \n   - Defaults to `false` if not provided.\n\n3. **`this.#dbConfig`**:  \n   - Always assigned to the first argument, regardless of type.\n\n---\n\n#### **Key Features**\n\n1. **Flexible Configuration**:\n   - Accepts connection options or a MySQL connection URL string.\n\n2. **Connection Pooling**:\n   - Optional support for pooling via the `usePool` parameter.\n\n3. **Custom Logging**:\n   - Easily integrates with logging systems through the `logger` callback.\n\n4. **Dynamic Initialization**:\n   - Allows initialization with or without pooling and logging based on the provided arguments.\n\n---\n\n#### **Advanced Configurations**\n\n- **Connection URL**:\n\n  ```typescript\n  const db = new DBnx(\n      \"mysql://root:12345678@localhost/world\",\n      true, // Enable pooling\n      (log) => console.log(log)\n  );\n  ```\n\n- **Single Connection without Logging**:\n\n  ```typescript\n  const db = new DBnx({\n      host: 'localhost',\n      user: 'root',\n      password: '12345678',\n      database: 'world',\n  });\n  ```\n\n- **Single Connection with Logging**:\n\n  ```typescript\n  const db = new DBnx(\n      {\n          host: 'localhost',\n          user: 'root',\n          password: '12345678',\n          database: 'world',\n      },\n      (log) => console.log(\"Log:\", log)\n  );\n  ```\n\n---\n\n#### **Method: `connect`**\n\nEstablishes a connection to the database. Internally determines whether to initialize a single connection or a connection pool.\n\n- **Usage**:\n\n  ```typescript\n  await db.connect();\n  ```\n\n- **Behavior**:\n  - If `usePool` is `true`, initializes a connection pool.\n  - Otherwise, establishes a single connection.\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "4. Condition.md",
      "id": 13,
      "name": "Condition",
      "type": "file",
      "path": "condition",
      "content": "\n---\n\n## Importing the Function\n\n```typescript\nimport { dbnxCondition } from '@dbnx/mysql';\n\n```\n\n##### **OR**\n\n```ts\n// database.js\nimport { DBnx } from \"@dbnx/mysql\";\n\n// Creating a new instance of DBnx to handle database connections.\nexport const db = new DBnx(\n    {\n        host: 'localhost', // Database host\n        user: 'root', // Database user\n        password: '11224455', // Database password\n        database: 'world', // Database name\n        waitForConnections: true, // Allows the pool to wait for connections\n        multipleStatements: true, // Allows multiple SQL statements per query\n        connectionLimit: 10, // Maximum number of connections in the pool\n        queueLimit: 0, // Unlimited connection queue size\n    },\n    // true // Use connection pooling\n);\n\n// Connecting to the database\ndb.connect()\n    .then(() => console.log('Database connected successfully'))\n    .catch((err) => console.error('Error connecting to database:', err));\n\ndb.condition() // condition\n```\n\n### Use\n\n```ts\nconst result = await db.findOne('users', {\n    where: db.condition({name:'dbnx'})\n}).execute();\nconsole.log(result);\n```\n\n---\n\n## Function Signature\n\n```typescript\ndbnxCondition(\n  filters: FilterObject, \n  joinBy: 'AND' | 'OR' = 'AND'\n): string\n```\n\n- **`filters`**: An object specifying the conditions for query generation.\n- **`joinBy`**: Logical operator (`AND` or `OR`) used to combine top-level conditions. Defaults to `AND`.\n\n---\n\nHere is the documentation for the `dbnxCondition` function and the `Filters` type, including a detailed example:\n\n---\n\n## `Filters` Type Documentation\n\n### Type: `FilterValue`\n\nThe `FilterValue` type represents the possible values that can be used in the filters to build SQL conditions. These include:\n\n- **string | number**: Used for simple equality checks (e.g., `status = 'active'`).\n- **Array<string | number>**: Used for `IN` checks (e.g., `tags IN ('electronics', 'home')`).\n- **{ notIn: Array<string | number> }**: Used for `NOT IN` checks (e.g., `location NOT IN ('New York', 'California')`).\n- **{ in: Array<string | number> }**: Used for `IN` checks.\n- **{ between: [number, number] }**: Used for `BETWEEN` checks (e.g., `price BETWEEN 1000 AND 5000`).\n- **{ notBetween: [number, number] }**: Used for `NOT BETWEEN` checks.\n- **{ inRange: [number, number] }**: Similar to `BETWEEN` but for range checks.\n- **{ $or: FilterValue[] }**: Logical OR condition (e.g., `(color LIKE 'red' OR color LIKE 'blue')`).\n- **{ like: string }**: Used for `LIKE` operator (e.g., `title LIKE '%phone%'`).\n- **{ notLike: string }**: Used for `NOT LIKE` operator (e.g., `description NOT LIKE '%old%'`).\n- **{ isNull: boolean }**: Used for checking if a value is NULL or NOT NULL (e.g., `updatedAt IS NULL`).\n- **{ $and: FilterValue[] }**: Logical AND condition (e.g., `(category = 'electronics' AND brand = 'Samsung')`).\n- **{ regexp: string }**: Used for `REGEXP` condition (e.g., `brand REGEXP '^Samsung'`).\n- **eq**: Represents equality (e.g., `status = 'active'`).\n- **gt**: Greater than check (e.g., `price > 1000`).\n- **lt**: Less than check (e.g., `price < 5000`).\n- **gte**: Greater than or equal to check (e.g., `price >= 1000`).\n- **lte**: Less than or equal to check (e.g., `price <= 5000`).\n- **neq**: Not equal to check (e.g., `status != 'inactive'`).\n\n### Type: `Filters`\n\nThe `Filters` type represents a set of filters used to build complex SQL conditions. It can either be a set of key-value pairs representing direct column filters, or it can contain logical operators like `$and` or `$or` for combining multiple filters.\n\nExample:\n\n```typescript\ntype Filters = {\n    [key: string]: FilterValue; // For columns directly mapped to FilterValue\n} | {\n    $or?: Record<string, FilterValue>; // Logical OR condition for multiple filters\n    $and?: Record<string, FilterValue>; // Logical AND condition for multiple filters\n};\n```\n\n## `dbnxCondition` Function\n\n### Function: `dbnxCondition`\n\nGenerates SQL conditions based on the filters object. It dynamically builds the `WHERE` clause for SQL based on the provided filters and logical operations (e.g., AND, OR).\n\n#### Parameters\n\n- **filters (Filters)**: An object containing the conditions to apply in the SQL query.\n- **joinBy ('AND' | 'OR')**: A logical operator used to combine the conditions. Defaults to 'AND'.\n\n#### Returns\n\nA string representing the SQL condition that can be used in the `WHERE` clause of a query.\n\n### Example Usage\n\n```typescript\nimport { dbnxCondition, Filters } from '@dbnx/mysql';\n\n// Example filters\nconst filters: Filters = {\n    status: \"active\", // Exact match\n    price: { between: [1000, 5000] }, // BETWEEN condition\n    tags: [\"electronics\", \"home\"], // IN condition\n    location: { notIn: [\"New York\", \"California\"] }, // NOT IN condition\n    stock: { inRange: [10, 50] }, // IN RANGE condition (BETWEEN)\n    updatedAt: { isNull: true }, // IS NULL condition\n    title: { like: \"%phone%\" }, // LIKE condition (pattern matching)\n    description: { notLike: \"%old%\" }, // NOT LIKE condition\n    color: {\n        $or: [\n            { like: \"red\" },\n            { like: \"blue\" },\n        ],\n    }, // OR condition\n    $and: {\n        category: \"electronics\",\n        brand: { regexp: \"^Samsung\" }, // REGEXP condition\n    },\n};\n\n// Generate the SQL condition string\nconst sqlCondition = dbnxCondition(filters);\n\nconsole.log(sqlCondition);\n```\n\n### Output\n\n```sql\nSELECT * FROM products WHERE \n`status` = 'active' AND \n`price` BETWEEN 1000 AND 5000 AND \n`tags` IN ('electronics', 'home') AND \n`location` NOT IN ('New York', 'California') AND \n`stock` BETWEEN 10 AND 50 AND \n`updatedAt` IS NULL AND \n`title` LIKE '%phone%' AND \n`description` NOT LIKE '%old%' AND \n(\n    `color` LIKE 'red' OR \n    `color` LIKE 'blue'\n) AND \n(\n    `category` = 'electronics' AND \n    `brand` REGEXP '^Samsung'\n);\n```\n\n### Function Details\n\n1. **IN and NOT IN**: The `IN` condition checks if the value is present in a list (e.g., `tags IN ('electronics', 'home')`), and the `NOT IN` condition checks if the value is not in a list (e.g., `location NOT IN ('New York', 'California')`).\n\n2. **BETWEEN and NOT BETWEEN**: These conditions are used for range checks (e.g., `price BETWEEN 1000 AND 5000`). The `NOT BETWEEN` condition checks for values outside a specified range.\n\n3. **LIKE and NOT LIKE**: Used for pattern matching (e.g., `title LIKE '%phone%'`). The `NOT LIKE` condition checks for values that do not match the pattern.\n\n4. **Logical AND and OR**: The function supports complex logical operations. The `$and` and `$or` operators are used to group conditions into logical expressions. For example, conditions can be grouped with `AND` (e.g., `category = 'electronics' AND brand = 'Samsung'`) or `OR` (e.g., `color LIKE 'red' OR color LIKE 'blue'`).\n\n5. **REGEXP**: The `REGEXP` condition is used for regular expression matching (e.g., `brand REGEXP '^Samsung'`).\n\n### Notes\n\n- The function sanitizes all inputs to avoid SQL injection risks, ensuring that values are properly escaped.\n- You can use multiple logical operators (`$and`, `$or`) to create more complex filtering conditions.\n\n---\n"
    },
    {
      "originalPath": "5.Model",
      "name": "Model",
      "path": "model",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Create Model.md",
          "id": 14,
          "name": "Create Model",
          "type": "file",
          "path": "model/create-model",
          "content": "### Dynamic Model Definition\n\n---\n\n### **1. Dependencies**\n\nThis implementation relies on the following imports:\n\n- **`DBnx`**: Database handler to execute SQL commands.\n- **`Model`**: Base class for models.\n- **`DataTypes`**: Utilities for defining column types.\n\n```ts\nimport { DBnx } from \"@dbnx/mysql\";\n\nexport const db = new DBnx(\n    {\n        host: 'localhost',\n        user: 'root',\n        password: '11224455',\n        database: 'world',\n        waitForConnections: true,\n        multipleStatements: true,\n        connectionLimit: 10,\n        queueLimit: 0,\n    },\n    // true // Use pool\n);\n\ndb.connect()\n```\n\n---\n\n### **2. Model Definition Example**\n\n#### **Product Model**\n\n```typescript\nimport { Model } from \"@dbnx/mysql\";\n\nconst Product = Model.init('product', {\n    product_id: {\n        type: \"BIGINT\",\n        autoIncrement: true,\n        primaryKey: true,\n        unique: true\n    },\n    title: {\n        type: \"VARCHAR(255)\",\n        defaultValue: null,\n    },\n    brand: {\n        type: \"VARCHAR(255)\",\n        defaultValue: 'hello',\n    },\n    created_at: {\n        type: \"TIMESTAMP\",\n        defaultValue: \"CURRENT_TIMESTAMP\",\n    },\n    updated_at: {\n        type: 'TIMESTAMP',\n        allowNull: false,\n        defaultValue: 'CURRENT_TIMESTAMP',\n        onUpdate: 'CURRENT_TIMESTAMP'\n    }\n}, db);\n```\n\n#### **Users Model**\n\n```typescript\n\nconst Users = db.define('users', {\n    username: {\n        type: DataTypes.SMALLINT(),\n        defaultValue: null,\n        unique: true,\n    },\n    city: {\n        type: DataTypes.INT(),\n        allowNull: true,\n        references: {\n            model: 'city',\n            key: 'ID',\n            onDelete: 'SET NULL',\n            onUpdate: 'CASCADE', // Update child table when parent table value changes\n        },\n    },\n    status: {\n        type: DataTypes.ENUM(),\n        values: ['active', 'inactive']\n    },\n    created_at: {\n        type: DataTypes.TIMESTAMP(),\n        onUpdate: \"CURRENT_TIMESTAMP\",\n    },\n}, {\n    auto_increment: 100,\n    charset: 'utf8mb4',\n    collation:\"utf8mb4_unicode_ci\"\n});\n```\n\n**Table Options:**\n\n```ts\ntype TableOptions = {\n    engine?: Engine;\n    charset?: Charset;\n    collation?: Collation;\n    auto_increment?: number;\n};\n```\n\n#### **Return Properties**\n\n- `ddlQuery`: SQL statement for creating the table.\n- `database`: SQL statement for creating the table.\n- `modelAttributes`: Object defining column configurations.\n- `tableOptions`: Options for the table (engine, charset, etc.).\n- `dbInstance`: Database instance to execute queries.\n- `tableName`: Name of the table in the database.\n- `dbTableIdentifier`: Name of the table identifier.\n\n---\n\n#### **Column Options**\n\n| Property         | Type                                      | Description                                                                 |\n|------------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `type`           | `string`                                  | Data type of the column (e.g., `VARCHAR`, `INT`, `TIMESTAMP`).              |\n| `modifyColumn`   | `string`                                  | To change the name of a column.                                            |\n| `onUpdate`       | `string / 'CURRENT_TIMESTAMP'`                       | For date value updated.                                            |\n| `allowNull`      | `boolean`                                 | Specifies if the column allows `NULL`.                                      |\n| `primaryKey`     | `boolean`                                 | Marks the column as the primary key.                                        |\n| `autoIncrement`  | `boolean`                                 | Enables auto-incrementing values.                                           |\n| `defaultValue`   | `string / number / \"CURRENT_TIMESTAMP\"`   | Default value for the column.                                               |\n| `references`     | `object / string`                         | Foreign key configuration (table name, key, `onDelete`, `onUpdate`).        |\n| `unique`         | `boolean`                                 | Ensures unique values in the column.                                        |\n| `values`         | `string[]`                                | Applicable for ENUM types, defines allowed values.                          |\n\n```ts\nexport type ColumnOptions = {\n    modifyColumn?: string,\n    type: string;\n    allowNull?: boolean;\n    primaryKey?: boolean;\n    autoIncrement?: boolean;\n    onUpdate?:string | \"CURRENT_TIMESTAMP\";\n    defaultValue?: string | number | \"CURRENT_TIMESTAMP\" | null;\n    references?: string | {\n        model: string | typeof Model,\n        onUpdate?: \"CASCADE\" | \"SET NULL\" | \"NO ACTION\" | \"RESTRICT\";\n        onDelete?: \"CASCADE\" | \"SET NULL\" | \"NO ACTION\" | \"RESTRICT\";\n        key: string; // Referenced column\n    };\n    unique?: boolean,\n    values?: readonly string[],\n}\n```\n\n---\n\n### **Usage Examples**\n\n#### Change column name\n\n```ts\nconst Product = Model.init('product', {\n    ...\n    ...\n    brand_name: {\n        modifyColumn: 'brand',\n        type: \"VARCHAR(255)\",\n        defaultValue: 'hello',\n    },\n    ...\n    ...\n}, db);\n```\n\nRename **`brand`** column to **`brand_name`** if exist.\n\n#### Creating a Table\n\n```typescript\nconsole.log(Product.ddlQuery); // Outputs the CREATE TABLE SQL query\nconsole.log(Product.sync()); // Outputs the CREATE TABLE SQL query\n```\n\n#### Adding Foreign Key Constraints\n\n```typescript\nconst Orders = db.define('orders', {\n    product_id: {\n        type: \"BIGINT\",\n        allowNull: false,\n        references: {\n            model: Product,\n            key: 'product_id',\n            onDelete: 'CASCADE',\n            onUpdate: 'CASCADE',\n        },\n    },\n});\n```\n\n**or**:\n\n```typescript\nconst Orders = db.define('orders', {\n    product_id: {\n        type: \"BIGINT\",\n        allowNull: false,\n        references: {\n            model: 'product',\n            key: 'product_id',\n            onDelete: 'CASCADE',\n            onUpdate: 'CASCADE',\n        },\n    },\n});\n```\n\nHere are examples demonstrating how to use the `Model` class for **creating**, **deleting**, **updating**, and **finding** records.\n\n---\n\n### 1. **Create**\n\nTo create a new record in the database:\n\n#### Example\n\n```typescript\n\n(async () => {\n    const result = await Users.create({\n        name: \"John Doe\",\n        email: \"john.doe@example.com\",\n        age: 30\n    });\n    console.log(\"Record created:\", result);\n})();\n```\n\n---\n\n### 2. **Find All**\n\nTo retrieve multiple records from the database:\n\n#### Example\n\n```typescript\n\n(async () => {\n    const records = await Users.findAll({\n        limitSkip: { limit: 10, skip: 0 } \n    });\n    console.log(\"Found records:\", records);\n})();\n```\n\n---\n\n### 3. **Find One**\n\nTo retrieve a single record:\n\n#### Example\n\n```typescript\n\n(async () => {\n    const record = await Users.findOne();\n    console.log(\"Single record found:\", record);\n})();\n```\n\n---\n\n### 4. **Update**\n\nTo update an existing record in the database:\n\n#### Example\n\n```typescript\nimport { Model } from './model';\n\n(async () => {\n    const result = await Model.update({\n        where: `email = \"john.doe@example.com\"`, // Condition to identify the record\n        values: { age: 31 } // Fields to update\n    });\n    console.log(\"Record updated:\", result);\n})();\n```\n\n---\n\n### 5. **Delete**\n\nTo delete a record from the database:\n\n#### Example\n\n```typescript\nimport { Model } from './model';\n\n(async () => {\n    const result = await Model.delete({\n        where: `email = \"john.doe@example.com\"` // Condition to identify the record to delete\n    });\n    console.log(\"Record deleted:\", result);\n})();\n```\n\n---\n\n#### Retrieving Engine Options\n\n```typescript\nconsole.log(ModelDefine.getEngineOptions());\n// Outputs table options like ENGINE, CHARSET, and COLLATION\n```\n\n---\n"
        },
        {
          "originalPath": "2. DataTypes.md",
          "id": 15,
          "name": "DataTypes",
          "type": "file",
          "path": "model/datatypes",
          "content": "\n---\n\n### **Defining Models**\n\nUse the `db.define()` method to define a model. Specify the table structure, data types, and constraints in an intuitive manner.\n\n```javascript\nconst { DBnx, DataTypes } = require('@dbnx/mysql');\nexport const db = new DBnx(\n    {\n        host: 'localhost',\n        user: 'root',\n        password: '11224455',\n        database: 'world',\n        waitForConnections: true,\n        multipleStatements: true,\n        connectionLimit: 10,\n        queueLimit: 0,\n    },\n    // true // Use pool\n);\n\ndb.connect()\n\nconst Users = db.define('users', {\n    username: {\n        type: DataTypes.STRING(150),\n        unique: true,\n        allowNull: false,\n        defaultValue: null,\n    },\n    city: {\n        type: DataTypes.INT(),\n        allowNull: true,\n        references: {\n            model: 'city',\n            key: 'ID',\n            onDelete: 'SET NULL',\n            onUpdate: 'CASCADE',\n        },\n    },\n    status: {\n        type: DataTypes.ENUM('active', 'inactive'),\n        defaultValue: 'inactive',\n    },\n    created_at: {\n        type: DataTypes.TIMESTAMP(),\n        onUpdate: 'CURRENT_TIMESTAMP',\n    },\n});\n```\n\n---\n\n### **DataTypes**\n\nThe `DataTypes` object provides a set of predefined methods for defining column types. Each method generates the appropriate SQL type.\n\n#### **String Types**\n\n- **`STRING(size = 250)`**: Variable-length string (`VARCHAR`).  \n  Example: `DataTypes.STRING(100)` -> `VARCHAR(100)`\n  \n- **`CHAR(size = 35)`**: Fixed-length string (`CHAR`).  \n  Example: `DataTypes.CHAR(10)` -> `CHAR(10)`\n\n- **`TEXT(type = 'TEXT')`**: Large text field.  \n  Options: `TINYTEXT`, `TEXT`, `MEDIUMTEXT`, `LONGTEXT`.  \n  Example: `DataTypes.TEXT('MEDIUMTEXT')`\n\n#### **Numeric Types**\n\n- **`TINYINT(unsigned = false)`**: Tiny integer.  \n  Example: `DataTypes.TINYINT(true)` -> `TINYINT UNSIGNED`\n  \n- **`SMALLINT(unsigned = false)`**: Small integer.  \n  Example: `DataTypes.SMALLINT()` -> `SMALLINT`\n  \n- **`INT(unsigned = false)`**: Standard integer.  \n  Example: `DataTypes.INT(true)` -> `INT UNSIGNED`\n  \n- **`BIGINT(unsigned = false)`**: Large integer.  \n  Example: `DataTypes.BIGINT()` -> `BIGINT`\n\n- **`DECIMAL(precision = 10, scale = 0)`**: Fixed-point decimal.  \n  Example: `DataTypes.DECIMAL(12, 4)` -> `DECIMAL(12, 4)`\n\nData types in `@dbnx/mysql` mirror MySQL column types, making schema design intuitive. Below are the supported types and options:\n\n| **Type**        | **Description**                                                                                           | **Example**                        |\n|------------------|-----------------------------------------------------------------------------------------------------------|------------------------------------|\n| `STRING(size)`   | Variable-length string (`VARCHAR`). Default size: 250.                                                   | `DataTypes.STRING(150)`           |\n| `CHAR(size)`     | Fixed-length string. Default size: 35.                                                                   | `DataTypes.CHAR(20)`              |\n| `TEXT(type)`     | Large text field. `type`: `TINYTEXT`, `TEXT`, `MEDIUMTEXT`, `LONGTEXT`.                                   | `DataTypes.TEXT('LONGTEXT')`      |\n| `INT(unsigned)`  | Integer. Add `true` for unsigned.                                                                        | `DataTypes.INT(true)`             |\n| `DECIMAL(p, s)`  | Fixed-point decimal with precision `p` and scale `s`. Default: `(10, 0)`.                                | `DataTypes.DECIMAL(12, 4)`        |\n| `TIMESTAMP()`    | Timestamp with optional auto-update.                                                                     | `DataTypes.TIMESTAMP()`           |\n| `ENUM(values)`   | Enum with specific values.                                                                               | `DataTypes.ENUM('active', 'inactive')` |\n| `BLOB(type)`     | Binary large object. `type`: `TINYBLOB`, `BLOB`, `MEDIUMBLOB`, `LONGBLOB`.                                | `DataTypes.BLOB('LONGBLOB')`      |\n| `JSON()`         | JSON-formatted data field.                                                                               | `DataTypes.JSON()`                |\n\n---\n\n#### **Date & Time Types**\n\n- **`TIMESTAMP()`**: Timestamp with optional auto-update.  \n  Example: `DataTypes.TIMESTAMP()` -> `TIMESTAMP`\n\n- **`DATE()`**: Stores dates without time.  \n  Example: `DataTypes.DATE()` -> `DATE`\n\n#### **Enumerations**\n\n- **`ENUM()`**: Enum type with specific values.  \n  Example: `DataTypes.ENUM()` -> `ENUM`\n\n#### **Binary Types**\n\n- **`BINARY(size = 16)`**: Fixed-length binary data.  \n  Example: `DataTypes.BINARY(32)` -> `BINARY(32)`\n\n- **`VARBINARY(size = 255)`**: Variable-length binary data.  \n  Example: `DataTypes.VARBINARY(100)` -> `VARBINARY(100)`\n\n- **`BLOB(type = 'BLOB')`**: Binary large object.  \n  Options: `TINYBLOB`, `BLOB`, `MEDIUMBLOB`, `LONGBLOB`.  \n  Example: `DataTypes.BLOB('LONGBLOB')`\n\n#### **JSON**\n\n- **`JSON()`**: Stores JSON-formatted data.  \n  Example: `DataTypes.JSON()` -> `JSON`\n\n---\n\n### **Advanced Features**\n\n#### **Relationships**\n\nDefine relationships using the `references` field for foreign keys:\n\n```javascript\ncity: {\n    type: DataTypes.INT(),\n    references: {\n        model: 'city',\n        key: 'ID',\n        onDelete: 'SET NULL',\n        onUpdate: 'CASCADE',\n    },\n}\n```\n\n#### **Default Values**\n\nSet default values directly in the model:\n\n```javascript\nstatus: {\n    type: DataTypes.ENUM(),\n    values: ['active', 'inactive'],\n    defaultValue: 'inactive',\n}\n```\n\n---\n\n### **Example: CRUD Operations**\n\nHereâ€™s an example workflow:\n\n#### Create a User\n\n```javascript\nawait Users.create({\n    username: 'john_doe',\n    city: 1,\n    status: 'active',\n});\n```\n\n#### Find Users\n\n```javascript\nconst allUsers = await Users.findAll();\n```\n\n#### Update a User\n\n```javascript\nUsers.update({\n    values:{ \n        status: 'inactive' \n    },\n    where: \"username = 'john_doe'\"\n})\n```\n\n#### Delete a User\n\n```javascript\nawait Users.delete({\n     where: `username = 'john_doe'`  \n     });\n```\n\n---\n\n---\n"
        },
        {
          "originalPath": "3. Synchronize Database Model.md",
          "id": 16,
          "name": "Synchronize Database Model",
          "type": "file",
          "path": "model/synchronize-database-model",
          "content": "\n---\n\n## **SYNC Database Model Documentation**\n\nThis setup helps in managing your database connection and table synchronization using raw SQL queries in a Node.js application. Below is the structure of the code, explaining the role of each file.\n\n---\n\n### **1. `database.js` (Database Connection Class)**\n\nThis file establishes the connection to the MySQL database using the `mysql2` driver.\n\n#### **Code:**\n\n```javascript\n// database.js\nimport { DBnx } from \"@dbnx/mysql\";\n\n// Creating a new instance of DBnx to handle database connections.\nexport const db = new DBnx(\n    {\n        host: 'localhost', // Database host\n        user: 'root', // Database user\n        password: '11224455', // Database password\n        database: 'world', // Database name\n        waitForConnections: true, // Allows the pool to wait for connections\n        multipleStatements: true, // Allows multiple SQL statements per query\n        connectionLimit: 10, // Maximum number of connections in the pool\n        queueLimit: 0, // Unlimited connection queue size\n    },\n    // true // Use connection pooling\n);\n\n// Connecting to the database\ndb.connect()\n    .then(() => console.log('Database connected successfully'))\n    .catch((err) => console.error('Error connecting to database:', err));\n```\n\n#### **Parameters:**\n\n- **`host`**: The host where the database is located (e.g., `localhost` or remote server).\n- **`user`**: The MySQL user for authentication.\n- **`password`**: The password for the MySQL user.\n- **`database`**: The name of the database to connect to.\n- **`waitForConnections`**: Whether to wait for connections to become available if the pool is full.\n- **`multipleStatements`**: Enables or disables executing multiple SQL statements in a single query.\n- **`connectionLimit`**: The maximum number of connections in the connection pool.\n- **`queueLimit`**: The maximum number of queued connection requests.\n\n#### **Methods:**\n\n- **`db.connect()`**: Connects to the database.\n- **`db.close()`**: Closes the database connection.\n\n---\n\n### **2. `models.js` (SQL Queries to Create Tables)**\n\nIn this file, you define models for your tables using raw SQL. These models serve as the foundation for your database schema.\n\n#### **Code:**\n\n```javascript\n// models.js\nimport { db } from \"./database.js\";\n\n// Defining the UserModel to represent the 'users' table\nexport const UserModel = db.define('users', {\n    username: {\n        defaultValue: null, \n        type: \"VARCHAR(50)\",  // Data type for the username column\n        allowNull: false,    // Ensure that this field cannot be null\n        unique: true,        // Ensure that the username is unique\n    },\n    code: {\n        type: \"char(3)\",    // A character field of length 3\n        allowNull: true,    // Allows null values for the code column\n    },\n    created_at: {\n        type: \"TIMESTAMP\",  // Type for the timestamp column\n        defaultValue: \"CURRENT_TIMESTAMP\",  // Automatically set the current timestamp\n    },\n});\n```\n\n#### **Parameters for each field:**\n\n- **`type`**: Defines the MySQL data type (e.g., `VARCHAR`, `INT`, `TIMESTAMP`).\n- **`allowNull`**: Specifies whether the column can accept `null` values.\n- **`defaultValue`**: Sets a default value for the column if no value is provided.\n- **`unique`**: Ensures that all values in this column are unique.\n- **`references`**: Used for foreign key references (optional).\n\n---\n\n### **3. `syncDatabase.js` (Sync Logic)**\n\nThis file synchronizes the database, creating tables if they donâ€™t exist. If needed, it can also drop existing tables and recreate them (using `force`).\n\n#### **Code (Basic Sync):**\n\n```javascript\n// syncDatabase.js\nimport { UserModel, PostModel } from './models.js'; // Import models\n\nasync function syncDatabase() {\n    try {\n        // Synchronize the UserModel and PostModel (create tables if they don't exist)\n        const user = await UserModel.sync(); // Sync user table\n        const post = await PostModel.sync(); // Sync post table\n        console.log('Database synchronized successfully.');\n    } catch (error) {\n        console.error('Error syncing database:', error);\n    } finally {\n        await db.close(); // Close the database connection after syncing\n    }\n}\n\n// Call the sync function to initiate the process\nsyncDatabase();\n```\n\n#### **Syncing Process:**\n\n- **`UserModel.sync()`**: Synchronizes the `users` table based on the `UserModel` schema. If the table doesnâ€™t exist, it will be created.\n- **`PostModel.sync()`**: Synchronizes the `posts` table similarly.\n\n#### **Methods:**\n\n- **`sync()`**: Creates or updates the table schema.\n  - **With `force: true`**: Drops the existing table and recreates it.\n  - **Without `force`**: Only creates the table if it doesnâ€™t exist.\n  \n#### **Code (With Force Sync):**\n\n```javascript\n// syncDatabase.js\nimport { UserModel, PostModel } from './models.js'; // Import models\n\nasync function syncDatabase() {\n    try {\n        // Force sync: Drop and recreate the tables if they already exist\n        const user = await UserModel.sync(true); // Drop and recreate the user table\n        const post = await PostModel.sync(true); // Drop and recreate the post table\n        console.log('Database synchronized successfully.');\n    } catch (error) {\n        console.error('Error syncing database:', error);\n    } finally {\n        await db.close(); // Close the database connection after syncing\n    }\n}\n\n// Call the force sync function to initiate the process\nsyncDatabase();\n```\n\n---\n\n### **Common Errors & Troubleshooting**\n\n1. **Connection Errors**: Ensure that MySQL is running, and the database credentials are correct.\n   - Check MySQL service status: `sudo systemctl status mysql`\n   - Check for firewall or permission issues preventing connections.\n\n2. **Table Already Exists**: If you run into table conflicts, use `force: true` when calling `sync()` to drop and recreate tables.\n   - Example: `await UserModel.sync(true);`\n\n3. **Type Mismatch**: Ensure that the data types specified in your models (e.g., `VARCHAR(50)`, `TIMESTAMP`) match the database constraints.\n\n4. **Missing Dependencies**: Ensure that `@dbnx/mysql` is installed in your project.\n   - Install via NPM: `npm install @dbnx/mysql`\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "6.CRUD operations",
      "name": "CRUD Operations",
      "path": "crud-operations",
      "type": "folder",
      "children": [
        {
          "originalPath": "1.Create.md",
          "id": 17,
          "name": "Create",
          "type": "file",
          "path": "crud-operations/create",
          "content": "### **Create/Insert Operation Documentation**\n\n---\n\n## **Create a Model**\n\nTo create a model, you must first initialize a `DBnx` and define the modelâ€™s schema. Below is an example of how to define a `User` model:\n\n```ts\nimport {DBnx} from '@dbnx/mysql'\n```\n\n```ts\nconst db = new DBnx(\n    {\n        host: 'localhost',\n        user: 'root',\n        password: '11224455',\n        database: 'world',\n        waitForConnections: true,\n        multipleStatements: true,\n        connectionLimit: 10,\n        queueLimit: 0,\n    },\n    // true // Use pool\n); // DEFAULT connection(false)\n\nconst User = db.define('User', {\n    username: {\n        defaultValue: null,\n        type: \"VARCHAR(50)\",\n        allowNull: false,\n        unique: true,\n    },\n    created_at: {\n        type: \"TIMESTAMP\",\n        defaultValue: \"CURRENT_TIMESTAMP\",\n    },\n});\n```\n\n---\n\n### **Directly Execute Query**\n\nTo insert data using the modelâ€™s static method `create`, the following function signature is used:\n\n```ts\nstatic async create(\n  values: CreateParamsType<[]>,\n  options?: InsertIntoOptionsType\n): Promise<ResponseType>\n```\n\n#### **Parameters**\n\n| Name      | Type                    | Description                                      |\n|-----------|-------------------------|--------------------------------------------------|\n| `values`  | `CreateParamsType<[]>`   | Data to insert into the table. Must be an object or an array of objects. |\n| `options` | `InsertIntoOptionsType`  | Optional parameters such as uniqueness constraints or conflict handling. |\n\n---\n\n## **Static Method: `create`**\n\nThe static `create` method inserts one or more records into the table associated with the model. This method allows you to handle single or multiple records efficiently.\n\n### **Signature**\n\n```ts\nstatic async create(\n  values: CreateParamsType<[]>,\n  options?: InsertIntoOptionsType\n): Promise<ResponseType>\n```\n\n- **Single row:**\n\n```ts\nvalues: { name: 'John', age: 30 }\n```\n\n- **Multiple rows:**\n\n```ts\nvalues: [\n           { name: 'Alice', age: 25 },\n           { name: 'Bob', age: 28 }\n]\n```\n\n### **Parameters**\n\n| Name      | Type                    | Description                                      |\n|-----------|-------------------------|--------------------------------------------------|\n| `values`  | `CreateParamsType<[]>`   | Data to insert into the table, either as a single object or an array of objects. |\n| `options` | `InsertIntoOptionsType`  | Optional settings such as constraints on uniqueness or behavior on duplicate keys. |\n\n### **Returns**\n\nA `Promise` that resolves to the database response, including information like the inserted row count or any errors.\n\n### **Usage Example**\n\n```ts\nconst result = await User.create(\n  { name: 'John Doe', email: 'john@example.com' },\n  { uniqueColumn: 'email' }\n);\nconsole.log(result); // Logs the database response.\n```\n\nOr:\n\n```ts\nconst result = await db.create(User,\n  { name: 'John Doe', email: 'john@example.com' },\n  { uniqueColumn: 'email' }\n);\nconsole.log(result); // Logs the response from the create operation.\n```\n\n---\n\n## **Return Query and More Functions**\n\n### **Instance Method: `create`**\n\nThe instance `create` method allows you to insert data directly into a specific table.\n\n### **Signature**\n\n```ts\ncreate(\n  table: string,\n  values: CreateParamsType<[]>,\n  options?: InsertIntoOptionsType\n): DBnx | Promise<ResponseType>\n```\n\n### **Parameters**\n\n| Name      | Type                    | Description                                      |\n|-----------|-------------------------|--------------------------------------------------|\n| `table`   | `string`                | Name of the table to insert data into.           |\n| `values`  | `CreateParamsType<[]>`   | Data to insert. Can be an object or an array of objects. |\n| `options` | `InsertIntoOptionsType`  | Optional settings like handling duplicate keys or ensuring uniqueness. |\n\n### **Returns**\n\n- **Chainable instance**: Returns the instance (`DBnx`) for chaining if the method is called without execution.\n- **Execution result**: Returns a `Promise` that resolves to the response from the database after execution.\n\n### **Usage Example**\n\n```ts\nconst result = await db.create(\n  'users',\n  { name: 'Alice', age: 30 },\n  { onDuplicateUpdateFields: ['age'] }\n).execute();\nconsole.log(result); // Logs the result after execution.\n```\n\n**See the query generated:**\n\n```ts\nconst query = await db.create(\n  'users',\n  { name: 'Alice', age: 30 },\n  { onDuplicateUpdateFields: ['age'] }\n).build();\nconsole.log(query); // Logs the raw SQL query generated.\n```\n\n---\n\n## **Options for `create`**\n\nThese options allow for greater flexibility and customization of the insert operation.\n\n| Option                     | Type                | Description                                        |\n|----------------------------|---------------------|----------------------------------------------------|\n| `uniqueColumn`             | `string | null`     | Ensures unique entries by the specified column.   |\n| `onDuplicateUpdateFields`  | `string[]`          | Fields to update in case of a duplicate key conflict. |\n\n---\n\n## **Types**\n\n### **CreateParamsType**\n\nDefines the shape of the `values` parameter. It can be either a single object or an array of objects. Each object corresponds to a record to be inserted.\n\n```ts\ntype CreateParamsType<columns extends any[]> = \n  | { [P in columns[number]]?: string[] }\n  | Record<string, string | number>\n  | { [P in columns[number]]?: string[] }[];\n```\n\n### **InsertIntoOptionsType**\n\nDefines the optional parameters for customizing the insert operation, including handling uniqueness and duplicate updates.\n\n```ts\ntype InsertIntoOptionsType = {\n  uniqueColumn?: string | null;\n  onDuplicateUpdateFields?: string[];\n};\n```\n\n---\n\n## **Common Errors & Troubleshooting**\n\nHere are some common errors you may encounter, along with possible causes and solutions:\n\n| Error Message                         | Cause                                    | Solution                                       |\n|---------------------------------------|------------------------------------------|-----------------------------------------------|\n| `Values must be a non-empty object.`  | The `values` parameter is either empty or invalid.  | Ensure `values` is a valid non-empty object or an array of objects. |\n| `Expected a table name and/or values.`| The table name or values are missing.    | Provide both a valid table name and a valid `values` object. |\n| `Duplicate entry for key 'PRIMARY'`   | Duplicate data is being inserted when a unique constraint exists. | Check if you are violating a unique key constraint. Use `onDuplicateUpdateFields` or adjust the data. |\n\n---\n\n## **Advanced Features**\n\n### **Batch Insert and Performance Optimization**\n\nYou can insert multiple rows efficiently using an array of objects. This reduces the number of queries executed and is faster for large datasets.\n\n```ts\nconst result = await db.create(\n  'users',\n  [\n    { name: 'Alice', age: 30 },\n    { name: 'Bob', age: 25 },\n    { name: 'Charlie', age: 35 }\n  ]\n).execute();\nconsole.log(result); // Logs the response after batch insertion.\n```\n\n---\n\n### **On Duplicate Key Updates**\n\nIf you want to update specific fields when encountering a duplicate key, use the `onDuplicateUpdateFields` option.\n\n```ts\nconst result = await db.create(\n  'users',\n  { name: 'John', age: 30 },\n  { onDuplicateUpdateFields: ['age'] }\n).execute();\nconsole.log(result); // Logs the result after updating the 'age' field.\n```\n\nThis option ensures that when a conflict (e.g., a unique constraint violation) occurs, the specified fields are updated instead of inserting a new record.\n\n---\n\n### **Custom Conflict Handling**\n\nYou can also customize how conflicts are handled by using the `onDuplicateUpdateFields` option. This is particularly useful when dealing with unique keys or other constraints that may lead to insertion conflicts.\n\n---\n"
        },
        {
          "originalPath": "1.Sequrity.md",
          "id": 18,
          "name": "Sequrity",
          "type": "file",
          "path": "crud-operations/sequrity",
          "content": ""
        },
        {
          "originalPath": "2.Find",
          "name": "Find",
          "path": "crud-operations/2find",
          "type": "folder",
          "children": [
            {
              "originalPath": "1.FindOne.md",
              "id": 19,
              "name": "FindOne",
              "type": "file",
              "path": "crud-operations/find/findone",
              "content": "### Developer Documentation for `findOne` Function\n\n---\n\n## **1. Overview**\n\nThe `findOne` function is designed to retrieve a single record from a database table, allowing for flexibility in defining search conditions, sorting, grouping, and performing aggregation. It supports both direct table queries and model-based queries, making it suitable for various use cases in a robust data handling layer.\n\n---\n\n## **2. `FindOneParamsType` Interface**\n\nThe `FindOneParamsType` interface defines the configuration options for the `findOne` function. It includes parameters for defining the query's filters, sorting, columns to select, and more.\n\n### **Type Breakdown**\n\n```ts\nexport interface FindOneParamsType<Tables extends string[]> {\n    distinct?: boolean;\n    sort?: SortType<Tables>;\n    columns?: {\n        [P in Tables[number]]?: string[];\n    } | { extra?: string | string[] } | string | string[];\n    groupBy?: {\n        [P in Tables[number]]?: string[];\n    } | { extra?: string | string[] } | string | string[];\n    aggregates?: Array<{\n        [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string;\n    } | { alias?: string; }>;\n    where?: string;\n    having?: string;\n    subQueries?: {\n        query: string,\n        as?: string;\n    }[];\n    joins?: JoinsType<Tables>;\n    recursiveCTE?: { baseCase: string, recursiveCase: string, alias: string };\n}\n```\n\n### **Key Parameters**\n\n1. **`distinct`**:\n   - If set to `true`, the query will return distinct results.\n\n   Example:\n\n   ```ts\n   distinct: true\n   ```\n\n2. **`sort`**:\n   - Defines the sorting for the query. Can be a column name or a record specifying sorting direction.\n\n   Example:\n\n   ```ts\n   sort: { age: 1 }  // Sort by age in ascending order\n   ```\n\n3. **`columns`**:\n   - Specifies which columns to include in the result. You can specify columns for each table or provide a string for all tables.\n\n   Example:\n\n   ```ts\n   columns: { users: ['id', 'name'] }\n   ```\n\n4. **`groupBy`**:\n   - Specifies the columns by which to group the result. Similar to the `GROUP BY` clause in SQL.\n\n   Example:\n\n   ```ts\n   groupBy: { users: ['status'] }\n   ```\n\n5. **`aggregates`**:\n   - Specifies aggregate functions (`MIN`, `MAX`, `SUM`, `COUNT`, `AVG`) to apply to columns.\n\n   Example:\n\n   ```ts\n   aggregates: [{ COUNT: 'age' }]\n   ```\n\n6. **`where`**:\n   - Defines the condition for filtering records, similar to the `WHERE` clause in SQL.\n\n   Example:\n\n   ```ts\n   where: \"status = 'active'\"\n   ```\n\n7. **`having`**:\n   - Defines the condition for filtering records after applying `GROUP BY`, similar to the `HAVING` clause in SQL.\n\n   Example:\n\n   ```ts\n   having: \"COUNT(age) > 2\"\n   ```\n\n8. **`subQueries`**:\n   - Allows for subqueries to be included in the `FROM` or `WHERE` clause.\n\n   Example:\n\n   ```ts\n   subQueries: [{ query: \"SELECT id FROM users WHERE status = 'active'\", as: 'active_users' }]\n   ```\n\n9. **`joins`**:\n   - Specifies how to join other tables in the query.\n\n   Example:\n\n   ```ts\n   joins: {\n       type: 'INNER',\n       table: 'orders',\n       on: 'users.id = orders.user_id'\n   }\n   ```\n\n10. **`recursiveCTE`**:\n    - Allows the use of recursive common table expressions (CTEs).\n\n    Example:\n\n    ```ts\n    recursiveCTE: { \n        baseCase: \"SELECT id FROM users WHERE status = 'active'\", \n        recursiveCase: \"SELECT u.id FROM users u INNER JOIN users r ON u.id = r.id\", \n        alias: \"recursion\"\n    }\n    ```\n\n---\n\n## **3. The `findOne` Function**\n\n### **Function Signatures**\n\n```ts\npublic findOne<tables extends string[]>(table: string, Config?: FindOneParamsType<tables>): DBnx;\npublic findOne<tables extends string[]>(model: typeof Model, Config?: FindOneParamsType<tables>): Promise<ResponseType>;\npublic findOne(...args: any): DBnx | Promise<ResponseType>;\n```\n\n### **How It Works**\n\nThe `findOne` function is overloaded to handle different types of input. It can work with either a table name or a model class, making it versatile for both raw SQL queries and ORM-based queries.\n\n#### **First Argument: Table Name or Model**\n\n- If the first argument is a string (the table name), the function generates a `SELECT` query for that table.\n- If the first argument is a model class, the function uses the model to determine the table and then executes the query.\n\n#### **Second Argument: Config**\n\n- The second argument is a configuration object, which contains the query parameters defined in `FindOneParamsType`. This object specifies the query filters, sorting, and other options.\n\n#### **Return Type:**\n\n- The function returns either a `DBnx` for further chaining of queries or a `Promise<ResponseType>` containing the query result.\n\n---\n\n## **4. Usage Examples**\n\n### **Basic Query**\n\n```ts\nconst result = await db.findOne('users', {\n    where: \"id = 1\"\n}).build();\nconsole.log(result);\n```\n\n**Execute**:\n\n```ts\nconst result = await db.findOne('users', {\n    where: \"id = 1\"\n}).execute();\nconsole.log(result);\n```\n\n**or use Model:**\n\n```ts\nconst result = await db.findOne(UserModel,{\n    where: \"id = 1\"\n});\nconsole.log(result);\n```\n\n**Or**:\n\n```ts\nconst result = await UserModel.findOne({\n    where: \"id = 1\"\n});\nconsole.log(result);\n```\n\n**Generated SQL Query:**\n\n```sql\nSELECT * FROM users WHERE id = 1 LIMIT 1;\n```\n\n### **Using Sorting**\n\n```ts\nconst result = await db.findOne('users', {\n    where: \"status = 'active'\",\n    sort: { name: 1 }\n}).build();\nconsole.log(result);\n```\n\n**Generated SQL Query:**\n\n```sql\nSELECT * FROM users WHERE status = 'active' ORDER BY name ASC LIMIT 1;\n```\n\n### **Using Aggregates**\n\n```ts\nconst result = await db.findOne('orders', {\n    aggregates: [{ COUNT: 'id' }],\n    where: \"status = 'completed'\"\n}).build();\nconsole.log(result);\n```\n\n**Generated SQL Query:**\n\n```sql\nSELECT COUNT(id) FROM orders WHERE status = 'completed' LIMIT 1;\n```\n\n### **Using Joins**\n\n```ts\nconst result = await db.findOne('users', {\n    joins: {\n        type: 'INNER',\n        table: 'orders',\n        on: 'users.id = orders.user_id'\n    },\n    where: \"users.status = 'active'\"\n}).build();\nconsole.log(result);\n```\n\n**Generated SQL Query:**\n\n```sql\nSELECT * FROM users INNER JOIN orders ON users.id = orders.user_id WHERE users.status = 'active' LIMIT 1;\n```\n\n### **Using Subqueries**\n\n```ts\nconst result = await db.findOne('users', {\n    subQueries: [{\n        query: \"SELECT id FROM users WHERE status = 'active'\",\n        as: 'active_users'\n    }],\n    where: \"id IN (SELECT id FROM active_users)\"\n}).build();\nconsole.log(result);\n```\n\n**Generated SQL Query:**\n\n```sql\nSELECT * FROM users WHERE id IN (SELECT id FROM users WHERE status = 'active') LIMIT 1;\n```\n\n### **Using Recursive CTEs**\n\n```ts\nconst result = await db.findOne('users', {\n    recursiveCTE: {\n        baseCase: \"SELECT id FROM users WHERE status = 'active'\",\n        recursiveCase: \"SELECT u.id FROM users u INNER JOIN users r ON u.id = r.id\",\n        alias: \"recursion\"\n    }\n}).build();\nconsole.log(result);\n```\n\n**Generated SQL Query:**\n\n```sql\nWITH recursion AS (\n    SELECT id FROM users WHERE status = 'active'\n    UNION ALL\n    SELECT u.id FROM users u INNER JOIN users r ON u.id = r.id\n)\nSELECT * FROM users WHERE id IN (SELECT id FROM recursion) LIMIT 1;\n```\n\n---\n"
            },
            {
              "originalPath": "2.FindAll.md",
              "id": 20,
              "name": "FindAll",
              "type": "file",
              "path": "crud-operations/find/findall",
              "content": "### `findAll` Method Documentation\n\n#### Description\n\nThe `findAll` method is used to retrieve data from a database table or model based on the configuration options provided. The method is overloaded to support both table names and models as the first argument.\n\n#### Method Signature\n\n```typescript\npublic findAll<tables extends string[]>(table: string, Config?: FindAllParamsType<tables>): DBnx;\npublic findAll<tables extends string[]>(model: typeof Model, Config?: FindAllParamsType<tables>): Promise<ResponseType>;\npublic findAll(...args: any): DBnx | Promise<ResponseType>;\n```\n\n#### Parameters\n\n1. **`table`**:\n   - Type: `string`\n   - Description: The name of the table from which the data is to be fetched.\n   - Required: Yes (if passing a table name as the first argument).\n\n2. **`model`**:\n   - Type: `typeof Model`\n   - Description: A Model class if you want to query using a model instead of a raw table name.\n   - Required: Yes (if passing a Model as the first argument).\n\n3. **`Config`**:\n   - Type: `FindAllParamsType<tables>`\n   - Description: An optional configuration object that customizes the query.\n   - Required: No.\n\n#### Returns\n\n- **When the first argument is a table name (`string`)**:\n  - Returns a `DBnx` instance that can be chained with additional query methods.\n  \n- **When the first argument is a Model (`typeof Model`)**:\n  - Returns a `Promise<ResponseType>`, which resolves to the query result.\n\n#### Method Flow\n\n- **Case 1: When a Table Name is Provided**\n  - If the first argument is a table name (string), the `findAll` method appends the query based on the provided configuration (e.g., filtering, sorting, etc.).\n  - The method will return an instance of `DBnx` for further query chaining.\n\n- **Case 2: When a Model is Provided**\n  - If the first argument is a Model class (an instance of `typeof Model`), the method will delegate the query to the `findAll` method of that model, which will execute the query and return the results as a `Promise<ResponseType>`.\n\n#### Example Usage\n\n##### Using a Table Name\n\n```typescript\nconst handler = DBnx.findAll(\"users\", {\n  limitSkip: { limit: 10, skip: 0 },\n  sort: { name: 'ASC' },\n  columns: { users: ['id', 'name'] },\n});\n\nhandler.execute(); // Executes the query and returns the result.\n```\n\n##### Using a Model\n\n```typescript\nconst result = await User.findAll({\n  limitSkip: { limit: 5 },\n  where: \"age > 25\",\n  columns: { users: ['id', 'name', 'age'] },\n});\n\nconsole.log(result); // Result will be the fetched data based on the model query.\n```\n\n#### `FindAllParamsType` Interface\n\nThe `FindAllParamsType` interface defines the available options for customizing the query.\n\n```typescript\nexport interface FindAllParamsType<Tables extends string[]> {\n  distinct?: boolean; // Whether to select distinct records.\n  sort?: SortType<Tables>; // Sorting options.\n  limitSkip?: { limit?: number; skip?: number }; // Pagination options.\n  columns?: { [P in Tables[number]]?: string[] } | { extra?: string | string[] } | string | string[]; // Columns to retrieve.\n  groupBy?: { [P in Tables[number]]?: string[] } | { extra?: string | string[] } | string | string[]; // Grouping options.\n  aggregates?: Array<{ [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string; } | { alias?: string; }>; // Aggregation functions.\n  where?: string; // WHERE clause for filtering.\n  having?: string; // HAVING clause for filtering after GROUP BY.\n  subQueries?: { query: string; as?: string }[]; // Subqueries to include.\n  joins?: JoinsType<Tables>; // JOIN conditions.\n  recursiveCTE?: { baseCase: string, recursiveCase: string, alias: string }; // Recursive Common Table Expressions.\n}\n```\n\n#### Example of `FindAllParamsType` Configuration\n\n```typescript\nconst config: FindAllParamsType<['users']> = {\n  distinct: true,\n  limitSkip: { limit: 10, skip: 0 },\n  sort: { name: 'ASC' },\n  columns: { users: ['id', 'name'] },\n  where: 'age > 25',\n  joins: [{ table: 'orders', on: 'users.id = orders.user_id' }],\n};\n\nconst handler = DBnx.findAll(\"users\", config);\nhandler.execute();\n```\n\n#### Error Handling\n\n- **Missing Arguments**: If no arguments are provided or the first argument is neither a table name nor a model, an error will be thrown:\n\n  ```typescript\n  throw new Error(\"No arguments provided to 'findAll'. Expected a table name or model.\");\n  ```\n\n- **Invalid Configuration**: If the configuration is not a valid object, an error is thrown:\n\n  ```typescript\n  throw new Error(\"Config must be a non-empty object.\");\n  ```\n\n#### Notes\n\n- This method supports chaining when working with raw table names (`DBnx` instance is returned), but resolves the results directly when working with models (`Promise<ResponseType>` is returned).\n- The `FindAllParamsType` interface allows flexible querying, including pagination, sorting, filtering, and complex joins, making the method highly versatile.\n"
            }
          ]
        },
        {
          "originalPath": "3.Update.md",
          "id": 21,
          "name": "Update",
          "type": "file",
          "path": "crud-operations/update",
          "content": "### Developer Documentation for `UpdateParamsType` and `update` Function\n\n---\n\n## **1. Overview**\n\nThe `update` function provides an easy-to-use interface for performing `UPDATE` operations in MySQL. It supports complex update scenarios, including conditional updates with `CASE` expressions, sorting, limiting, and more. This makes it highly flexible for handling a wide variety of use cases in your database management logic.\n\n---\n\n## **2. `UpdateParamsType` Type Definition**\n\n### **Basic Structure**\n\nThe `UpdateParamsType` type defines the structure of the properties (`Props`) that can be passed to the `update` function. It includes fields for setting values, conditional updates, sorting, and more.\n\n### **Type Breakdown**\n\n```ts\nexport type UpdateParamsType<Tables extends string[]> = {\n    values?: {\n        [key: string]: string | number | null | {\n            case: {\n                when: string;  // The condition in the WHEN clause\n                then: any;     // The value to set in the THEN clause\n            }[];   // The CASE structure with an array of WHEN/THEN conditions\n            default: any;       // The default value for the column when no conditions match\n        };\n    },\n    sort?: { [P in Tables[number]]?: Record<string, 1 | -1> } | Record<string, 1 | -1> | string,\n    where: string,\n    defaultValues?: string[],\n    limit?: string | number,\n    joins?: JoinsType<Tables>,\n    fromSubQuery?: Record<string, string>,\n    setCalculations?: {    // For SET calculation\n        [key: string]: string;\n    }\n};\n```\n\n### **Key Parameters**\n\n1. **`values`**:\n   - This defines the data to be updated in the database.\n   - It can either be a direct value (e.g., string, number, or `null`) or a `CASE` expression that includes conditional logic.\n\n   Example:\n\n   ```ts\n   values: {\n       age: {\n           case: [\n               { when: \"status = 'active'\", then: 30 },\n               { when: \"status = 'inactive'\", then: 25 }\n           ],\n           default: 20\n       }\n   }\n   ```\n\n   In this example, the `age` field is updated based on the `status` field's value. If the `status` is `active`, the `age` is set to `30`. If the `status` is `inactive`, the `age` is set to `25`. Otherwise, the default value `20` is used.\n\n2. **`sort`**:\n   - Specifies sorting for the update operation. It can either be a string (column name), or an object specifying sorting directions (`1` for ascending and `-1` for descending).\n\n   Example:\n\n   ```ts\n   sort: { age: 1 }\n   ```\n\n   This will sort the records by `age` in ascending order.\n\n3. **`where`**:\n   - Defines the condition for updating the records. It is similar to the `WHERE` clause in SQL.\n\n   Example:\n\n   ```ts\n   where: \"status = 'active'\"\n   ```\n\n4. **`Null Values`**:\n   - Specifies columns that should be set to `NULL` during the update.\n\n   Example:\n\n   ```ts\n   values:{\"address\":null}\n   ```\n\n5. **`defaultValues`**:\n   - Specifies columns to be updated with their default values.\n\n   Example:\n\n   ```ts\n   defaultValues: [\"email\"]\n   ```\n\n6. **`limit`**:\n   - Limits the number of records to be updated.\n\n   Example:\n\n   ```ts\n   limit: 100\n   ```\n\n7. **`joins`**:\n   - Allows for joining other tables in the `UPDATE` operation.\n\n   Example:\n\n   ```ts\n   joins: {\n       type: \"INNER\",\n       table: \"users\",\n       on: \"orders.user_id = users.id\"\n   }\n   ```\n\n8. **`fromSubQuery`**:\n   - Allows updating data from a subquery.\n\n9. **`setCalculations`**:\n   - For setting calculated values during the update.\n\n   Example:\n\n   ```ts\n   setCalculations: {\n       total_price: \"price * quantity\"\n   }\n   ```\n\n---\n\n## **3. The `update` Function**\n\n### **Function Signatures**\n\n```ts\npublic update<tables extends string[]>(table: string, Props: UpdateParamsType<tables>): DBnx;\npublic update<tables extends string[]>(model: typeof Model, Props: UpdateParamsType<tables>): Promise<ResponseType>;\npublic update(...args: any): DBnx | Promise<ResponseType>;\n```\n\n### **How It Works**\n\nThe `update` function is overloaded, meaning it can handle different types of inputs and return either a `DBnx` for chaining queries or a `Promise<ResponseType>` for immediate results.\n\n#### **First Argument: Table Name or Model**\n\n- If the first argument is a table name (string), the function generates an SQL `UPDATE` query for that table.\n- If the first argument is a model, the function uses the model to determine the table and generates an update query.\n\n#### **Second Argument: Props**\n\n- The second argument contains the update parameters defined in `UpdateParamsType`, which specify how the update should be executed.\n\n#### **Return Type:**\n\n- If used as a query builder (in a chain), it returns a `DBnx`.\n- If executed immediately, it returns a `Promise<ResponseType>` containing the result of the query.\n\n---\n\n## **4. How to Use the `update` Function**\n\n### **Basic Update**\n\n```ts\nconst query = await db.update('users', {\n    values: {\n        name: 'John Doe',\n        age: 30\n    },\n    where: \"id = 1\"\n}).build();\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE users SET name = 'John Doe', age = 30 WHERE id = 1;\n```\n\n### **Basic Update**\n\n```ts\nconst result = await db.update('users', {\n    values: {\n        name: 'John Doe',\n        age: 30\n    },\n    where: \"id = 1\"\n}).execute();\nconsole.log(result);\n```\n\n**With model**:\n\n```ts\nconst result = await db.update(UsersModel, {\n    values: {\n        name: 'John Doe',\n        age: 30\n    },\n    where: \"id = 1\"\n});\nconsole.log(result);\n```\n\n**or**:\n\n```ts\nconst result = await UsersModel.update( {\n    values: {\n        name: 'John Doe',\n        age: 30\n    },\n    where: \"id = 1\"\n});\nconsole.log(result);\n```\n\n### **Conditional Update with CASE**\n\n```ts\nconst query = await db.update('users', {\n    values: {\n        age: {\n            case: [\n                { when: \"status = 'active'\", then: 35 },\n                { when: \"status = 'inactive'\", then: 25 }\n            ],\n            default: 30\n        }\n    },\n    where: \"id = 1\"\n}).build();\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE users SET age = CASE WHEN status = 'active' THEN 35 WHEN status = 'inactive' THEN 25 ELSE 30 END WHERE id = 1;\n```\n\n### **Update with Sorting**\n\n```ts\nconst query = await db.update('users', {\n    values: {\n        status: 'active'\n    },\n    where: \"age > 18\",\n    sort: { name: 1 }\n}).build();\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE users SET status = 'active' WHERE age > 18 ORDER BY name ASC;\n```\n\n### **Using Joins in Update**\n\n```ts\nconst query = await db.update('orders', {\n    values: {\n        status: 'shipped'\n    },\n    where: \"orders.status = 'pending'\",\n    joins: {\n        type: 'INNER',\n        table: 'users',\n        on: 'orders.user_id = users.id'\n    }\n}).build();\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE orders INNER JOIN users ON orders.user_id = users.id SET status = 'shipped' WHERE orders.status = 'pending';\n```\n\n### **Using Subquery in Update**\n\n```ts\nconst query = await db.update('orders', {\n    values: {\n        status: 'shipped'\n    },\n    where: \"id IN (SELECT id FROM pending_orders)\",\n    fromSubQuery: {\n        pending_orders: \"SELECT id FROM orders WHERE status = 'pending'\"\n    }\n}).build();\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE orders SET status = 'shipped' WHERE id IN (SELECT id FROM orders WHERE status = 'pending');\n```\n\n---\n\n## **5. Advanced Use Cases**\n\n### **Handling Null Values**\n\nYou can specify which columns should be set to `NULL` during the update operation:\n\n```ts\nconst query = await db.update('users', {\n    values: {\n        name: 'Jane Doe',\n        age: 28,\n        address: null,\n    },\n    where: \"id = 2\"\n}).build();\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE users SET name = 'Jane Doe', age = 28, address = NULL WHERE id = 2;\n```\n\n### **Performing Calculations in Updates**\n\nYou can set calculated values directly in the `values`:\n\n```ts\nconst query = await db.update('orders', {\n    values: {\n        total_price: {\n            case: [\n                { when: \"quantity > 10\", then: \"price * quantity * 0.9\" },\n                { when: \"quantity <= 10\", then: \"price * quantity\" }\n            ],\n            default: \"price * quantity\"\n        }\n    },\n    where: \"id = 3\"\n}).build();\n\n\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE orders SET total_price = CASE WHEN quantity > 10 THEN price * quantity * 0.9 WHEN quantity <= 10 THEN price * quantity ELSE price * quantity END WHERE id = 3;\n```\n\n---\n"
        },
        {
          "originalPath": "4.Delete.md",
          "id": 22,
          "name": "Delete",
          "type": "file",
          "path": "crud-operations/delete",
          "content": "\n---\n\n## **Delete Operation Documentation**\n\nThis section explains the **Delete Operation**, outlining how to delete data from a MySQL database using the `delete` helper function. This function supports customizing the deletion process with options such as **where conditions**, **joins**, **sorting**, and **limits**.\n\n---\n\n### **Setting Up the Database Handler**\n\nBefore performing delete operations, you need to configure the database handler that interacts with your MySQL database. Here's an example of how to set up the handler:\n\n```ts\nconst db = new DBnx(\n    {\n        host: 'localhost',\n        user: 'root',\n        password: '11224455',\n        database: 'world',\n        waitForConnections: true,\n        multipleStatements: true,\n        connectionLimit: 10,\n        queueLimit: 0,\n    },\n    // Use pool for better performance\n    // true\n); // Default connection is false\n\n// Define a User model with properties\nconst User = db.define('User', {\n    username: {\n        defaultValue: null,\n        type: \"VARCHAR(50)\",\n        allowNull: false,\n        unique: true,\n    },\n    created_at: {\n        type: \"TIMESTAMP\",\n        defaultValue: \"CURRENT_TIMESTAMP\",\n    },\n});\n```\n\n#### **Example Usage:**\n\n```ts\nconst query = await db.delete(\n    'users',\n    {\n        where: 'age > 30',\n        sort: { field: 'created_at', order: 'DESC' },\n        limit: 5\n    }\n).build();\nconsole.log(query); // Logs the generated DELETE SQL query\n```\n\nThis will generate the following SQL:\n\n```sql\nDELETE users FROM users WHERE age > 30 ORDER BY created_at DESC LIMIT 5;\n```\n\n#### **Customizing the Delete Operation:**\n\n1. **Where Condition**: The `where` clause is mandatory for defining which rows to delete. It is used to specify the conditions for the deletion operation (e.g., `WHERE age > 30`).\n\n2. **Joins**: The `joins` option allows you to specify SQL JOIN clauses if you need to delete data from multiple tables at once. It is passed as an object defining the tables to join.\n\nExample of a join condition:\n\n```ts\n    const query = db.delete(\n        'orders',\n        {\n            where: 'status = \"pending\"',\n            joins: {\n                type: 'INNER',\n                table: 'users',\n                on: 'orders.user_id = users.id'\n            }\n        }\n    );\n    console.log(query);\n```\n\nThis generates an SQL query with a join:\n\n```sql\n    DELETE orders FROM orders INNER JOIN users ON orders.user_id = users.id WHERE status = \"pending\";\n```\n\n**with Model**:\n\n```ts\n    const response = db.delete(\n        Orders,//this is Model of Orders\n        {\n            where: 'status = \"pending\"',\n            joins: {\n                type: 'INNER',\n                table: 'users',\n                on: 'orders.user_id = users.id'\n            }\n        }\n    );\n    console.log(response);\n```\n\n**with table**:\n\n```ts\n    const response = db.delete(\n        'orders',\n        {\n            where: 'status = \"pending\"',\n            joins: {\n                type: 'INNER',\n                table: 'users',\n                on: 'orders.user_id = users.id'\n            }\n        }\n    ).execute();\n    console.log(response);\n```\n\n1. **Limit**: The `limit` option restricts the number of rows to delete. If not specified, the operation will delete all rows matching the `where` condition.\n\n    Example with limit:\n\n```ts\n    const query = db.delete(\n        'users',\n        {\n            where: 'status = \"inactive\"',\n            limit: 10\n        }\n    );\n    console.log(query); // Deletes up to 10 rows\n```\n\nThis generates the following SQL query:\n\n```sql\n    DELETE users FROM users WHERE status = \"inactive\" LIMIT 10;\n```\n\n1. **Sorting**: The `sort` option specifies the sorting order (for example, deleting the most recent records first). This works in conjunction with the `WHERE` clause, but it's typically used for more controlled deletion strategies.\n\n    Example with sorting:\n\n```ts\nconst query = db.delete(\n    'products',\n    {\n        where: 'stock = 0',\n        sort: { field: 'created_at', order: 'ASC' }\n    }\n);\nconsole.log(query); // Deletes products in ascending order of `created_at`\n```\n\nThis generates the following SQL query:\n\n```sql\nDELETE products FROM products WHERE stock = 0 ORDER BY created_at ASC;\n```\n\n---\n\n### **Types and Definitions**\n\n#### **DeleteParamsType**\n\nDefines the shape of the parameters for the `delete` function. The `where` clause is mandatory, while `joins`, `limit`, and `sort` are optional for more advanced query configurations.\n\n```ts\nexport interface DeleteParamsType<Tables extends string[]> {\n    where: string;                    // Condition for deleting rows\n    sort?: SortType<Tables>;          // Optional sorting criteria\n    limit?: string | number;          // Optional limit for number of deleted rows\n    joins?: JoinsType<Tables>;        // Optional JOIN clauses for multi-table deletion\n}\n```\n\n#### **JoinsType**\n\nDefines the possible JOIN types (e.g., `INNER`, `LEFT`, etc.) and the associated table and ON condition.\n\n```ts\nexport type JoinsType<Tables extends string[]> = {\n    type: 'INNER' | 'LEFT' | 'RIGHT' | 'FULL';  // Type of the join\n    table: string;                             // The table to join\n    on: string;                                // The ON condition for the join\n};\n```\n\n#### **SortType**\n\nDefines sorting criteria for queries, with the field to sort by and the direction (e.g., `ASC`, `DESC`).\n\n```ts\nexport type SortType<Tables extends string[]> = {\n    field: string;  // The field to sort by\n    order: 'ASC' | 'DESC';  // Sorting direction\n};\n```\n\n---\n\n### **Best Practices for Delete Operations**\n\n1. **Always Use the WHERE Clause**: Deleting rows without a `WHERE` clause will remove all rows from the table. Ensure you always specify conditions to avoid unintended data loss.\n\n2. **Limit Deletions**: Use the `limit` option to restrict the number of rows deleted, especially in production environments where bulk deletions could affect system performance.\n\n3. **Optimize with Joins**: Use `joins` for multi-table deletion operations to ensure the deletion is properly linked across tables.\n\n4. **Test Queries First**: Always log or inspect the generated SQL query before execution to confirm it's deleting the correct data.\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "7.Advanced Usage",
      "name": "Advanced Usage",
      "path": "advanced-usage",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. SetQuery.md",
          "id": 23,
          "name": "SetQuery",
          "type": "file",
          "path": "advanced-usage/setquery",
          "content": "---\n\n### `setQuery(query: string): DBnx`\n\nThe `setQuery` method allows you to overwrite the current query with a new one. It also provides useful logging to track query changes and avoid redundant updates.\n\n#### Parameters\n\n- **`query`** (`string`): The new SQL query string to be set. This query will replace the current one.\n\n#### Returns\n\n- **`DBnx`**: Returns the current instance of the class (`this`) for method chaining.\n\n#### Behavior\n\n- The method updates the internal query variable (`#query`) with the provided `query` string.\n- It logs a message indicating the query change. If the query remains the same as before, a message will indicate no change.\n- This method helps keep track of when and how queries are being set, which can be helpful for debugging or auditing purposes.\n\n#### Example Usage\n\n```typescript\n// Create an instance of DBnx\nconst logger = (message: string) => console.log(message);\nconst instance = new DBnx(logger);\n\n// Set a new query\ninstance.setQuery('SELECT * FROM users');\n\n// Set the same query again (no change will be logged)\ninstance.setQuery('SELECT * FROM users');\n\n// Set a different query\ninstance.setQuery('SELECT * FROM products');\n```\n\n#### Console Output\n\n```\nQuery set to: SELECT * FROM users\nQuery remains the same: SELECT * FROM users\nQuery set to: SELECT * FROM products\n```\n\n#### Notes\n\n- If the new query is the same as the previous query, a message indicating no change will be logged (`Query remains the same: <query>`).\n- If the query is different, the log message will indicate the new query that has been set (`Query set to: <query>`).\n  \n---\n"
        },
        {
          "originalPath": "Multiple Execute Query.md",
          "id": 24,
          "name": "Multiple Execute Query",
          "type": "file",
          "path": "advanced-usage/multiple-execute-query",
          "content": "\n---\n\n## **DBnx Multiple Execute Query Example with `executeQuery()`**\n\nThis documentation provides the step-by-step process of executing multiple database queries using the `DBnx` library. The following methods (`update`, `findAll`, `create`, `delete`) are chained together to execute in a single sequence.\n\n---\n\n### **1. Setup `database.js` (Database Connection Class)**\n\nThe `DBnx` instance is initialized in this file, establishing the connection with MySQL.\n\n#### **Code:**\n\n```javascript\n// database.js\nimport { DBnx } from \"@dbnx/mysql\";\n\n// Create a new DBnx instance to handle database connection.\nexport const db = new DBnx(\n    {\n        host: 'localhost',        // Database host\n        user: 'root',             // Database username\n        password: '11224455',     // Database password\n        database: 'world',        // Database name\n        waitForConnections: true, // Allow the pool to wait for a connection\n        multipleStatements: true, // Allow multiple SQL statements in one query\n        connectionLimit: 10,      // Max number of connections in the pool\n        queueLimit: 0,            // Unlimited queue size\n    },\n    // true // Enable connection pooling\n);\n\n// Connect to the database\ndb.connect()\n```\n\n---\n\n### **2. Multiple Queries with `executeQuery()`**\n\nIn this example, we'll execute the following queries sequentially using the `executeQuery()` method:\n\n1. **Update** a product's title.\n2. **Find all** products.\n3. **Create** a new product.\n4. **Find one** specific product.\n5. **Delete** a product.\n\n#### **Code:**\n\n```javascript\n// executeQueries.js\nimport { db } from './database.js';\n\nasync function executeMultipleQueries() {\n    try {\n        // Begin executing multiple queries\n        const result = await db\n            .update('product', {\n                values: {\n                    title: 'SRAKIB brand', // New title\n                },\n                where: 'product_id = 1', // Condition for the update\n            })\n            .findAll('product') // Retrieve all products\n            .create('product', {\n                title: 'test', // New product to be created\n            })\n            .findOne('product', {\n                where: 'product_id = 1', // Find one product with product_id = 1\n            })\n            .delete('product', {\n                where: 'product_id = 2', // Delete product with product_id = 2\n            })\n            .executeQuery(); // Execute all queries in sequence\n\n        console.log('Multiple queries executed successfully:', result);\n    } catch (error) {\n        console.error('Error executing multiple queries:', error);\n    } finally {\n        await db.close(); // Close the database connection after execution\n    }\n}\n\n// Call the function to execute the queries\nexecuteMultipleQueries();\n```\n\n---\n\n### **3. Breakdown of Methods**\n\nHere's an explanation of the different query methods used in the example:\n\n#### **`update(table, { values, where })`**\n\n- **Purpose**: Updates existing records in the specified table.\n- **Parameters**:\n  - **`table`**: Name of the table (e.g., `'product'`).\n  - **`values`**: An object containing the column-value pairs to update.\n  - **`where`**: The condition to match the records that need to be updated.\n\n#### **`findAll(table)`**\n\n- **Purpose**: Retrieves all records from the specified table.\n- **Parameters**:\n  - **`table`**: Name of the table (e.g., `'product'`).\n\n#### **`create(table, data)`**\n\n- **Purpose**: Inserts a new record into the specified table.\n- **Parameters**:\n  - **`table`**: Name of the table (e.g., `'product'`).\n  - **`data`**: An object containing the column-value pairs to insert.\n\n#### **`findOne(table, { where })`**\n\n- **Purpose**: Retrieves a single record from the specified table that matches the given condition.\n- **Parameters**:\n  - **`table`**: Name of the table (e.g., `'product'`).\n  - **`where`**: The condition to match the record (e.g., `'product_id = 1'`).\n\n#### **`delete(table, { where })`**\n\n- **Purpose**: Deletes a record from the specified table based on the condition.\n- **Parameters**:\n  - **`table`**: Name of the table (e.g., `'product'`).\n  - **`where`**: The condition to match the record to delete.\n\n#### **`executeQuery()`**\n\n- **Purpose**: Executes all the queued queries in sequence.\n- **Returns**: The result of the queries once executed.\n\n---\n\n### **4. Handling Errors**\n\nMake sure to handle errors properly by wrapping the entire process in a `try...catch` block. This will catch any exceptions that occur during the execution of the queries.\n\n#### **Error Handling Example:**\n\n```javascript\ntry {\n    const result = await db\n        .update('product', { values: { title: 'SRAKIB brand' }, where: 'product_id = 1' })\n        .findAll('product')\n        .create('product', { title: 'test' })\n        .findOne('product', { where: 'product_id = 1' })\n        .delete('product', { where: 'product_id = 2' })\n        .executeQuery();\n    \n    console.log(result);\n} catch (error) {\n    console.error('Error executing query chain:', error);\n}\n```\n\n---\n\n### **5. Closing the Connection**\n\nIt's important to close the database connection once all queries are executed to free up resources.\n\n```javascript\nawait db.close();\n```\n\n---\n\n### **6. Example Output**\n\nOnce the queries are executed successfully, you should see an output similar to this:\n\n```plaintext\nDatabase connected successfully\nMultiple queries executed successfully: [/* Array of results from each query */]\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "8.API Reference",
      "name": "API Reference",
      "path": "api-reference",
      "type": "folder",
      "children": [
        {
          "originalPath": "crud",
          "name": "Crud",
          "path": "api-reference/crud",
          "type": "folder",
          "children": [
            {
              "originalPath": "Create.md",
              "id": 25,
              "name": "Create",
              "type": "file",
              "path": "api-reference/crud/create",
              "content": "### API Reference for `create` Method\n\nThis reference explains the usage of the `create` method, which is used to insert new records into a table or model.\n\n---\n\n### **`create` Method**\n\n#### **Method Signature**\n\n```typescript\npublic create<tables extends string[]>(table: string, values: CreateParamsType<[]>, options?: CreateOptionsType): MySQLHandler;\npublic create<tables extends string[]>(model: typeof Model, values: CreateParamsType<[]>, options?: CreateOptionsType): Promise<ResponseType>;\npublic create(...args: any): MySQLHandler | Promise<ResponseType>;\n```\n\n#### **Description**\n\nThe `create` method is used to insert new records into a table or model. The method supports both direct table insertion and ORM-based model insertion. It takes the values to be inserted and options that define the insertion behavior.\n\n---\n\n### **Parameters**\n\n1. **`table`** (required)  \n   - Type: `string`  \n   - Description: The name of the table into which the record will be inserted.  \n   - Example: `\"users\"`, `\"products\"`\n\n2. **`model`** (required for Model-based queries)  \n   - Type: `typeof Model`  \n   - Description: The model class (e.g., `User`, `Product`) if you prefer querying through the ORM model rather than using the table name directly.  \n   - Example: `User`, `Product`\n\n3. **`values`** (required)  \n   - Type: `CreateParamsType<[]>`  \n   - Description: The values to be inserted into the table or model.  \n   - Example:\n\n     ```typescript\n     {\n       name: \"John\",\n       age: 30,\n       email: \"john@example.com\"\n     }\n     ```\n\n4. **`options`** (optional)  \n   - Type: `CreateOptionsType`  \n   - Description: Options that define the behavior of the insertion (e.g., `engine`, `charset`, `collation`, `auto_increment`).  \n   - Example:\n\n     ```typescript\n     {\n       engine: \"InnoDB\",\n       charset: \"utf8mb4\",\n       collation: \"utf8mb4_unicode_ci\",\n       auto_increment: 100\n     }\n     ```\n\n---\n\n### **Response**\n\n- **When a table name is provided**:  \n  - Returns an instance of `MySQLHandler`, which is the query builder.\n  \n- **When a model class is provided**:  \n  - Returns a `Promise<ResponseType>` with the result of the insert operation executed on the database.\n\n---\n\n### **Details of `CreateParamsType` and `CreateOptionsType`**\n\n```typescript\nexport type CreateParamsType<Tables extends string[]> = {\n    // Define the fields and their values for inserting new records.\n    [key: string]: string | number | boolean | null;\n}\n\nexport type CreateOptionsType = {\n    engine?: Engine;        // Optional: Defines the storage engine (e.g., \"InnoDB\")\n    charset?: Charset;      // Optional: Defines the character set (e.g., \"utf8mb4\")\n    collation?: Collation;  // Optional: Defines the collation (e.g., \"utf8mb4_unicode_ci\")\n    auto_increment?: number; // Optional: Defines the auto-increment value for the primary key\n};\n```\n\n- **`CreateParamsType`**: This defines the fields and their values that will be inserted into the table. It can include basic types like strings, numbers, booleans, or `null`.\n\n- **`CreateOptionsType`**: This defines additional options for the creation operation, such as the database engine, charset, collation, and auto-increment values for primary keys.\n\n---\n\n### **Examples**\n\n#### Example 1: Inserting a record using a table name\n\n```typescript\nconst query = create('users', {\n    name: \"John\",\n    age: 30,\n    email: \"john@example.com\"\n}, {\n    engine: \"InnoDB\",\n    charset: \"utf8mb4\",\n    collation: \"utf8mb4_unicode_ci\"\n});\nconsole.log(query);  // The resulting INSERT SQL query string\n```\n\n#### Example 2: Inserting a record using a model\n\n```typescript\nconst result = await User.create({\n    name: \"John\",\n    age: 30,\n    email: \"john@example.com\"\n}, {\n    engine: \"InnoDB\",\n    charset: \"utf8mb4\",\n    collation: \"utf8mb4_unicode_ci\"\n});\nconsole.log(result);  // Result of the insert operation\n```\n\n---\n\n### **Errors**\n\n- **Missing arguments**: If no arguments are provided or if the arguments are invalid, an error will be thrown.\n  \n  Example:\n\n  ```typescript\n  // Missing table name or model\n  create();\n  // Error: No arguments provided to 'create'. Expected a table name and/or values.\n  ```\n\n- **Invalid first argument**: The first argument must be either a table name (string) or a model class.\n\n  Example:\n\n  ```typescript\n  // Invalid argument type\n  create(123, { name: \"John\", age: 30 });\n  // Error: Invalid first argument: must be a table name or a Model class.\n  ```\n\n- **Invalid values**: If `values` is not provided or is not an object, an error will be thrown.\n\n  Example:\n\n  ```typescript\n  // Invalid values\n  create('users', \"name: John\");\n  // Error: Values must be a non-empty object.\n  ```\n\n---\n\n### **Internal Methods**\n\n- **`insertInto` function**: This function constructs the actual SQL `INSERT` query based on the provided parameters.\n- **`runHooks` function**: If applicable, this can run hooks like `beforeCreate` before executing the insert operation.\n\n---\n\n### **Use Case**\n\nUse the `create` method when you need to insert new records into a table, either directly by specifying the table name or via ORM model classes. You can include additional options such as `charset`, `collation`, and `auto_increment` for advanced table configurations. This method ensures that the insertion operation is performed correctly with the provided data.\n"
            },
            {
              "originalPath": "Delete.md",
              "id": 26,
              "name": "Delete",
              "type": "file",
              "path": "api-reference/crud/delete",
              "content": "### API Reference for `delete` Method\n\nThis reference provides detailed information on how to use the `delete` method in both Model and DBHandler, including parameters, response, examples, and possible errors.\n\n---\n\n### **`delete` Method**\n\n#### **Method Signature**\n\n```typescript\npublic delete<tables extends string[]>(table: string, Props: DeleteParamsType<tables>): MySQLHandler;\npublic delete<tables extends string[]>(model: typeof Model, Props: DeleteParamsType<tables>): Promise<ResponseType>;\npublic delete(...args: any): MySQLHandler | Promise<ResponseType>;\n```\n\n#### **Description**\n\nThe `delete` method is used to delete records from a table or model based on the provided conditions. It can be used either by passing a table name directly or by querying a model class.\n\n---\n\n### **Parameters**\n\n1. **`table`** (required)  \n   - Type: `string`  \n   - Description: The name of the table from which records will be deleted.  \n   - Example: `\"users\"`, `\"orders\"`\n\n2. **`model`** (required for Model-based queries)  \n   - Type: `typeof Model`  \n   - Description: A model class (e.g., `User`, `Product`) if you prefer querying through the ORM model rather than using the table name directly.  \n   - Example: `User`, `Product`\n\n3. **`Props`** (required)  \n   - Type: `DeleteParamsType<tables>`  \n   - Description: An object that defines the parameters for the delete operation.  \n   - Example:\n\n     ```typescript\n     {\n       where: \"age > 25\",\n       sort: { name: \"ASC\" },\n       limit: 10,\n       joins: { table: \"address\", on: \"users.id = address.user_id\" }\n     }\n     ```\n\n---\n\n### **Response**\n\n- **When a table name is provided**:  \n  - Returns an instance of `MySQLHandler`, which is the query builder.\n  \n- **When a model class is provided**:  \n  - Returns a `Promise<ResponseType>` with the result of the delete operation executed on the database.\n\n---\n\n### **Details of `DeleteParamsType`**\n\n```typescript\nexport interface DeleteParamsType<Tables extends string[]> {\n    where: string; // The condition to identify which rows to delete\n    sort?: SortType<Tables>; // Optional: Sorting options for the query\n    limit?: string | number; // Optional: Limit the number of deleted records\n    joins?: JoinsType<Tables>; // Optional: Join conditions for the delete query\n}\n```\n\n- **`where`**: The condition that specifies which rows should be deleted (e.g., `\"age > 30\"`).\n- **`sort`**: Sorting criteria for the query (e.g., `{ name: \"ASC\" }`).\n- **`limit`**: Limits the number of records to delete (e.g., `10`).\n- **`joins`**: Define join conditions if the delete query involves joining other tables.\n\n---\n\n### **Examples**\n\n#### Example 1: Deleting records using a table name\n\n```typescript\nconst query = dbHandler.delete('users', {\n    where: 'age > 30',\n    sort: { name: 'ASC' },\n    limit: 10,\n    joins: { table: 'orders', on: 'users.id = orders.user_id' }\n});\nconsole.log(query);  // The resulting DELETE SQL query string\n```\n\n#### Example 2: Deleting records using a model\n\n```typescript\nconst result = await User.delete({\n    where: 'age > 30',\n    sort: { name: 'ASC' },\n    limit: 10\n});\nconsole.log(result);  // Result of the delete operation\n```\n\n---\n\n### **Errors**\n\n- **Missing arguments**: If no arguments are provided or if the arguments are invalid, an error will be thrown.\n  \n  Example:\n\n  ```typescript\n  // Missing table name or model\n  delete();\n  // Error: No arguments provided to 'delete'. Expected a table name or model.\n  ```\n\n- **Invalid first argument**: The first argument must be either a table name (string) or a model class.\n\n  Example:\n\n  ```typescript\n  // Invalid argument type\n  delete(123, { where: \"age > 30\" });\n  // Error: Invalid first argument: must be a table name or a Model class.\n  ```\n\n- **Props must be a non-empty object**: If `Props` is not provided or is not an object, an error will be thrown.\n\n  Example:\n\n  ```typescript\n  // Invalid props\n  delete('users', \"where: age > 30\");\n  // Error: Props must be a non-empty object.\n  ```\n\n---\n\n### **Internal Methods**\n\n- **`destroy` function**: This is used to construct the actual DELETE SQL query.\n- **`parseJoins` function**: Handles parsing and formatting the `joins` parameter into SQL JOIN clauses.\n- **`parseSort` function**: Handles parsing and formatting the `sort` parameter into SQL ORDER BY clauses.\n\n---\n\n### **Use Case**\n\nUse the `delete` method when you want to delete records from a table with specific conditions such as filtering, sorting, and limiting the number of records to be deleted. It can be used with both direct table names or ORM-based models.\n"
            },
            {
              "originalPath": "Find.md",
              "id": 27,
              "name": "Find",
              "type": "file",
              "path": "api-reference/crud/find",
              "content": "\n---\n\nThis API offers methods to query and retrieve records from the database. You can find a single record or multiple records with advanced filtering, sorting, and aggregation capabilities.\n\n---\n\n### **1. `findAll` Method**\n\n#### **Method Signature**\n\n```typescript\npublic findAll<tables extends string[]>(table: string, config?: FindAllParamsType<tables>): MySQLHandler;\npublic findAll<tables extends string[]>(model: typeof Model, config?: FindAllParamsType<tables>): Promise<ResponseType>;\n```\n\n#### **Parameters:**\n\n- **`table`** (`string`):\n  - The name of the table to query.\n  - Alternatively, you can pass a `Model` class.\n  \n- **`config`** (`FindAllParamsType<tables>`):\n  - Optional configuration for querying the table.\n  - **Possible options:**\n    - `distinct`: If true, returns distinct rows.\n    - `sort`: Sorting configuration, defined using `SortType`.\n    - `limitSkip`: Pagination options (`limit` and `skip` values).\n    - `columns`: Columns to select (can be specified per table).\n    - `groupBy`: Columns to group by.\n    - `aggregates`: Array of aggregate functions (e.g., `MIN`, `MAX`).\n    - `where`: `WHERE` clause condition.\n    - `having`: `HAVING` clause condition.\n    - `subQueries`: List of subqueries.\n    - `joins`: Table joins, defined using `JoinsType`.\n    - `recursiveCTE`: Recursive common table expressions.\n\n#### **Returns:**\n\n- **`MySQLHandler`**: If a `table` name is provided, the query handler is returned to build and execute the query.\n- **`Promise<ResponseType>`**: If a `Model` class is provided, the query is executed, and a `Promise` with the response is returned.\n\n#### **Example:**\n\n```typescript\nconst results = await findAll('users', {\n  sort: { name: 1 },\n  limitSkip: { limit: 10, skip: 0 },\n  columns: ['name', 'email'],\n  where: 'status = \"active\"',\n});\n```\n\n---\n\n### **2. `findOne` Method**\n\n#### **Method Signature**\n\n```typescript\npublic findOne<tables extends string[]>(table: string, config?: FindOneParamsType<tables>): MySQLHandler;\npublic findOne<tables extends string[]>(model: typeof Model, config?: FindOneParamsType<tables>): Promise<ResponseType>;\n```\n\n#### **Parameters:**\n\n- **`table`** (`string`):\n  - The name of the table to query.\n  - Alternatively, you can pass a `Model` class.\n  \n- **`config`** (`FindOneParamsType<tables>`):\n  - Optional configuration for querying the table.\n  - **Possible options:**\n    - `distinct`: If true, returns distinct rows.\n    - `sort`: Sorting configuration, defined using `SortType`.\n    - `columns`: Columns to select (can be specified per table).\n    - `groupBy`: Columns to group by.\n    - `aggregates`: Array of aggregate functions.\n    - `where`: `WHERE` clause condition.\n    - `having`: `HAVING` clause condition.\n    - `subQueries`: List of subqueries.\n    - `joins`: Table joins, defined using `JoinsType`.\n    - `recursiveCTE`: Recursive common table expressions.\n\n#### **Returns:**\n\n- **`MySQLHandler`**: If a `table` name is provided, the query handler is returned to build and execute the query.\n- **`Promise<ResponseType>`**: If a `Model` class is provided, the query is executed, and a `Promise` with the response is returned.\n\n#### **Example:**\n\n```typescript\nconst user = await findOne('users', {\n  where: 'id = 1',\n  columns: ['id', 'name', 'email'],\n});\n```\n\n---\n\n### **3. `JoinsType`**\n\nDefines the different types of joins that can be used in the query.\n\n```typescript\nexport type JoinsType<Tables extends string[]> = Array<{\n    operator?: OperatorType | string,\n    type?: 'JOIN' | 'INNER JOIN' | 'OUTER JOIN' | 'CROSS JOIN' | 'RIGHT JOIN' | 'LEFT JOIN';\n} | {\n    on?: string, table?: string\n} | {\n    [key: string]: string\n} | {\n    [P in Tables[number]]?: string\n}>\n```\n\n#### **Usage:**\n\nYou can define how to join tables, specify the join type (e.g., `LEFT JOIN`), and use operators (e.g., `=` or `IN`).\n\n#### **Example:**\n\n```typescript\nconst results = await findAll('users', {\n  joins: [\n    { type: 'INNER JOIN', table: 'profiles', on: 'users.id = profiles.user_id' },\n  ],\n});\n```\n\n---\n\n### **4. `SortType`**\n\nDefines how the results should be sorted.\n\n```typescript\nexport type SortType<Tables extends string[]> = { [P in Tables[number]]?: Record<string, 1 | -1> } | Record<string, 1 | -1> | string;\n```\n\n#### **Usage:**\n\nYou can sort the results based on one or more columns.\n\n- `1` indicates ascending order.\n- `-1` indicates descending order.\n\n#### **Example:**\n\n```typescript\nconst sortedResults = await findAll('products', {\n  sort: { price: -1 }, // Sort by price in descending order\n});\n```\n\n---\n\n### **5. `OperatorType`**\n\nDefines the different operators that can be used in the query conditions.\n\n```typescript\nexport type OperatorType =\n    | '='    // Equality\n    | '!='   // Not equal\n    | '<>'   // Not equal (alternate syntax)\n    | '<'    // Less than\n    | '>'    // Greater than\n    | '<='   // Less than or equal\n    | '>='   // Greater than or equal\n    | 'LIKE' // Pattern matching\n    | 'IN'   // Check if value exists in a set\n    | 'BETWEEN'; // Range condition\n```\n\n#### **Usage:**\n\nYou can use these operators in the `where` condition to define filters on the data.\n\n#### **Example:**\n\n```typescript\nconst results = await findAll('orders', {\n  where: 'totalAmount > 100 AND status = \"completed\"',\n  operator: 'IN',\n});\n```\n\n---\n\n### **6. `FindOneParamsType` Interface**\n\nThe configuration object for a single query to find one record.\n\n```typescript\nexport interface FindOneParamsType<Tables extends string[]> {\n    distinct?: boolean;\n    sort?: SortType<Tables>;\n    columns?: { [P in Tables[number]]?: string[] } | string | string[];\n    groupBy?: { [P in Tables[number]]?: string[] } | string | string[];\n    aggregates?: Array<{ [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string }>;\n    where?: string;\n    having?: string;\n    subQueries?: { query: string, as?: string }[];\n    joins?: JoinsType<Tables>;\n    recursiveCTE?: { baseCase: string, recursiveCase: string, alias: string };\n}\n```\n\n#### **Usage:**\n\nThis is used to pass query options for the `findOne` operation. You can filter data, sort, group, and more.\n\n---\n\n### **7. `FindAllParamsType` Interface**\n\nThe configuration object for a query to find multiple records.\n\n```typescript\nexport interface FindAllParamsType<Tables extends string[]> {\n    distinct?: boolean;\n    sort?: SortType<Tables>;\n    limitSkip?: { limit?: number; skip?: number };\n    columns?: { [P in Tables[number]]?: string[] } | string | string[];\n    groupBy?: { [P in Tables[number]]?: string[] } | string | string[];\n    aggregates?: Array<{ [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string }>;\n    where?: string;\n    having?: string;\n    subQueries?: { query: string, as?: string }[];\n    joins?: JoinsType<Tables>;\n    recursiveCTE?: { baseCase: string, recursiveCase: string, alias: string };\n}\n```\n\n#### **Usage:**\n\nThis is used to pass query options for the `findAll` operation. You can control the results using filtering, sorting, pagination, and more.\n\n---\n\n### **Conclusion**\n\nWith the `find` API, you can easily query the database to fetch single or multiple records, with flexible configurations for sorting, filtering, grouping, and joining tables. This API is highly customizable to suit various database query requirements, giving you full control over how the data is retrieved.\n\n---\n"
            },
            {
              "originalPath": "Update.md",
              "id": 28,
              "name": "Update",
              "type": "file",
              "path": "api-reference/crud/update",
              "content": "### API Reference for `update` Method\n\nThis reference explains the usage of the `update` method, including parameters, response, examples, and possible errors.\n\n---\n\n### **`update` Method**\n\n#### **Method Signature**\n\n```typescript\npublic update<tables extends string[]>(table: string, Props: UpdateParamsType<tables>): MySQLHandler;\npublic update<tables extends string[]>(model: typeof Model, Props: UpdateParamsType<tables>): Promise<ResponseType>;\npublic update(...args: any): MySQLHandler | Promise<ResponseType>;\n```\n\n#### **Description**\n\nThe `update` method is used to update existing records in a table or model. The update is performed based on the conditions provided in the parameters. You can specify fields to update, conditions to match, sorting, and other query modifiers.\n\n---\n\n### **Parameters**\n\n1. **`table`** (required)  \n   - Type: `string`  \n   - Description: The name of the table where records will be updated.  \n   - Example: `\"users\"`, `\"products\"`\n\n2. **`model`** (required for Model-based queries)  \n   - Type: `typeof Model`  \n   - Description: The model class (e.g., `User`, `Product`) if you prefer querying through the ORM model rather than using the table name directly.  \n   - Example: `User`, `Product`\n\n3. **`Props`** (required)  \n   - Type: `UpdateParamsType<tables>`  \n   - Description: The parameters for the update operation, including columns to update, conditions, sorting, and other options.  \n   - Example:\n\n     ```typescript\n     {\n       values: { \n         age: 30, \n         name: \"John\" \n       },\n       where: \"id = 5\",\n       sort: { name: \"ASC\" },\n       limit: 10,\n       joins: { table: \"orders\", on: \"users.id = orders.user_id\" }\n     }\n     ```\n\n---\n\n### **Response**\n\n- **When a table name is provided**:  \n  - Returns an instance of `MySQLHandler`, which is the query builder.\n  \n- **When a model class is provided**:  \n  - Returns a `Promise<ResponseType>` with the result of the update operation executed on the database.\n\n---\n\n### **Details of `UpdateParamsType`**\n\n```typescript\nexport type UpdateParamsType<Tables extends string[]> = {\n    values?: { // The data to update\n        [key: string]: string | number | null | { \n            case: { \n                when: string;  // The condition in the WHEN clause\n                then: any;     // The value to set in the THEN clause\n            }[];  // The CASE structure with an array of WHEN/THEN conditions\n            default: any;  // The default value for the column when no conditions match\n        };\n    },\n    sort?: { [P in Tables[number]]?: Record<string, 1 | -1> } | Record<string, 1 | -1> | string,\n    where: string,   // The condition to identify which rows to update\n    defaultValues?: string[], // Optional: Columns to set to default values\n    limit?: string | number,  // Optional: Limits the number of records to update\n    joins?: JoinsType<Tables>, // Optional: Join conditions for the update query\n    fromSubQuery?: Record<string, string>, // Optional: Subqueries for the update operation\n    setCalculations?: { // For SET calculation\n        [key: string]: string; // Expressions to calculate new values\n    }\n}\n```\n\n- **`values`**: Specifies the columns to be updated. It can include:\n  - Direct values (e.g., `{ age: 30, name: \"John\" }`).\n  - Complex `CASE` structures with conditions and default values.\n\n- **`sort`**: Sorting options for the query (e.g., `{ name: \"ASC\" }`).\n\n- **`where`**: The condition for selecting the rows to be updated (e.g., `\"id = 5\"`).\n\n- **`defaultValues`**: Columns to be set to their default values.\n\n- **`limit`**: Limits the number of records to update.\n\n- **`joins`**: Specifies join conditions if the update operation involves multiple tables.\n\n- **`fromSubQuery`**: Allows the use of a subquery for the update operation.\n\n- **`setCalculations`**: Allows you to specify calculations to set the new values (e.g., `{ total_price: \"quantity * unit_price\" }`).\n\n---\n\n### **Examples**\n\n#### Example 1: Updating records using a table name\n\n```typescript\nconst query = update('users', {\n    values: { age: 30, name: \"John\" },\n    where: \"id = 5\",\n    sort: { name: \"ASC\" },\n    limit: 10,\n    joins: { table: \"orders\", on: \"users.id = orders.user_id\" }\n});\nconsole.log(query);  // The resulting UPDATE SQL query string\n```\n\n#### Example 2: Updating records using a model\n\n```typescript\nconst result = await User.update({\n    values: { age: 30, name: \"John\" },\n    where: \"id = 5\",\n    sort: { name: \"ASC\" },\n    limit: 10\n});\nconsole.log(result);  // Result of the update operation\n```\n\n---\n\n### **Errors**\n\n- **Missing arguments**: If no arguments are provided or if the arguments are invalid, an error will be thrown.\n  \n  Example:\n\n  ```typescript\n  // Missing table name or model\n  update();\n  // Error: No arguments provided to 'update'. Expected a table name or model.\n  ```\n\n- **Invalid first argument**: The first argument must be either a table name (string) or a model class.\n\n  Example:\n\n  ```typescript\n  // Invalid argument type\n  update(123, { where: \"id = 5\" });\n  // Error: Invalid first argument: must be a table name or a Model class.\n  ```\n\n- **Props must be a non-empty object**: If `Props` is not provided or is not an object, an error will be thrown.\n\n  Example:\n\n  ```typescript\n  // Invalid props\n  update('users', \"where: id = 5\");\n  // Error: Props must be a non-empty object.\n  ```\n\n---\n\n### **Internal Methods**\n\n- **`update` function**: This function constructs the actual SQL `UPDATE` query based on the provided parameters.\n- **`parseJoins` function**: Parses and formats the `joins` parameter into SQL JOIN clauses.\n- **`parseSort` function**: Parses and formats the `sort` parameter into SQL ORDER BY clauses.\n\n---\n\n### **Use Case**\n\nUse the `update` method when you need to modify existing records in a table, with various conditions and sorting. It can be used with both direct table names or ORM-based models. This method supports advanced features like `CASE` expressions, sorting, joining multiple tables, and limiting the number of records affected.\n"
            }
          ]
        }
      ]
    }
  ],
  "files": [
    {
      "id": 1,
      "path": "release-note/v1023",
      "name": "V1.0.23",
      "folder": "Release Note",
      "content": "\n---\n\n### Release Notes: Version 1.0.23\n\n**Date Released:** December 31, 2024\n\n#### New Features\n\n1. **Enhanced SQL Query Builder**  \n   - **Filter Enhancements:** The `dbnxCondition` function now supports more flexible filter conditions, including `IN`, `NOT IN`, `BETWEEN`, `NOT BETWEEN`, `IN RANGE`, `LIKE`, `NOT LIKE`, `REGEXP`, and logical conditions like `$or`, `$and`.\n   - **Pattern Matching Improvements:** Enhanced pattern handling for SQL `LIKE`, `NOT LIKE`, and `REGEXP` operators with proper sanitization and escape handling.\n   - **Null Checks:** Added support for `IS NULL` and `IS NOT NULL` conditions in SQL queries.\n   - **Improved Range Checks:** Added `inRange` and `BETWEEN` checks with clearer handling of number ranges.\n\n2. **Refined Data Sanitization:**  \n   - `sanitize()` method now automatically escapes special characters to protect against SQL injection and ensures safe query generation.\n\n3. **Better Logical Operations:**  \n   - The `$and` and `$or` operators are now more easily managed, allowing complex filter combinations for better flexibility in query construction.\n\n#### Bug Fixes\n\n- Fixed issue where `IN` and `NOT IN` conditions were not being sanitized correctly for arrays of values.\n- Resolved an issue with `BETWEEN` and `NOT BETWEEN` conditions where boundary values were not properly escaped.\n\n#### Documentation Updates\n\n- The type definitions for `FilterValue` and `Filters` have been updated to reflect new features and filter conditions.\n- Added examples for common use cases of the `dbnxCondition` function.\n- Improved inline comments and documentation for SQL generation, especially for pattern matching and range-based filters.\n\n#### Example Update\n\nHereâ€™s an updated example showcasing the use of the new filter conditions:\n\n```typescript\nconst filters: Filters = {\n    status: \"active\",\n    price: { between: [1000, 5000] },\n    tags: [\"electronics\", \"home\"],\n    location: { notIn: [\"New York\", \"California\"] },\n    stock: { inRange: [10, 50] },\n    updatedAt: { isNull: true },\n    title: { like: \"%phone%\" },\n    discount: {\n        eq: 34\n    },\n    description: { notLike: \"%old%\" },\n    color: {\n        $or: [\n            { like: \"red\" },\n            { like: \"blue\" },\n        ],\n    },\n    $and: {\n        category: \"electronics\",\n        brand: { regexp: \"^Samsung\" },\n    },\n};\n```\n\n---\n"
    },
    {
      "id": 2,
      "path": "release-note/v1016",
      "name": "V1.0.16",
      "folder": "Release Note",
      "content": "### Release Notes - Version 1.0.16\n\n#### New Features\n\n1. **Logger Functionality**:\n   - Introduced enhanced `logger_execute` functionality for more detailed logging throughout the application. This allows developers to track and log various database interactions (e.g., connections, queries, table manipulations) with clear and meaningful messages.\n   - Example Logs:\n     - `âœ¨ Creating model: \\`modelName\\``\n     - `ðŸ”„ Starting model synchronization...`\n     - `âŒ Error initializing model: \\`modelName\\`: Error message`\n\n   This feature improves debugging and enhances the overall visibility of database operations.\n\n2. **Updated `getConfig` Function**:\n   - The `getConfig` function has been updated to handle multiple configurations for both pool and connection-based instances.\n   - Returns:\n     - ConnectionConfig or PoolConfig, if available.\n     - If no config is available, it parses the MySQL URL string and returns the configuration parsed from the URL.\n\n   This improvement provides flexibility and ensures better configuration management for both single connections and connection pools.\n\n   **Example Usage**:\n\n   ```ts\n   const config = db.getConfig();\n   console.log(config); // Logs the current connection or pool config\n   ```\n\n3. **Version 1.0.16 Update**:\n   - This release marks the addition of the logging feature, improvements to the `getConfig` function, and several internal fixes that improve performance and stability.\n   - Version 1.0.16 includes stability enhancements related to table synchronization and handling dynamic queries for different table configurations.\n\n#### Updates & Enhancements\n\n1. **Enhanced Table Synchronization**:\n   - Improved synchronization of models with the database, including the ability to modify or add columns based on the current model schema.\n   - Logs are added for each significant change during model synchronization, including:\n     - `ðŸ› ï¸ Synchronizing model: \\`tableName\\``\n     - `ðŸ”„ Starting model synchronization...`\n\n2. **Error Handling**:\n   - Detailed error logging has been implemented across all database operations to ensure that errors are caught, logged, and handled appropriately.\n   - This allows for better traceability and quick identification of issues during execution.\n\n3. **Database Configuration**:\n   - A more flexible approach to handling configurations for database connections (single or pool-based) using either `ConnectionOptions` or `PoolOptions` as input parameters.\n   - Support for parsing MySQL URLs directly into configurations for easier management.\n\n#### Example Usage\n\n```ts\n// Logger function to log a message\nthis.dbInstance.logger_execute('ðŸ”„ Starting model synchronization...');\nthis.dbInstance.logger_execute('ðŸ› ï¸ Synchronizing model: `myTable`');\n\n// Accessing and logging database configuration\nconst config = this.dbInstance.getConfig();\nconsole.log(config); // Logs current configuration (connection or pool)\n\n// Initialize model\nMyModel.init('myDatabase.myTable', modelAttributes, dbInstance, options);\n```\n\n---\n\n#### Bug Fixes\n\n- Fixed issues with table synchronization when a column exists but doesn't match the model schema.\n- Minor improvements to logging formatting to ensure consistency across all database operations.\n\n#### Known Issues\n\n- None reported at this time.\n\n---\n"
    },
    {
      "id": 3,
      "path": "release-note/v103",
      "name": "V1.0.3",
      "folder": "Release Note",
      "content": "### Release Notes for `@dbnx/mysql` v1.0.3  \n\n#### **Release Date:**  \n\nDecember 5, 2024  \n\n---\n\n### **Initial Version - 1.0.3**\n\n#### **Key Features:**  \n\n1. **Database Connection Management:**  \n   - Seamlessly connect to MySQL databases with easy configuration.  \n   - Support for both single connection and connection pooling for optimized performance.  \n\n2. **Query Execution:**  \n   - Execute raw SQL queries with support for prepared statements to prevent SQL injection.  \n   - Parameterized queries for secure and efficient database operations.  \n\n3. **CRUD Operations:**  \n   - Built-in support for `CREATE`, `READ`, `UPDATE`, and `DELETE` (CRUD) queries using simple methods.  \n   - Flexible query methods for dynamic operations.\n\n4. **Error Handling:**  \n   - Clear and descriptive error messages for easier debugging.  \n   - Graceful connection recovery for transient errors.  \n\n5. **Async/Await Support:**  \n   - Fully asynchronous API to integrate with modern Node.js applications.  \n\n6. **Connection Pooling:**  \n   - Built-in connection pooling to handle multiple concurrent requests efficiently.  \n\n7. **Lightweight and Performant:**  \n   - Minimal overhead for high-performance database operations.  \n\n8. **Well-Documented API:**  \n   - Comprehensive method documentation for developers to quickly get started.\n\n---\n\n#### **Bug Fixes:**  \n\n- N/A (Initial Release).  \n\n---\n\n#### **Known Issues:**  \n\n- None reported as of this version.  \n\n---\n\n#### **How to Install:**  \n\n```bash\nnpm install @dbnx/mysql\n```\n\n---\n\n#### **Future Plans:**  \n\n- Add support for transaction management.  \n- Introduce query builders for enhanced usability.  \n- Provide TypeScript decorators for models in upcoming releases.  \n\n**Contributions and Feedback:**  \nWe welcome feedback, bug reports, and feature requests!  \nPlease share your thoughts on our [GitHub repository](https://github.com/SRAKIB17/dbnx-mysql).  \n\n---\n\nEnjoy seamless MySQL integration with `@dbnx/mysql`! ðŸš€\n"
    },
    {
      "id": 4,
      "path": "utilities/date-time",
      "name": "Date Time",
      "folder": "Utilities",
      "content": "\n## Functions\n\n### `mysql_datetime(date: Date | string): string`\n\nThis function takes a `Date` or `string` as input and formats it into MySQL's `DATETIME` format (`YYYY-MM-DD HH:mm:ss`).\n\n#### Parameters\n\n- `date`: A `Date` object or a string that can be parsed as a date.\n  - Example: `2024-11-24T14:30:00Z`, or `new Date()`.\n\n#### Returns\n\n- A string representing the date in MySQL `DATETIME` format: `YYYY-MM-DD HH:mm:ss`.\n\n#### Example Usage\n\n```javascript\nimport { mysql_datetime } from '@dbnx/mysql';\n\nconst date1 = mysql_datetime(new Date());\nconsole.log(date1);\n// Output: \"2024-11-24 14:30:00\"\n\nconst date2 = mysql_datetime('2024-11-24T14:30:00Z');\nconsole.log(date2);\n// Output: \"2024-11-24 14:30:00\"\n```\n\n---\n\n### `mysql_date(date: Date | string): string`\n\nThis function takes a `Date` or `string` as input and formats it into MySQL's `DATE` format (`YYYY-MM-DD`).\n\n#### Parameters\n\n- `date`: A `Date` object or a string that can be parsed as a date.\n  - Example: `2024-11-24T14:30:00Z`, or `new Date()`.\n\n#### Returns\n\n- A string representing the date in MySQL `DATE` format: `YYYY-MM-DD`.\n\n#### Example Usage\n\n```javascript\nimport { mysql_date } from '@dbnx/mysql';\n\nconst date1 = mysql_date(new Date());\nconsole.log(date1);\n// Output: \"2024-11-24\"\n\nconst date2 = mysql_date('2024-11-24T14:30:00Z');\nconsole.log(date2);\n// Output: \"2024-11-24\"\n```\n\n---\n\n### Notes\n\n- The `mysql_datetime` function ensures the date is always formatted in a consistent way, even for invalid input strings.\n- The `mysql_date` function provides a simpler date format, useful when only the date part (without time) is needed.\n"
    },
    {
      "id": 5,
      "path": "utilities/query-security-utilities",
      "name": "Query Security Utilities",
      "folder": "Utilities",
      "content": "\n---\n\n## **Function 1: `sanitize`**\n\n### **Purpose**\n\nSanitizes user input to make it safe for use in MySQL queries by escaping dangerous characters and converting `null` or `undefined` values to `NULL`.\n\n### **Usage**\n\n```typescript\nconst userInput = \"John's\"; // Untrusted user input\nconst sanitizedInput = sanitize(userInput); // Returns: 'John\\'s'\nconsole.log(sanitizedInput);\n```\n\n---\n\n## **Function 2: `escape`**\n\n### **Purpose**\n\nEscapes special characters in a string to neutralize SQL injection attempts. Handles `null`, `undefined`, `boolean`, and `number` inputs gracefully, returning safe representations for MySQL queries.\n\n### **Usage**\n\n```typescript\nconst dangerousInput = \"Robert'); DROP TABLE Students;--\";\nconst escapedValue = escape(dangerousInput);\n// Result: 'Robert\\'); DROP TABLE Students;--'\nconsole.log(escapedValue);\n```\n\n---\n\n## **Function 3: `format`**\n\n### **Purpose**\n\nFormats a query string by replacing placeholders (`?`) with sanitized and escaped values, ensuring secure parameterization of SQL queries.\n\n### **Definition**\n\n```typescript\n/**\n * Formats a query string by replacing placeholders (`?`) with escaped values.\n * @param query - The base SQL query with placeholders.\n * @param values - Array of values to replace placeholders.\n * @returns The formatted query string.\n */\nexport function format(query: string, values: any[]): string {\n    let i = 0;\n    return query.replace(/\\?/g, () => {\n        if (i >= values.length) {\n            throw new Error('Insufficient values provided for placeholders.');\n        }\n        const escapedValue = escape(values[i]);\n        i++;\n        return escapedValue;\n    });\n}\n```\n\n### **Usage**\n\n```typescript\nconst baseQuery = \"SELECT * FROM users WHERE username = ? AND status = ?\";\nconst params = [\"john_doe\", \"active\"];\nconst secureQuery = format(baseQuery, params);\n// Result: \"SELECT * FROM users WHERE username = 'john_doe' AND status = 'active'\"\nconsole.log(secureQuery);\n```\n\n---\n\n## **Enhanced Secure WHERE Clause**\n\nBuilds a secure `WHERE` clause for dynamic queries by sanitizing.\n\n```typescript\n\ndb.findAll('orders', {\n    where: sanitize('order_date BETWEEN \"2024-01-01\" AND \"2024-12-31\"'),\n    columns: ['id', 'customer_id', 'order_date'],\n});\n```\n\n---\n"
    },
    {
      "id": 6,
      "path": "examples/create-example",
      "name": "Create Example",
      "folder": "Examples",
      "content": "\n#### 1. Single Row Insert with Date Fields\n\n```typescript\n  const query = db.create('users', [{\n        id: 1,\n        name: 'John',\n        email: 'john@example.com',\n        avatar: null,\n        created_at: \"CURRENT_TIMESTAMP\"\n    }]);\nconsole.log(query.build())\n    //Output: INSERT INTO users (id, name, email, created_at) VALUES (1, 'John', 'john@example.com', CURRENT_TIMESTAMP)\n```\n\n#### 2. Multiple Row Insert with Date Fields\n\n```typescript\nconst query = db.create('users', [\n        {\n            id: 1,\n            name: 'John',\n            email: 'john@example.com'\n        },\n        {\n            id: 2,\n            name: 'Jane',\n            email: 'jane@example.com'\n        }\n]);\nconsole.log(query.build())\n//Output: INSERT INTO users (id, name, email) VALUES (1, 'John', 'john@example.com'), (2, 'Jane', 'jane@example.com')\n```\n\n#### 3. Insert with `ON DUPLICATE KEY UPDATE`\n\n```typescript\n\nconst user = db.create('users', [{\n     created_at: null,\n     username: 'dbnx',\n }], {\n     onDuplicateUpdateFields: ['name', 'email']\n }).build();\n// Output: INSERT INTO user (created_at, username) VALUES (NULL, 'dbnx') ON DUPLICATE KEY UPDATE name = VALUES(name), email = VALUES(email)      \n```\n\n#### 4. Insert with `INSERT IGNORE` to Prevent Duplicates\n\n```typescript\nconst query = db.create('users', {\n        id: 1, name: 'John', email: 'john@example.com'\n    },\n    {\n            uniqueColumn: 'id'\n}).build();\nconsole.log(query)\n// Output: INSERT IGNORE INTO users (id, name, email) VALUES (1, 'John', 'john@example.com')\n```\n"
    },
    {
      "id": 7,
      "path": "examples/find-example",
      "name": "Find Example",
      "folder": "Examples",
      "content": "## `findOne`/`findAll`\n\n### **Beginner Level**\n\n1. **Select All Rows**\n\n   ```typescript\n   db.findAll('users', {});\n   ```\n\n2. **Select Specific Columns**\n\n   ```typescript\n   db.findAll('users', { columns: ['id', 'name'] });\n   ```\n\n3. **Add a WHERE Clause**\n\n   ```typescript\n   db.findAll('users', { where: 'age > 18' });\n   ```\n\n4. **Add Sorting**\n\n   ```typescript\n   db.findAll('users', { sort: { name: 1 } });\n   ```\n\n5. **Apply DISTINCT**\n\n   ```typescript\n   db.findAll('users', { distinct: true });\n   ```\n\n6. **Apply LIMIT and OFFSET**\n\n   ```typescript\n   db.findAll('users', { limitSkip: { limit: 5, skip: 10 } });\n   ```\n\n---\n\n### **Intermediate Level**\n\n7. **Group Results**\n\n   ```typescript\n   db.findAll('sales', {\n       groupBy: ['region'],\n       aggregates: [{ SUM: 'amount', alias: 'total_sales' }],\n   });\n   ```\n\n8. **Filter with HAVING**\n\n   ```typescript\n   db.findAll('sales', {\n       groupBy: ['region'],\n       aggregates: [{ SUM: 'amount', alias: 'total_sales' }],\n       having: 'SUM(amount) > 1000',\n   });\n   ```\n\n9. **Join Two Tables**\n\n   ```typescript\n   db.findAll('orders', {\n       joins: [\n           { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n       ],\n       columns: ['orders.id', 'customers.name'],\n   });\n   ```\n\n10. **Perform Aggregations**\n\n   ```typescript\n   db.findAll('products', {\n       aggregates: [{ COUNT: '*', alias: 'total_products' }],\n   });\n   ```\n\n11. **Use Multiple Aggregates**\n\n   ```typescript\n   db.findAll('sales', {\n       aggregates: [\n           { SUM: 'amount', alias: 'total_amount' },\n           { AVG: 'amount', alias: 'average_amount' },\n       ],\n   });\n   ```\n\n12. **Multiple WHERE Conditions**\n\n   ```typescript\n   db.findAll('users', { where: 'age > 18 AND active = 1' });\n   ```\n\n---\n\n### **Advanced Level**\n\n13. **Recursive CTE**\n\n   ```typescript\n   db.findAll('categories', {\n       recursiveCTE: {\n           baseCase: 'SELECT id, parent_id FROM categories WHERE parent_id IS NULL',\n           recursiveCase: 'SELECT c.id, c.parent_id FROM categories c INNER JOIN tree t ON c.parent_id = t.id',\n           alias: 'tree',\n       },\n       columns: ['id', 'parent_id'],\n   });\n   ```\n\n14. **Join with Aggregates**\n\n   ```typescript\n   db.findAll('orders', {\n       joins: [\n           { type: 'LEFT JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n       ],\n       aggregates: [{ COUNT: 'orders.id', alias: 'order_count' }],\n       groupBy: ['customers.id'],\n   });\n   ```\n\n15. **Subqueries**\n\n   ```typescript\n   db.findAll('products', {\n       subQueries: [\n           { query: 'SELECT MAX(price) FROM products', as: 'max_price' },\n       ],\n       columns: ['id', 'name'],\n   });\n   ```\n\n16. **Using Aggregates and Joins**\n\n   ```typescript\n   db.findAll('sales', {\n       joins: [{ type: 'INNER JOIN', on: 'sales.product_id = products.id', table: 'products' }],\n       aggregates: [{ SUM: 'sales.amount', alias: 'total_sales' }],\n       groupBy: ['products.category_id'],\n   });\n   ```\n\n17. **Nested Aggregates**\n\n   ```typescript\n   db.findAll('orders', {\n       groupBy: ['customer_id'],\n       aggregates: [{ COUNT: '*', alias: 'order_count' }],\n       having: 'COUNT(*) > (SELECT AVG(order_count) FROM orders GROUP BY customer_id)',\n   });\n   ```\n\n18. **Multiple Joins**\n\n   ```typescript\n   db.findAll('orders', {\n       joins: [\n           { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n           { type: 'LEFT JOIN', on: 'orders.product_id = products.id', table: 'products' },\n       ],\n       columns: ['orders.id', 'customers.name', 'products.name'],\n   });\n   ```\n\n---\n\n### **Advanced Examples with Complex Queries**\n\n19. **Combined Aggregates and Subqueries**\n\n   ```typescript\n   db.findAll('orders', {\n       aggregates: [\n           { SUM: 'total', alias: 'total_sales' },\n           { AVG: 'total', alias: 'average_order' },\n       ],\n       subQueries: [{ query: 'SELECT COUNT(*) FROM customers', as: 'customer_count' }],\n   });\n   ```\n\n20. **Dynamic WHERE and Joins**\n\n   ```typescript\n   db.findAll('orders', {\n       where: 'status = \"completed\"',\n       joins: [\n           { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n       ],\n   });\n   ```\n\n### **21. Filtering by a Date Range**\n\n```typescript\ndb.findAll('orders', {\n    where: 'order_date BETWEEN \"2024-01-01\" AND \"2024-12-31\"',\n    columns: ['id', 'customer_id', 'order_date'],\n});\n```\n\n---\n\n### **22. Filtering with `IN` Operator**\n\n```typescript\ndb.findAll('products', {\n    where: 'category_id IN (1, 2, 3)',\n    columns: ['id', 'name', 'category_id'],\n});\n```\n\n---\n\n### **23. Joining More Than Three Tables**\n\n```typescript\ndb.findAll('orders', {\n    joins: [\n        { type: 'INNER JOIN', on: 'orders.customer_id = customers.id', table: 'customers' },\n        { type: 'LEFT JOIN', on: 'orders.product_id = products.id', table: 'products' },\n        { type: 'RIGHT JOIN', on: 'products.supplier_id = suppliers.id', table: 'suppliers' },\n    ],\n    columns: ['orders.id', 'customers.name', 'products.name', 'suppliers.name'],\n});\n```\n\n---\n\n### **24. Combining `UNION` in Subqueries**\n\n```typescript\ndb.findAll('employees', {\n    subQueries: [\n        { query: 'SELECT id, name FROM employees WHERE department_id = 1', as: 'sales_team' },\n        { query: 'SELECT id, name FROM employees WHERE department_id = 2', as: 'support_team' },\n    ],\n});\n```\n\n---\n\n### **25. Performing Window Functions (e.g., Ranking)**\n\n```typescript\ndb.findAll('employees', {\n    columns: [\n        'id', \n        'name', \n        { query: 'ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC)', as: 'rank' },\n    ],\n});\n```\n\n---\n\n### **26. Aggregating with a Custom Alias Logic**\n\n```typescript\ndb.findAll('sales', {\n    aggregates: [\n        { SUM: 'amount', alias: 'total_revenue' },\n        { MAX: 'amount', alias: 'highest_sale' },\n        { MIN: 'amount', alias: 'lowest_sale' },\n    ],\n});\n```\n\n---\n\n### **27. Joining with Multiple Conditions**\n\n```typescript\ndb.findAll('orders', {\n    joins: [\n        {\n            type: 'INNER JOIN',\n            on: 'orders.customer_id = customers.id AND orders.status = \"completed\"',\n            table: 'customers',\n        },\n    ],\n    columns: ['orders.id', 'customers.name'],\n});\n```\n\n---\n\n### **28. Including Raw SQL in `WHERE` or Joins**\n\n```typescript\ndb.findAll('products', {\n    where: 'price > (SELECT AVG(price) FROM products)',\n    columns: ['id', 'name', 'price'],\n});\n```\n\n---\n\n### **29. Using Multiple `HAVING` Conditions**\n\n```typescript\ndb.findAll('sales', {\n    groupBy: ['region'],\n    aggregates: [{ SUM: 'amount', alias: 'total_sales' }],\n    having: 'SUM(amount) > 1000 AND COUNT(*) > 10',\n});\n```\n\n---\n\n### **30. Recursive Hierarchy with Aggregates**\n\n```typescript\ndb.findAll('categories', {\n    recursiveCTE: {\n        baseCase: 'SELECT id, parent_id, name FROM categories WHERE parent_id IS NULL',\n        recursiveCase: 'SELECT c.id, c.parent_id, c.name FROM categories c INNER JOIN category_tree ct ON c.parent_id = ct.id',\n        alias: 'category_tree',\n    },\n    aggregates: [{ COUNT: 'id', alias: 'total_categories' }],\n    groupBy: ['parent_id'],\n});\n```\n\n---\n"
    },
    {
      "id": 8,
      "path": "examples/update-example",
      "name": "Update Example",
      "folder": "Examples",
      "content": "\n---\n\n### **db.update('table_name', config)**\n\nThe `db.update` function allows you to perform an update on a table with a wide range of capabilities such as conditional updates, calculations, joins, and more. Below are various examples of how to use this function effectively.\n\n---\n\n### 1. **Simple Update**\n\nThis example demonstrates updating a single column with a constant value:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 60000 },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = 60000 WHERE id = 1;\n```\n\n---\n\n### 2. **Conditional Update with CASE WHEN**\n\nUse a `CASE` expression to conditionally update the column values:\n\n```typescript\nconst query = db.update('employees', {\n    values: {\n        salary: {\n            case: [\n                { when: \"position = 'Manager'\", then: 100000 },\n                { when: \"position = 'Developer'\", then: 80000 }\n            ],\n            default: 50000\n        }\n    },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = CASE WHEN position = 'Manager' THEN 100000\n//         WHEN position = 'Developer' THEN 80000 ELSE 50000 END WHERE id = 1;\n```\n\n---\n\n### 3. **Update with Calculation**\n\nHere, we apply a calculation to increase the salary by 10%:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 'salary * 1.1' },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = salary * 1.1 WHERE id = 1;\n```\n\n---\n\n### 4. **Update with Subquery in SET**\n\nThis example demonstrates updating a column using a subquery:\n\n```typescript\nconst query = db.update('orders', {\n    values: { total_amount: '(SELECT SUM(amount) FROM order_items WHERE order_id = orders.id)' },\n    where: 'status = \"pending\"'\n}).build();\nconsole.log(query);\n// Output: UPDATE orders SET total_amount = (SELECT SUM(amount) FROM order_items WHERE order_id = orders.id) WHERE status = 'pending';\n```\n\n---\n\n### 5. **Update Multiple Columns with Different Conditions**\n\nHere, we update multiple columns, each with its own condition:\n\n```typescript\nconst query = db.update('employees', {\n    values: {\n        salary: { case: [{ when: \"position = 'Manager'\", then: 120000 }], default: 50000 },\n        department: 'HR'\n    },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = CASE WHEN position = 'Manager' THEN 120000 ELSE 50000 END, department = 'HR' WHERE id = 1;\n```\n\n---\n\n### 6. **Update with NULL Values**\n\nSet columns to `NULL` for specific fields:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 70000, phone:null },\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = 70000, phone = NULL WHERE id = 1;\n```\n\n---\n\n### 7. **Update with Default Values**\n\nHere we set certain columns to their default values:\n\n```typescript\nconst query = db.update('employees', {\n    values: { salary: 80000 },\n    defaultValues: ['address'],\n    where: 'id = 1'\n}).build();\nconsole.log(query);\n// Output: UPDATE employees SET salary = 80000, address = DEFAULT WHERE id = 1;\n```\n\n---\n\n### 8. **Update with Joins**\n\nThis example demonstrates an update with a join between two tables:\n\n```typescript\nconst query = db.update('orders', {\n    values: { status: \"'completed'\" },\n    where: 'orders.id = 1',\n    joins: [\n        { type: 'INNER JOIN', table: 'customers', on: 'orders.customer_id = customers.id' }\n    ]\n}).build();\nconsole.log(query);\n// Output: UPDATE orders INNER JOIN customers ON orders.customer_id = customers.id SET status = 'completed' WHERE orders.id = 1;\n```\n\n---\n\n### 9. **Update with Sorting and Limit**\n\nUpdate the rows with sorting and limiting the number of rows to be updated:\n\n```typescript\nconst query = db.update('products', {\n    values: { price: 'price * 1.2' },\n    where: 'stock > 0',\n    sort: { name: -1 },\n    limit: 5\n}).build();\nconsole.log(query);\n// Output: UPDATE products SET price = price * 1.2 WHERE stock > 0 ORDER BY name DESC LIMIT 5;\n```\n\n---\n\n### 10. **Update with Multiple Joins**\n\nThis example demonstrates updating a table with multiple joins and complex conditions:\n\n```typescript\nconst query = db.update('orders', {\n    values: { total_amount: 'total_amount + (SELECT SUM(price) FROM order_items WHERE order_id = orders.id)' },\n    where: 'orders.status = \"pending\"',\n    joins: [\n        { type: 'INNER JOIN', table: 'order_items', on: 'orders.id = order_items.order_id' },\n        { type: 'LEFT JOIN', table: 'customers', on: 'orders.customer_id = customers.id' }\n    ]\n}).build();\nconsole.log(query);\n// Output: UPDATE orders INNER JOIN order_items ON orders.id = order_items.order_id LEFT JOIN customers ON orders.customer_id = customers.id\n//         SET total_amount = total_amount + (SELECT SUM(price) FROM order_items WHERE order_id = orders.id)\n//         WHERE orders.status = 'pending';\n```\n\n---\n"
    },
    {
      "id": 9,
      "path": "examples/delete-example",
      "name": "Delete Example",
      "folder": "Examples",
      "content": "### Delete Query Documentation Example for `db.delete()`\n\n---\n\n### 1. **Simple DELETE with WHERE Condition**\n\nDelete rows from the `employees` table where the `age` is greater than 60:\n\n```typescript\nconst result = await db.delete('employees', {\n    where: 'age > 60',\n    limit: 10\n}).build();\nconsole.log(result);\n// Output: DELETE FROM employees WHERE age > 60 LIMIT 10;\n```\n\n### 2. **DELETE with INNER JOIN**\n\nDelete rows from the `orders` table where the `status` is \"pending\" and join with the `customers` table based on the `customer_id`:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"pending\"',\n    joins: [\n        { type: 'INNER JOIN', table: 'customers', on: 'orders.customer_id = customers.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders INNER JOIN customers ON orders.customer_id = customers.id WHERE status = \"pending\";\n```\n\n### 3. **DELETE with LEFT JOIN**\n\nDelete rows from the `products` table where the `price` is lower than 100, while joining with the `categories` table using a `LEFT JOIN`:\n\n```typescript\nconst result = await db.delete('products', {\n    where: 'price < 100',\n    joins: [\n        { type: 'LEFT JOIN', table: 'categories', on: 'products.category_id = categories.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM products LEFT JOIN categories ON products.category_id = categories.id WHERE price < 100;\n```\n\n### 4. **DELETE with Sorting**\n\nDelete rows from the `orders` table where the `status` is \"shipped\" and sort the rows by `order_date` in descending order:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"shipped\"',\n    sort: { order_date: -1 }\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders WHERE status = \"shipped\" ORDER BY order_date DESC;\n```\n\n### 5. **DELETE with LIMIT**\n\nDelete only 5 rows from the `products` table where the `stock` is 0:\n\n```typescript\nconst result = await db.delete('products', {\n    where: 'stock = 0',\n    limit: 5\n}).build();\nconsole.log(result);\n// Output: DELETE FROM products WHERE stock = 0 LIMIT 5;\n```\n\n### 6. **DELETE with Multiple Joins**\n\nDelete rows from the `orders` table where the `status` is \"pending\", and join with both `customers` and `products` tables:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"pending\"',\n    joins: [\n        { type: 'INNER JOIN', table: 'customers', on: 'orders.customer_id = customers.id' },\n        { type: 'LEFT JOIN', table: 'products', on: 'orders.product_id = products.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders INNER JOIN customers ON orders.customer_id = customers.id LEFT JOIN products ON orders.product_id = products.id WHERE status = \"pending\";\n```\n\n### 7. **DELETE with WHERE, Sorting, and LIMIT**\n\nDelete rows from the `employees` table where the `position` is \"Intern\", sort by `hire_date` ascending, and limit to 10 rows:\n\n```typescript\nconst result = await db.delete('employees', {\n    where: 'position = \"Intern\"',\n    sort: { hire_date: 1 },\n    limit: 10\n}).build();\nconsole.log(result);\n// Output: DELETE FROM employees WHERE position = \"Intern\" ORDER BY hire_date ASC LIMIT 10;\n```\n\n### 8. **DELETE with WHERE and Complex Join**\n\nDelete rows from the `employees` table where the `salary` is greater than 50000, and join with `departments` and `projects` tables:\n\n```typescript\nconst result = await db.delete('employees', {\n    where: 'salary > 50000',\n    joins: [\n        { type: 'INNER JOIN', table: 'departments', on: 'employees.department_id = departments.id' },\n        { type: 'LEFT JOIN', table: 'projects', on: 'employees.project_id = projects.id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM employees INNER JOIN departments ON employees.department_id = departments.id LEFT JOIN projects ON employees.project_id = projects.id WHERE salary > 50000;\n```\n\n### 9. **DELETE with RIGHT JOIN**\n\nDelete rows from the `orders` table where the `status` is \"cancelled\", and use a `RIGHT JOIN` with the `payments` table to identify orders with no payment:\n\n```typescript\nconst result = await db.delete('orders', {\n    where: 'status = \"cancelled\"',\n    joins: [\n        { type: 'RIGHT JOIN', table: 'payments', on: 'orders.id = payments.order_id' }\n    ]\n}).build();\nconsole.log(result);\n// Output: DELETE FROM orders RIGHT JOIN payments ON orders.id = payments.order_id WHERE status = \"cancelled\";\n```\n\n### 10. **DELETE with Multiple Sorting Criteria**\n\nDelete rows from the `products` table where `stock` is less than 10, and sort by `price` in ascending order and `name` in descending order:\n\n```typescript\nconst result = await db.delete('products', {\n    where: 'stock < 10',\n    sort: { price: 1, name: -1 }\n}).build();\nconsole.log(result);\n// Output: DELETE FROM products WHERE stock < 10 ORDER BY price ASC, name DESC;\n```\n\n---\n\n### Notes\n\n- `where`: The condition for deleting rows (e.g., `age > 60` or `status = \"pending\"`).\n- `joins`: Array of JOIN operations for filtering data during deletion.\n- `limit`: The number of rows to delete.\n- `sort`: Sorting criteria to order the rows for deletion.\n- `table`: The name of the table from which rows will be deleted.\n"
    },
    {
      "id": 10,
      "path": "getting-started/installation",
      "name": "Installation",
      "folder": "Getting Started",
      "content": "\n---\n\n### 1. **Installation**\n\nUse `npm` or `yarn` to install the `@dbnx/mysql` package:\n\n#### Pre-require\n\nInstall **mysql2**\n\n```bash\nnpm i mysql2\n```\n\n#### Install with npm\n\n```bash\nnpm install @dbnx/mysql\n```\n\n#### Install with yarn\n\n```bash\nyarn add @dbnx/mysql\n```\n\n---\n\n### 2. **Setup and Configuration**\n\n#### Import and Initialize\n\nAfter installation, you can import the package and initialize a database connection.\n\n```typescript\nimport { DBnx } from '@dbnx/mysql';\n\n// Database connection configuration\nconst dbConfig = {\n    host: \"localhost\",\n    user: \"your-username\",\n    password: \"your-password\",\n    database: \"your-database-name\"\n};\n\n// Create a DB instance\nconst dbInstance = new DBnx(dbConfig);\n\n// Test connection\n(async () => {\n    try {\n        await dbInstance.connect();\n        console.log(\"Database connected successfully!\");\n    } catch (error) {\n        console.error(\"Failed to connect to the database:\", error);\n    }\n})();\n```\n\n---\n\n### 3. **Usage Examples**\n\n#### Execute Raw SQL Query\n\n```typescript\n(async () => {\n    const result = await dbInstance.execute(\"SELECT * FROM users WHERE age > ?\", [25]);\n    console.log(\"Query Result:\", result);\n})();\n```\n\n#### Use Prepared Statements\n\n```typescript\n(async () => {\n    const userId = 1;\n    const user = await dbInstance.execute(\"SELECT * FROM users WHERE id = ?\", [userId]);\n    console.log(\"User Data:\", user);\n})();\n```\n\n#### Insert Data\n\n```typescript\n(async () => {\n    const result = await dbInstance.execute(\n        \"INSERT INTO users (name, email, age) VALUES (?, ?, ?)\",\n        [\"John Doe\", \"john.doe@example.com\", 30]\n    );\n    console.log(\"Insert Result:\", result);\n})();\n```\n\n#### Update Data\n\n```typescript\n(async () => {\n    const result = await dbInstance.execute(\n        \"UPDATE users SET age = ? WHERE id = ?\",\n        [31, 1]\n    );\n    console.log(\"Update Result:\", result);\n})();\n```\n\n#### Delete Data\n\n```typescript\n(async () => {\n    const result = await dbInstance.execute(\n        \"DELETE FROM users WHERE id = ?\",\n        [1]\n    );\n    console.log(\"Delete Result:\", result);\n})();\n```\n\n---\n\n### 4. **Closing the Connection**\n\nAlways close the connection when done:\n\n```typescript\n(async () => {\n    try {\n        await dbInstance.close();\n        console.log(\"Database connection closed.\");\n    } catch (error) {\n        console.error(\"Error closing the database connection:\", error);\n    }\n})();\n```\n\n---\n\n### 5. **Additional Notes**\n\n- **Error Handling:** Use `try-catch` blocks for robust error handling.\n- **Pooling:** `@dbnx/mysql` supports connection pooling. Configure pooling in the `DBnx` instance for better performance with high traffic.\n  \n  ```typescript\n  const dbConfig = {\n      host: \"localhost\",\n      user: \"your-username\",\n      password: \"your-password\",\n      database: \"your-database-name\",\n      connectionLimit: 10 // Enable connection pooling\n  };\n  ```\n"
    },
    {
      "id": 11,
      "path": "getting-started/configuration",
      "name": "Configuration",
      "folder": "Getting Started",
      "content": "\n---\n\n### **1. Initializing DBnx:**\n\nTo use DBnx for MySQL, you need to initialize the database connection using the `DBnx` class. The connection accepts configuration options and an optional boolean to enable or disable connection pooling.\n\n#### **Initialization Example:**\n\n```typescript\nimport { DBnx } from \"@dbnx/mysql\";\n\n// Database connection configuration\nexport const db = new DBnx(\n    {\n        host: 'localhost',               // MySQL server hostname (default: 'localhost')\n        user: 'root',                    // Database username (default: 'root')\n        password: '11224455',            // Database password\n        database: 'world',               // The database name you want to connect to\n        waitForConnections: true,        // Whether to wait for connections (default: true)\n        multipleStatements: true,       // Enable multiple SQL statements per query (default: true)\n        connectionLimit: 10,             // Connection pool size (default: 10)\n        queueLimit: 0,                   // Maximum number of queued connection requests (default: 0)\n    },\n    true  // Connection pooling: `true` to enable, `false` to disable (default: true)\n);\ndb.connect((err, success) => {\n    console.log(err)\n})\n```\n\n### **Configuration Options:**\n\n- `host`: **string** â€“ The MySQL server hostname (default: `'localhost'`).\n- `user`: **string** â€“ The MySQL username (default: `'root'`).\n- `password`: **string** â€“ The password for the MySQL user.\n- `database`: **string** â€“ The name of the database to use.\n- `waitForConnections`: **boolean** â€“ Whether to wait for a connection when the pool is full (default: `true`).\n- `multipleStatements`: **boolean** â€“ Whether to allow multiple SQL statements in a query (default: `true`).\n- `connectionLimit`: **number** â€“ The maximum number of connections in the pool (default: `10`).\n- `queueLimit`: **number** â€“ The maximum number of queued connection requests (default: `0` â€“ no limit).\n\n#### **Connection Pooling:**\n\nWhen initializing `DBnx`, you can enable connection pooling by passing `true` as the second argument in the constructor. Connection pooling allows efficient handling of multiple concurrent database connections by reusing connections instead of creating new ones every time.\n\n- `true` â€“ Use connection pooling (default behavior).\n- `false` â€“ Disable connection pooling.\n\n---\n\n### **Connecting with a MySQL URL:**\n\nA MySQL connection URL typically follows this format:\n\n```bash\nmysql://user:password@host:port/database\n```\n\nWhere:\n\n- `user`: The username for MySQL\n- `password`: The password for MySQL\n- `host`: The MySQL server hostname or IP address\n- `port`: The MySQL port (default is `3306`)\n- `database`: The name of the database to connect to\n\n### **Example with DBnx:**\n\n```typescript\nimport { DBnx } from \"@dbnx/mysql\";\n// MySQL connection URL\nconst connectionUrl = 'mysql://root:11224455@localhost:3306/world';\n// Initialize DBnx with the URL and optional connection pooling setting\nexport const db = new DBnx(connectionUrl, true); // true for pooling enabled\ndb.connect((err, success) => {\n    console.log(err)\n})\n```\n\n### **Explanation:**\n\n1. **`connectionUrl`:**  \n   The URL string `'mysql://root:11224455@localhost:3306/world'` connects to a MySQL database:\n   - `root`: Username\n   - `11224455`: Password\n   - `localhost`: Hostname of the MySQL server\n   - `3306`: Port (default MySQL port)\n   - `world`: Database name\n\n2. **Initializing DBnx with Connection URL:**\n   You pass the URL directly to the `DBnx` constructor. The second argument `true` is used to enable connection pooling. If you do not need pooling, you can pass `false` or omit it entirely.\n\n3. **Making Queries:**  \n   After initializing the connection, you can use `db.execute()` to run SQL queries. In the example, we are fetching all rows from the `users` table.\n\n---\n\n### **2. Defining Models:**\n\nDBnx provides a way to define models for database tables using the `Model` class. The models are used to define the structure of your tables, including fields, data types, and relationships.\n\n#### **Model Definition Example:**\n\n```typescript\nimport { Model } from \"@dbnx/mysql\";\nimport { db } from \"./server\";  // Import the initialized DB handler\n\n// Defining a 'User' model\nconst User = db.define('User', {\n    username: {\n        type: \"VARCHAR(50)\",          // The type of the field\n        allowNull: false,            // Field cannot be NULL\n        defaultValue: null,          // Default value if no value is provided\n        unique: true,                // Ensures this field is unique\n    },\n    created_at: {\n        type: \"TIMESTAMP\",           // The type of the field\n        defaultValue: \"CURRENT_TIMESTAMP\", // Default value of the field\n    },\n},{\n    //table options\n});\n\n// Defining a 'Product' model\nconst Product = Model.init('Product', {\n    product_id: {\n        type: \"BIGINT\",              // Data type for product_id\n        autoIncrement: true,        // Auto-increment the product ID\n        primaryKey: true,           // Marks this field as the primary key\n        unique: true,               // Ensures uniqueness of product_id\n    },\n\n    title: {\n        type: \"VARCHAR(255)\",        // Title of the product\n        defaultValue: null,          // Default value for title\n    },\n\n    created_at: {\n        type: \"TIMESTAMP\",           // Timestamp when the product is created\n        defaultValue: \"CURRENT_TIMESTAMP\", // Default value of the field\n    },\n\n    updated_at: {\n        type: 'TIMESTAMP',           // Timestamp when the product was last updated\n        allowNull: false,            // This field cannot be null\n        defaultValue: 'CURRENT_TIMESTAMP', // Default value\n        onUpdate: 'CURRENT_TIMESTAMP' // Automatically update the field on record change\n    }\n}, db,{\n    //options\n});\n```\n\n#### options\n\n```typescript\nexport type TableOptions = {\n    engine?: Engine;\n    charset?: Charset;\n    collation?: Collation;\n    auto_increment?: number; // default 1 , if you pass number value then start from input number.\n};\n```\n\n### **Model Methods:**\n\n1. **`db.define()`** â€“ Defines a new model/table within the database. The first argument is the name of the table, and the second argument is an object with field definitions.\n2. **`Model.init()`** â€“ Initializes an existing model with a given structure and attaches it to the `dbHandler`.\n\n### **Field Properties:**\n\nEach field in a model can have the following properties:\n\n- `type`: **string** â€“ The SQL data type (e.g., `VARCHAR`, `TIMESTAMP`, `BIGINT`).\n- `defaultValue`: **any** â€“ The default value for the field.\n- `allowNull`: **boolean** â€“ Whether the field allows `NULL` values (default is `true`).\n- `unique`: **boolean** â€“ Ensures that the field contains unique values.\n- `primaryKey`: **boolean** â€“ Marks the field as the primary key for the table.\n- `autoIncrement`: **boolean** â€“ Auto-increments the field's value, commonly used for primary keys.\n- `references`: **string** â€“ Specifies a foreign key reference to another table.\n- `onUpdate`: **string** â€“ Specifies how the field should update (commonly used with `TIMESTAMP`).\n\n---\n\n### **3. Query Execution with DBnx:**\n\nYou can use the `query` method to execute raw SQL queries against the connected database.\n\n```typescript\nconst fetchData = async () => {\n    try {\n        const result = await db.execute('SELECT * FROM users');\n        console.log(result);  // Logs the result of the query\n    } catch (error) {\n        console.error('Error fetching data:', error);\n    }\n};\n\nfetchData();\n```\n\n- The `execute` method accepts an SQL string and returns the result of the query.\n\n---\n\n### **4. Summary of Key Features:**\n\n- **Connection Pooling**: Automatically managed and easily configurable for efficient connection management.\n- **Model Definition**: Use `define()` or `init()` to define database models with strong type checking.\n- **Customizable Field Definitions**: Set field types, constraints, default values, and relationships.\n- **Advanced Query Support**: Execute raw SQL queries directly using `execute()` for more control.\n\n---\n"
    },
    {
      "id": 12,
      "path": "getting-started/logger-function",
      "name": "Logger Function",
      "folder": "Getting Started",
      "content": "\n---\n\n#### **Constructor**\n\nThe constructor initializes the database connection with flexible options to suit various configurations. It supports the following signatures:\n\n```typescript\nconstructor(dbConfig: ConnectionOptions | PoolOptions | string, usePool?: boolean, logger?: (log: any) => void)\nconstructor(dbConfig: ConnectionOptions | PoolOptions | string, logger?: (log: any) => void)\nconstructor(dbConfig: ConnectionOptions | PoolOptions | string)\n```\n\n- **Parameters**:\n  1. **`dbConfig`** (`ConnectionOptions | PoolOptions | string`)  \n     - Configuration options for the database. Can be:\n       - An object containing MySQL connection or pool options.\n       - A connection URL string (e.g., `\"mysql://user:pass@host/db\"`).\n  2. **`usePool`** (`boolean`, optional)  \n     - Indicates whether to use a connection pool. Defaults to `false` if not provided.\n  3. **`logger`** (`(log: any) => void`, optional)  \n     - A callback function for logging. Useful for debugging connection events and queries.\n\n---\n\n#### **Example Usage**\n\n```typescript\nimport { DBnx } from \"@dbnx/mysql\";\n\n// Instantiate the DBnx class\nexport const db = new DBnx(\n    {\n        host: 'localhost',       // Host address\n        user: 'root',            // MySQL username\n        password: '12345678',    // Password for the user\n        database: 'world',       // Name of the database\n        waitForConnections: true, // Connection pool options\n        multipleStatements: true, // Enable multi-statement execution\n        connectionLimit: 10,     // Max number of simultaneous connections\n        queueLimit: 0,           // No limit on queued requests\n    },\n    true, // Enable connection pooling\n    (log) => console.log(log) // Logging callback\n);\n\n// Establish a connection\ndb.connect();\n```\n\n---\n\n#### **Constructor Internals**\n\nThe constructor supports dynamic argument parsing to handle the different initialization patterns:\n\n1. **`this.#logger`**:  \n   - Set to the second argument if itâ€™s a function.  \n   - Otherwise, the third argument is used.\n\n2. **`this.#usePool`**:  \n   - Set to the second argument if itâ€™s a boolean.  \n   - Defaults to `false` if not provided.\n\n3. **`this.#dbConfig`**:  \n   - Always assigned to the first argument, regardless of type.\n\n---\n\n#### **Key Features**\n\n1. **Flexible Configuration**:\n   - Accepts connection options or a MySQL connection URL string.\n\n2. **Connection Pooling**:\n   - Optional support for pooling via the `usePool` parameter.\n\n3. **Custom Logging**:\n   - Easily integrates with logging systems through the `logger` callback.\n\n4. **Dynamic Initialization**:\n   - Allows initialization with or without pooling and logging based on the provided arguments.\n\n---\n\n#### **Advanced Configurations**\n\n- **Connection URL**:\n\n  ```typescript\n  const db = new DBnx(\n      \"mysql://root:12345678@localhost/world\",\n      true, // Enable pooling\n      (log) => console.log(log)\n  );\n  ```\n\n- **Single Connection without Logging**:\n\n  ```typescript\n  const db = new DBnx({\n      host: 'localhost',\n      user: 'root',\n      password: '12345678',\n      database: 'world',\n  });\n  ```\n\n- **Single Connection with Logging**:\n\n  ```typescript\n  const db = new DBnx(\n      {\n          host: 'localhost',\n          user: 'root',\n          password: '12345678',\n          database: 'world',\n      },\n      (log) => console.log(\"Log:\", log)\n  );\n  ```\n\n---\n\n#### **Method: `connect`**\n\nEstablishes a connection to the database. Internally determines whether to initialize a single connection or a connection pool.\n\n- **Usage**:\n\n  ```typescript\n  await db.connect();\n  ```\n\n- **Behavior**:\n  - If `usePool` is `true`, initializes a connection pool.\n  - Otherwise, establishes a single connection.\n\n---\n"
    },
    {
      "id": 13,
      "path": "condition",
      "name": "Condition",
      "folder": ".",
      "content": "\n---\n\n## Importing the Function\n\n```typescript\nimport { dbnxCondition } from '@dbnx/mysql';\n\n```\n\n##### **OR**\n\n```ts\n// database.js\nimport { DBnx } from \"@dbnx/mysql\";\n\n// Creating a new instance of DBnx to handle database connections.\nexport const db = new DBnx(\n    {\n        host: 'localhost', // Database host\n        user: 'root', // Database user\n        password: '11224455', // Database password\n        database: 'world', // Database name\n        waitForConnections: true, // Allows the pool to wait for connections\n        multipleStatements: true, // Allows multiple SQL statements per query\n        connectionLimit: 10, // Maximum number of connections in the pool\n        queueLimit: 0, // Unlimited connection queue size\n    },\n    // true // Use connection pooling\n);\n\n// Connecting to the database\ndb.connect()\n    .then(() => console.log('Database connected successfully'))\n    .catch((err) => console.error('Error connecting to database:', err));\n\ndb.condition() // condition\n```\n\n### Use\n\n```ts\nconst result = await db.findOne('users', {\n    where: db.condition({name:'dbnx'})\n}).execute();\nconsole.log(result);\n```\n\n---\n\n## Function Signature\n\n```typescript\ndbnxCondition(\n  filters: FilterObject, \n  joinBy: 'AND' | 'OR' = 'AND'\n): string\n```\n\n- **`filters`**: An object specifying the conditions for query generation.\n- **`joinBy`**: Logical operator (`AND` or `OR`) used to combine top-level conditions. Defaults to `AND`.\n\n---\n\nHere is the documentation for the `dbnxCondition` function and the `Filters` type, including a detailed example:\n\n---\n\n## `Filters` Type Documentation\n\n### Type: `FilterValue`\n\nThe `FilterValue` type represents the possible values that can be used in the filters to build SQL conditions. These include:\n\n- **string | number**: Used for simple equality checks (e.g., `status = 'active'`).\n- **Array<string | number>**: Used for `IN` checks (e.g., `tags IN ('electronics', 'home')`).\n- **{ notIn: Array<string | number> }**: Used for `NOT IN` checks (e.g., `location NOT IN ('New York', 'California')`).\n- **{ in: Array<string | number> }**: Used for `IN` checks.\n- **{ between: [number, number] }**: Used for `BETWEEN` checks (e.g., `price BETWEEN 1000 AND 5000`).\n- **{ notBetween: [number, number] }**: Used for `NOT BETWEEN` checks.\n- **{ inRange: [number, number] }**: Similar to `BETWEEN` but for range checks.\n- **{ $or: FilterValue[] }**: Logical OR condition (e.g., `(color LIKE 'red' OR color LIKE 'blue')`).\n- **{ like: string }**: Used for `LIKE` operator (e.g., `title LIKE '%phone%'`).\n- **{ notLike: string }**: Used for `NOT LIKE` operator (e.g., `description NOT LIKE '%old%'`).\n- **{ isNull: boolean }**: Used for checking if a value is NULL or NOT NULL (e.g., `updatedAt IS NULL`).\n- **{ $and: FilterValue[] }**: Logical AND condition (e.g., `(category = 'electronics' AND brand = 'Samsung')`).\n- **{ regexp: string }**: Used for `REGEXP` condition (e.g., `brand REGEXP '^Samsung'`).\n- **eq**: Represents equality (e.g., `status = 'active'`).\n- **gt**: Greater than check (e.g., `price > 1000`).\n- **lt**: Less than check (e.g., `price < 5000`).\n- **gte**: Greater than or equal to check (e.g., `price >= 1000`).\n- **lte**: Less than or equal to check (e.g., `price <= 5000`).\n- **neq**: Not equal to check (e.g., `status != 'inactive'`).\n\n### Type: `Filters`\n\nThe `Filters` type represents a set of filters used to build complex SQL conditions. It can either be a set of key-value pairs representing direct column filters, or it can contain logical operators like `$and` or `$or` for combining multiple filters.\n\nExample:\n\n```typescript\ntype Filters = {\n    [key: string]: FilterValue; // For columns directly mapped to FilterValue\n} | {\n    $or?: Record<string, FilterValue>; // Logical OR condition for multiple filters\n    $and?: Record<string, FilterValue>; // Logical AND condition for multiple filters\n};\n```\n\n## `dbnxCondition` Function\n\n### Function: `dbnxCondition`\n\nGenerates SQL conditions based on the filters object. It dynamically builds the `WHERE` clause for SQL based on the provided filters and logical operations (e.g., AND, OR).\n\n#### Parameters\n\n- **filters (Filters)**: An object containing the conditions to apply in the SQL query.\n- **joinBy ('AND' | 'OR')**: A logical operator used to combine the conditions. Defaults to 'AND'.\n\n#### Returns\n\nA string representing the SQL condition that can be used in the `WHERE` clause of a query.\n\n### Example Usage\n\n```typescript\nimport { dbnxCondition, Filters } from '@dbnx/mysql';\n\n// Example filters\nconst filters: Filters = {\n    status: \"active\", // Exact match\n    price: { between: [1000, 5000] }, // BETWEEN condition\n    tags: [\"electronics\", \"home\"], // IN condition\n    location: { notIn: [\"New York\", \"California\"] }, // NOT IN condition\n    stock: { inRange: [10, 50] }, // IN RANGE condition (BETWEEN)\n    updatedAt: { isNull: true }, // IS NULL condition\n    title: { like: \"%phone%\" }, // LIKE condition (pattern matching)\n    description: { notLike: \"%old%\" }, // NOT LIKE condition\n    color: {\n        $or: [\n            { like: \"red\" },\n            { like: \"blue\" },\n        ],\n    }, // OR condition\n    $and: {\n        category: \"electronics\",\n        brand: { regexp: \"^Samsung\" }, // REGEXP condition\n    },\n};\n\n// Generate the SQL condition string\nconst sqlCondition = dbnxCondition(filters);\n\nconsole.log(sqlCondition);\n```\n\n### Output\n\n```sql\nSELECT * FROM products WHERE \n`status` = 'active' AND \n`price` BETWEEN 1000 AND 5000 AND \n`tags` IN ('electronics', 'home') AND \n`location` NOT IN ('New York', 'California') AND \n`stock` BETWEEN 10 AND 50 AND \n`updatedAt` IS NULL AND \n`title` LIKE '%phone%' AND \n`description` NOT LIKE '%old%' AND \n(\n    `color` LIKE 'red' OR \n    `color` LIKE 'blue'\n) AND \n(\n    `category` = 'electronics' AND \n    `brand` REGEXP '^Samsung'\n);\n```\n\n### Function Details\n\n1. **IN and NOT IN**: The `IN` condition checks if the value is present in a list (e.g., `tags IN ('electronics', 'home')`), and the `NOT IN` condition checks if the value is not in a list (e.g., `location NOT IN ('New York', 'California')`).\n\n2. **BETWEEN and NOT BETWEEN**: These conditions are used for range checks (e.g., `price BETWEEN 1000 AND 5000`). The `NOT BETWEEN` condition checks for values outside a specified range.\n\n3. **LIKE and NOT LIKE**: Used for pattern matching (e.g., `title LIKE '%phone%'`). The `NOT LIKE` condition checks for values that do not match the pattern.\n\n4. **Logical AND and OR**: The function supports complex logical operations. The `$and` and `$or` operators are used to group conditions into logical expressions. For example, conditions can be grouped with `AND` (e.g., `category = 'electronics' AND brand = 'Samsung'`) or `OR` (e.g., `color LIKE 'red' OR color LIKE 'blue'`).\n\n5. **REGEXP**: The `REGEXP` condition is used for regular expression matching (e.g., `brand REGEXP '^Samsung'`).\n\n### Notes\n\n- The function sanitizes all inputs to avoid SQL injection risks, ensuring that values are properly escaped.\n- You can use multiple logical operators (`$and`, `$or`) to create more complex filtering conditions.\n\n---\n"
    },
    {
      "id": 14,
      "path": "model/create-model",
      "name": "Create Model",
      "folder": "Model",
      "content": "### Dynamic Model Definition\n\n---\n\n### **1. Dependencies**\n\nThis implementation relies on the following imports:\n\n- **`DBnx`**: Database handler to execute SQL commands.\n- **`Model`**: Base class for models.\n- **`DataTypes`**: Utilities for defining column types.\n\n```ts\nimport { DBnx } from \"@dbnx/mysql\";\n\nexport const db = new DBnx(\n    {\n        host: 'localhost',\n        user: 'root',\n        password: '11224455',\n        database: 'world',\n        waitForConnections: true,\n        multipleStatements: true,\n        connectionLimit: 10,\n        queueLimit: 0,\n    },\n    // true // Use pool\n);\n\ndb.connect()\n```\n\n---\n\n### **2. Model Definition Example**\n\n#### **Product Model**\n\n```typescript\nimport { Model } from \"@dbnx/mysql\";\n\nconst Product = Model.init('product', {\n    product_id: {\n        type: \"BIGINT\",\n        autoIncrement: true,\n        primaryKey: true,\n        unique: true\n    },\n    title: {\n        type: \"VARCHAR(255)\",\n        defaultValue: null,\n    },\n    brand: {\n        type: \"VARCHAR(255)\",\n        defaultValue: 'hello',\n    },\n    created_at: {\n        type: \"TIMESTAMP\",\n        defaultValue: \"CURRENT_TIMESTAMP\",\n    },\n    updated_at: {\n        type: 'TIMESTAMP',\n        allowNull: false,\n        defaultValue: 'CURRENT_TIMESTAMP',\n        onUpdate: 'CURRENT_TIMESTAMP'\n    }\n}, db);\n```\n\n#### **Users Model**\n\n```typescript\n\nconst Users = db.define('users', {\n    username: {\n        type: DataTypes.SMALLINT(),\n        defaultValue: null,\n        unique: true,\n    },\n    city: {\n        type: DataTypes.INT(),\n        allowNull: true,\n        references: {\n            model: 'city',\n            key: 'ID',\n            onDelete: 'SET NULL',\n            onUpdate: 'CASCADE', // Update child table when parent table value changes\n        },\n    },\n    status: {\n        type: DataTypes.ENUM(),\n        values: ['active', 'inactive']\n    },\n    created_at: {\n        type: DataTypes.TIMESTAMP(),\n        onUpdate: \"CURRENT_TIMESTAMP\",\n    },\n}, {\n    auto_increment: 100,\n    charset: 'utf8mb4',\n    collation:\"utf8mb4_unicode_ci\"\n});\n```\n\n**Table Options:**\n\n```ts\ntype TableOptions = {\n    engine?: Engine;\n    charset?: Charset;\n    collation?: Collation;\n    auto_increment?: number;\n};\n```\n\n#### **Return Properties**\n\n- `ddlQuery`: SQL statement for creating the table.\n- `database`: SQL statement for creating the table.\n- `modelAttributes`: Object defining column configurations.\n- `tableOptions`: Options for the table (engine, charset, etc.).\n- `dbInstance`: Database instance to execute queries.\n- `tableName`: Name of the table in the database.\n- `dbTableIdentifier`: Name of the table identifier.\n\n---\n\n#### **Column Options**\n\n| Property         | Type                                      | Description                                                                 |\n|------------------|-------------------------------------------|-----------------------------------------------------------------------------|\n| `type`           | `string`                                  | Data type of the column (e.g., `VARCHAR`, `INT`, `TIMESTAMP`).              |\n| `modifyColumn`   | `string`                                  | To change the name of a column.                                            |\n| `onUpdate`       | `string / 'CURRENT_TIMESTAMP'`                       | For date value updated.                                            |\n| `allowNull`      | `boolean`                                 | Specifies if the column allows `NULL`.                                      |\n| `primaryKey`     | `boolean`                                 | Marks the column as the primary key.                                        |\n| `autoIncrement`  | `boolean`                                 | Enables auto-incrementing values.                                           |\n| `defaultValue`   | `string / number / \"CURRENT_TIMESTAMP\"`   | Default value for the column.                                               |\n| `references`     | `object / string`                         | Foreign key configuration (table name, key, `onDelete`, `onUpdate`).        |\n| `unique`         | `boolean`                                 | Ensures unique values in the column.                                        |\n| `values`         | `string[]`                                | Applicable for ENUM types, defines allowed values.                          |\n\n```ts\nexport type ColumnOptions = {\n    modifyColumn?: string,\n    type: string;\n    allowNull?: boolean;\n    primaryKey?: boolean;\n    autoIncrement?: boolean;\n    onUpdate?:string | \"CURRENT_TIMESTAMP\";\n    defaultValue?: string | number | \"CURRENT_TIMESTAMP\" | null;\n    references?: string | {\n        model: string | typeof Model,\n        onUpdate?: \"CASCADE\" | \"SET NULL\" | \"NO ACTION\" | \"RESTRICT\";\n        onDelete?: \"CASCADE\" | \"SET NULL\" | \"NO ACTION\" | \"RESTRICT\";\n        key: string; // Referenced column\n    };\n    unique?: boolean,\n    values?: readonly string[],\n}\n```\n\n---\n\n### **Usage Examples**\n\n#### Change column name\n\n```ts\nconst Product = Model.init('product', {\n    ...\n    ...\n    brand_name: {\n        modifyColumn: 'brand',\n        type: \"VARCHAR(255)\",\n        defaultValue: 'hello',\n    },\n    ...\n    ...\n}, db);\n```\n\nRename **`brand`** column to **`brand_name`** if exist.\n\n#### Creating a Table\n\n```typescript\nconsole.log(Product.ddlQuery); // Outputs the CREATE TABLE SQL query\nconsole.log(Product.sync()); // Outputs the CREATE TABLE SQL query\n```\n\n#### Adding Foreign Key Constraints\n\n```typescript\nconst Orders = db.define('orders', {\n    product_id: {\n        type: \"BIGINT\",\n        allowNull: false,\n        references: {\n            model: Product,\n            key: 'product_id',\n            onDelete: 'CASCADE',\n            onUpdate: 'CASCADE',\n        },\n    },\n});\n```\n\n**or**:\n\n```typescript\nconst Orders = db.define('orders', {\n    product_id: {\n        type: \"BIGINT\",\n        allowNull: false,\n        references: {\n            model: 'product',\n            key: 'product_id',\n            onDelete: 'CASCADE',\n            onUpdate: 'CASCADE',\n        },\n    },\n});\n```\n\nHere are examples demonstrating how to use the `Model` class for **creating**, **deleting**, **updating**, and **finding** records.\n\n---\n\n### 1. **Create**\n\nTo create a new record in the database:\n\n#### Example\n\n```typescript\n\n(async () => {\n    const result = await Users.create({\n        name: \"John Doe\",\n        email: \"john.doe@example.com\",\n        age: 30\n    });\n    console.log(\"Record created:\", result);\n})();\n```\n\n---\n\n### 2. **Find All**\n\nTo retrieve multiple records from the database:\n\n#### Example\n\n```typescript\n\n(async () => {\n    const records = await Users.findAll({\n        limitSkip: { limit: 10, skip: 0 } \n    });\n    console.log(\"Found records:\", records);\n})();\n```\n\n---\n\n### 3. **Find One**\n\nTo retrieve a single record:\n\n#### Example\n\n```typescript\n\n(async () => {\n    const record = await Users.findOne();\n    console.log(\"Single record found:\", record);\n})();\n```\n\n---\n\n### 4. **Update**\n\nTo update an existing record in the database:\n\n#### Example\n\n```typescript\nimport { Model } from './model';\n\n(async () => {\n    const result = await Model.update({\n        where: `email = \"john.doe@example.com\"`, // Condition to identify the record\n        values: { age: 31 } // Fields to update\n    });\n    console.log(\"Record updated:\", result);\n})();\n```\n\n---\n\n### 5. **Delete**\n\nTo delete a record from the database:\n\n#### Example\n\n```typescript\nimport { Model } from './model';\n\n(async () => {\n    const result = await Model.delete({\n        where: `email = \"john.doe@example.com\"` // Condition to identify the record to delete\n    });\n    console.log(\"Record deleted:\", result);\n})();\n```\n\n---\n\n#### Retrieving Engine Options\n\n```typescript\nconsole.log(ModelDefine.getEngineOptions());\n// Outputs table options like ENGINE, CHARSET, and COLLATION\n```\n\n---\n"
    },
    {
      "id": 15,
      "path": "model/datatypes",
      "name": "DataTypes",
      "folder": "Model",
      "content": "\n---\n\n### **Defining Models**\n\nUse the `db.define()` method to define a model. Specify the table structure, data types, and constraints in an intuitive manner.\n\n```javascript\nconst { DBnx, DataTypes } = require('@dbnx/mysql');\nexport const db = new DBnx(\n    {\n        host: 'localhost',\n        user: 'root',\n        password: '11224455',\n        database: 'world',\n        waitForConnections: true,\n        multipleStatements: true,\n        connectionLimit: 10,\n        queueLimit: 0,\n    },\n    // true // Use pool\n);\n\ndb.connect()\n\nconst Users = db.define('users', {\n    username: {\n        type: DataTypes.STRING(150),\n        unique: true,\n        allowNull: false,\n        defaultValue: null,\n    },\n    city: {\n        type: DataTypes.INT(),\n        allowNull: true,\n        references: {\n            model: 'city',\n            key: 'ID',\n            onDelete: 'SET NULL',\n            onUpdate: 'CASCADE',\n        },\n    },\n    status: {\n        type: DataTypes.ENUM('active', 'inactive'),\n        defaultValue: 'inactive',\n    },\n    created_at: {\n        type: DataTypes.TIMESTAMP(),\n        onUpdate: 'CURRENT_TIMESTAMP',\n    },\n});\n```\n\n---\n\n### **DataTypes**\n\nThe `DataTypes` object provides a set of predefined methods for defining column types. Each method generates the appropriate SQL type.\n\n#### **String Types**\n\n- **`STRING(size = 250)`**: Variable-length string (`VARCHAR`).  \n  Example: `DataTypes.STRING(100)` -> `VARCHAR(100)`\n  \n- **`CHAR(size = 35)`**: Fixed-length string (`CHAR`).  \n  Example: `DataTypes.CHAR(10)` -> `CHAR(10)`\n\n- **`TEXT(type = 'TEXT')`**: Large text field.  \n  Options: `TINYTEXT`, `TEXT`, `MEDIUMTEXT`, `LONGTEXT`.  \n  Example: `DataTypes.TEXT('MEDIUMTEXT')`\n\n#### **Numeric Types**\n\n- **`TINYINT(unsigned = false)`**: Tiny integer.  \n  Example: `DataTypes.TINYINT(true)` -> `TINYINT UNSIGNED`\n  \n- **`SMALLINT(unsigned = false)`**: Small integer.  \n  Example: `DataTypes.SMALLINT()` -> `SMALLINT`\n  \n- **`INT(unsigned = false)`**: Standard integer.  \n  Example: `DataTypes.INT(true)` -> `INT UNSIGNED`\n  \n- **`BIGINT(unsigned = false)`**: Large integer.  \n  Example: `DataTypes.BIGINT()` -> `BIGINT`\n\n- **`DECIMAL(precision = 10, scale = 0)`**: Fixed-point decimal.  \n  Example: `DataTypes.DECIMAL(12, 4)` -> `DECIMAL(12, 4)`\n\nData types in `@dbnx/mysql` mirror MySQL column types, making schema design intuitive. Below are the supported types and options:\n\n| **Type**        | **Description**                                                                                           | **Example**                        |\n|------------------|-----------------------------------------------------------------------------------------------------------|------------------------------------|\n| `STRING(size)`   | Variable-length string (`VARCHAR`). Default size: 250.                                                   | `DataTypes.STRING(150)`           |\n| `CHAR(size)`     | Fixed-length string. Default size: 35.                                                                   | `DataTypes.CHAR(20)`              |\n| `TEXT(type)`     | Large text field. `type`: `TINYTEXT`, `TEXT`, `MEDIUMTEXT`, `LONGTEXT`.                                   | `DataTypes.TEXT('LONGTEXT')`      |\n| `INT(unsigned)`  | Integer. Add `true` for unsigned.                                                                        | `DataTypes.INT(true)`             |\n| `DECIMAL(p, s)`  | Fixed-point decimal with precision `p` and scale `s`. Default: `(10, 0)`.                                | `DataTypes.DECIMAL(12, 4)`        |\n| `TIMESTAMP()`    | Timestamp with optional auto-update.                                                                     | `DataTypes.TIMESTAMP()`           |\n| `ENUM(values)`   | Enum with specific values.                                                                               | `DataTypes.ENUM('active', 'inactive')` |\n| `BLOB(type)`     | Binary large object. `type`: `TINYBLOB`, `BLOB`, `MEDIUMBLOB`, `LONGBLOB`.                                | `DataTypes.BLOB('LONGBLOB')`      |\n| `JSON()`         | JSON-formatted data field.                                                                               | `DataTypes.JSON()`                |\n\n---\n\n#### **Date & Time Types**\n\n- **`TIMESTAMP()`**: Timestamp with optional auto-update.  \n  Example: `DataTypes.TIMESTAMP()` -> `TIMESTAMP`\n\n- **`DATE()`**: Stores dates without time.  \n  Example: `DataTypes.DATE()` -> `DATE`\n\n#### **Enumerations**\n\n- **`ENUM()`**: Enum type with specific values.  \n  Example: `DataTypes.ENUM()` -> `ENUM`\n\n#### **Binary Types**\n\n- **`BINARY(size = 16)`**: Fixed-length binary data.  \n  Example: `DataTypes.BINARY(32)` -> `BINARY(32)`\n\n- **`VARBINARY(size = 255)`**: Variable-length binary data.  \n  Example: `DataTypes.VARBINARY(100)` -> `VARBINARY(100)`\n\n- **`BLOB(type = 'BLOB')`**: Binary large object.  \n  Options: `TINYBLOB`, `BLOB`, `MEDIUMBLOB`, `LONGBLOB`.  \n  Example: `DataTypes.BLOB('LONGBLOB')`\n\n#### **JSON**\n\n- **`JSON()`**: Stores JSON-formatted data.  \n  Example: `DataTypes.JSON()` -> `JSON`\n\n---\n\n### **Advanced Features**\n\n#### **Relationships**\n\nDefine relationships using the `references` field for foreign keys:\n\n```javascript\ncity: {\n    type: DataTypes.INT(),\n    references: {\n        model: 'city',\n        key: 'ID',\n        onDelete: 'SET NULL',\n        onUpdate: 'CASCADE',\n    },\n}\n```\n\n#### **Default Values**\n\nSet default values directly in the model:\n\n```javascript\nstatus: {\n    type: DataTypes.ENUM(),\n    values: ['active', 'inactive'],\n    defaultValue: 'inactive',\n}\n```\n\n---\n\n### **Example: CRUD Operations**\n\nHereâ€™s an example workflow:\n\n#### Create a User\n\n```javascript\nawait Users.create({\n    username: 'john_doe',\n    city: 1,\n    status: 'active',\n});\n```\n\n#### Find Users\n\n```javascript\nconst allUsers = await Users.findAll();\n```\n\n#### Update a User\n\n```javascript\nUsers.update({\n    values:{ \n        status: 'inactive' \n    },\n    where: \"username = 'john_doe'\"\n})\n```\n\n#### Delete a User\n\n```javascript\nawait Users.delete({\n     where: `username = 'john_doe'`  \n     });\n```\n\n---\n\n---\n"
    },
    {
      "id": 16,
      "path": "model/synchronize-database-model",
      "name": "Synchronize Database Model",
      "folder": "Model",
      "content": "\n---\n\n## **SYNC Database Model Documentation**\n\nThis setup helps in managing your database connection and table synchronization using raw SQL queries in a Node.js application. Below is the structure of the code, explaining the role of each file.\n\n---\n\n### **1. `database.js` (Database Connection Class)**\n\nThis file establishes the connection to the MySQL database using the `mysql2` driver.\n\n#### **Code:**\n\n```javascript\n// database.js\nimport { DBnx } from \"@dbnx/mysql\";\n\n// Creating a new instance of DBnx to handle database connections.\nexport const db = new DBnx(\n    {\n        host: 'localhost', // Database host\n        user: 'root', // Database user\n        password: '11224455', // Database password\n        database: 'world', // Database name\n        waitForConnections: true, // Allows the pool to wait for connections\n        multipleStatements: true, // Allows multiple SQL statements per query\n        connectionLimit: 10, // Maximum number of connections in the pool\n        queueLimit: 0, // Unlimited connection queue size\n    },\n    // true // Use connection pooling\n);\n\n// Connecting to the database\ndb.connect()\n    .then(() => console.log('Database connected successfully'))\n    .catch((err) => console.error('Error connecting to database:', err));\n```\n\n#### **Parameters:**\n\n- **`host`**: The host where the database is located (e.g., `localhost` or remote server).\n- **`user`**: The MySQL user for authentication.\n- **`password`**: The password for the MySQL user.\n- **`database`**: The name of the database to connect to.\n- **`waitForConnections`**: Whether to wait for connections to become available if the pool is full.\n- **`multipleStatements`**: Enables or disables executing multiple SQL statements in a single query.\n- **`connectionLimit`**: The maximum number of connections in the connection pool.\n- **`queueLimit`**: The maximum number of queued connection requests.\n\n#### **Methods:**\n\n- **`db.connect()`**: Connects to the database.\n- **`db.close()`**: Closes the database connection.\n\n---\n\n### **2. `models.js` (SQL Queries to Create Tables)**\n\nIn this file, you define models for your tables using raw SQL. These models serve as the foundation for your database schema.\n\n#### **Code:**\n\n```javascript\n// models.js\nimport { db } from \"./database.js\";\n\n// Defining the UserModel to represent the 'users' table\nexport const UserModel = db.define('users', {\n    username: {\n        defaultValue: null, \n        type: \"VARCHAR(50)\",  // Data type for the username column\n        allowNull: false,    // Ensure that this field cannot be null\n        unique: true,        // Ensure that the username is unique\n    },\n    code: {\n        type: \"char(3)\",    // A character field of length 3\n        allowNull: true,    // Allows null values for the code column\n    },\n    created_at: {\n        type: \"TIMESTAMP\",  // Type for the timestamp column\n        defaultValue: \"CURRENT_TIMESTAMP\",  // Automatically set the current timestamp\n    },\n});\n```\n\n#### **Parameters for each field:**\n\n- **`type`**: Defines the MySQL data type (e.g., `VARCHAR`, `INT`, `TIMESTAMP`).\n- **`allowNull`**: Specifies whether the column can accept `null` values.\n- **`defaultValue`**: Sets a default value for the column if no value is provided.\n- **`unique`**: Ensures that all values in this column are unique.\n- **`references`**: Used for foreign key references (optional).\n\n---\n\n### **3. `syncDatabase.js` (Sync Logic)**\n\nThis file synchronizes the database, creating tables if they donâ€™t exist. If needed, it can also drop existing tables and recreate them (using `force`).\n\n#### **Code (Basic Sync):**\n\n```javascript\n// syncDatabase.js\nimport { UserModel, PostModel } from './models.js'; // Import models\n\nasync function syncDatabase() {\n    try {\n        // Synchronize the UserModel and PostModel (create tables if they don't exist)\n        const user = await UserModel.sync(); // Sync user table\n        const post = await PostModel.sync(); // Sync post table\n        console.log('Database synchronized successfully.');\n    } catch (error) {\n        console.error('Error syncing database:', error);\n    } finally {\n        await db.close(); // Close the database connection after syncing\n    }\n}\n\n// Call the sync function to initiate the process\nsyncDatabase();\n```\n\n#### **Syncing Process:**\n\n- **`UserModel.sync()`**: Synchronizes the `users` table based on the `UserModel` schema. If the table doesnâ€™t exist, it will be created.\n- **`PostModel.sync()`**: Synchronizes the `posts` table similarly.\n\n#### **Methods:**\n\n- **`sync()`**: Creates or updates the table schema.\n  - **With `force: true`**: Drops the existing table and recreates it.\n  - **Without `force`**: Only creates the table if it doesnâ€™t exist.\n  \n#### **Code (With Force Sync):**\n\n```javascript\n// syncDatabase.js\nimport { UserModel, PostModel } from './models.js'; // Import models\n\nasync function syncDatabase() {\n    try {\n        // Force sync: Drop and recreate the tables if they already exist\n        const user = await UserModel.sync(true); // Drop and recreate the user table\n        const post = await PostModel.sync(true); // Drop and recreate the post table\n        console.log('Database synchronized successfully.');\n    } catch (error) {\n        console.error('Error syncing database:', error);\n    } finally {\n        await db.close(); // Close the database connection after syncing\n    }\n}\n\n// Call the force sync function to initiate the process\nsyncDatabase();\n```\n\n---\n\n### **Common Errors & Troubleshooting**\n\n1. **Connection Errors**: Ensure that MySQL is running, and the database credentials are correct.\n   - Check MySQL service status: `sudo systemctl status mysql`\n   - Check for firewall or permission issues preventing connections.\n\n2. **Table Already Exists**: If you run into table conflicts, use `force: true` when calling `sync()` to drop and recreate tables.\n   - Example: `await UserModel.sync(true);`\n\n3. **Type Mismatch**: Ensure that the data types specified in your models (e.g., `VARCHAR(50)`, `TIMESTAMP`) match the database constraints.\n\n4. **Missing Dependencies**: Ensure that `@dbnx/mysql` is installed in your project.\n   - Install via NPM: `npm install @dbnx/mysql`\n\n---\n"
    },
    {
      "id": 17,
      "path": "crud-operations/create",
      "name": "Create",
      "folder": "CRUD Operations",
      "content": "### **Create/Insert Operation Documentation**\n\n---\n\n## **Create a Model**\n\nTo create a model, you must first initialize a `DBnx` and define the modelâ€™s schema. Below is an example of how to define a `User` model:\n\n```ts\nimport {DBnx} from '@dbnx/mysql'\n```\n\n```ts\nconst db = new DBnx(\n    {\n        host: 'localhost',\n        user: 'root',\n        password: '11224455',\n        database: 'world',\n        waitForConnections: true,\n        multipleStatements: true,\n        connectionLimit: 10,\n        queueLimit: 0,\n    },\n    // true // Use pool\n); // DEFAULT connection(false)\n\nconst User = db.define('User', {\n    username: {\n        defaultValue: null,\n        type: \"VARCHAR(50)\",\n        allowNull: false,\n        unique: true,\n    },\n    created_at: {\n        type: \"TIMESTAMP\",\n        defaultValue: \"CURRENT_TIMESTAMP\",\n    },\n});\n```\n\n---\n\n### **Directly Execute Query**\n\nTo insert data using the modelâ€™s static method `create`, the following function signature is used:\n\n```ts\nstatic async create(\n  values: CreateParamsType<[]>,\n  options?: InsertIntoOptionsType\n): Promise<ResponseType>\n```\n\n#### **Parameters**\n\n| Name      | Type                    | Description                                      |\n|-----------|-------------------------|--------------------------------------------------|\n| `values`  | `CreateParamsType<[]>`   | Data to insert into the table. Must be an object or an array of objects. |\n| `options` | `InsertIntoOptionsType`  | Optional parameters such as uniqueness constraints or conflict handling. |\n\n---\n\n## **Static Method: `create`**\n\nThe static `create` method inserts one or more records into the table associated with the model. This method allows you to handle single or multiple records efficiently.\n\n### **Signature**\n\n```ts\nstatic async create(\n  values: CreateParamsType<[]>,\n  options?: InsertIntoOptionsType\n): Promise<ResponseType>\n```\n\n- **Single row:**\n\n```ts\nvalues: { name: 'John', age: 30 }\n```\n\n- **Multiple rows:**\n\n```ts\nvalues: [\n           { name: 'Alice', age: 25 },\n           { name: 'Bob', age: 28 }\n]\n```\n\n### **Parameters**\n\n| Name      | Type                    | Description                                      |\n|-----------|-------------------------|--------------------------------------------------|\n| `values`  | `CreateParamsType<[]>`   | Data to insert into the table, either as a single object or an array of objects. |\n| `options` | `InsertIntoOptionsType`  | Optional settings such as constraints on uniqueness or behavior on duplicate keys. |\n\n### **Returns**\n\nA `Promise` that resolves to the database response, including information like the inserted row count or any errors.\n\n### **Usage Example**\n\n```ts\nconst result = await User.create(\n  { name: 'John Doe', email: 'john@example.com' },\n  { uniqueColumn: 'email' }\n);\nconsole.log(result); // Logs the database response.\n```\n\nOr:\n\n```ts\nconst result = await db.create(User,\n  { name: 'John Doe', email: 'john@example.com' },\n  { uniqueColumn: 'email' }\n);\nconsole.log(result); // Logs the response from the create operation.\n```\n\n---\n\n## **Return Query and More Functions**\n\n### **Instance Method: `create`**\n\nThe instance `create` method allows you to insert data directly into a specific table.\n\n### **Signature**\n\n```ts\ncreate(\n  table: string,\n  values: CreateParamsType<[]>,\n  options?: InsertIntoOptionsType\n): DBnx | Promise<ResponseType>\n```\n\n### **Parameters**\n\n| Name      | Type                    | Description                                      |\n|-----------|-------------------------|--------------------------------------------------|\n| `table`   | `string`                | Name of the table to insert data into.           |\n| `values`  | `CreateParamsType<[]>`   | Data to insert. Can be an object or an array of objects. |\n| `options` | `InsertIntoOptionsType`  | Optional settings like handling duplicate keys or ensuring uniqueness. |\n\n### **Returns**\n\n- **Chainable instance**: Returns the instance (`DBnx`) for chaining if the method is called without execution.\n- **Execution result**: Returns a `Promise` that resolves to the response from the database after execution.\n\n### **Usage Example**\n\n```ts\nconst result = await db.create(\n  'users',\n  { name: 'Alice', age: 30 },\n  { onDuplicateUpdateFields: ['age'] }\n).execute();\nconsole.log(result); // Logs the result after execution.\n```\n\n**See the query generated:**\n\n```ts\nconst query = await db.create(\n  'users',\n  { name: 'Alice', age: 30 },\n  { onDuplicateUpdateFields: ['age'] }\n).build();\nconsole.log(query); // Logs the raw SQL query generated.\n```\n\n---\n\n## **Options for `create`**\n\nThese options allow for greater flexibility and customization of the insert operation.\n\n| Option                     | Type                | Description                                        |\n|----------------------------|---------------------|----------------------------------------------------|\n| `uniqueColumn`             | `string | null`     | Ensures unique entries by the specified column.   |\n| `onDuplicateUpdateFields`  | `string[]`          | Fields to update in case of a duplicate key conflict. |\n\n---\n\n## **Types**\n\n### **CreateParamsType**\n\nDefines the shape of the `values` parameter. It can be either a single object or an array of objects. Each object corresponds to a record to be inserted.\n\n```ts\ntype CreateParamsType<columns extends any[]> = \n  | { [P in columns[number]]?: string[] }\n  | Record<string, string | number>\n  | { [P in columns[number]]?: string[] }[];\n```\n\n### **InsertIntoOptionsType**\n\nDefines the optional parameters for customizing the insert operation, including handling uniqueness and duplicate updates.\n\n```ts\ntype InsertIntoOptionsType = {\n  uniqueColumn?: string | null;\n  onDuplicateUpdateFields?: string[];\n};\n```\n\n---\n\n## **Common Errors & Troubleshooting**\n\nHere are some common errors you may encounter, along with possible causes and solutions:\n\n| Error Message                         | Cause                                    | Solution                                       |\n|---------------------------------------|------------------------------------------|-----------------------------------------------|\n| `Values must be a non-empty object.`  | The `values` parameter is either empty or invalid.  | Ensure `values` is a valid non-empty object or an array of objects. |\n| `Expected a table name and/or values.`| The table name or values are missing.    | Provide both a valid table name and a valid `values` object. |\n| `Duplicate entry for key 'PRIMARY'`   | Duplicate data is being inserted when a unique constraint exists. | Check if you are violating a unique key constraint. Use `onDuplicateUpdateFields` or adjust the data. |\n\n---\n\n## **Advanced Features**\n\n### **Batch Insert and Performance Optimization**\n\nYou can insert multiple rows efficiently using an array of objects. This reduces the number of queries executed and is faster for large datasets.\n\n```ts\nconst result = await db.create(\n  'users',\n  [\n    { name: 'Alice', age: 30 },\n    { name: 'Bob', age: 25 },\n    { name: 'Charlie', age: 35 }\n  ]\n).execute();\nconsole.log(result); // Logs the response after batch insertion.\n```\n\n---\n\n### **On Duplicate Key Updates**\n\nIf you want to update specific fields when encountering a duplicate key, use the `onDuplicateUpdateFields` option.\n\n```ts\nconst result = await db.create(\n  'users',\n  { name: 'John', age: 30 },\n  { onDuplicateUpdateFields: ['age'] }\n).execute();\nconsole.log(result); // Logs the result after updating the 'age' field.\n```\n\nThis option ensures that when a conflict (e.g., a unique constraint violation) occurs, the specified fields are updated instead of inserting a new record.\n\n---\n\n### **Custom Conflict Handling**\n\nYou can also customize how conflicts are handled by using the `onDuplicateUpdateFields` option. This is particularly useful when dealing with unique keys or other constraints that may lead to insertion conflicts.\n\n---\n"
    },
    {
      "id": 18,
      "path": "crud-operations/sequrity",
      "name": "Sequrity",
      "folder": "CRUD Operations",
      "content": ""
    },
    {
      "id": 19,
      "path": "crud-operations/find/findone",
      "name": "FindOne",
      "folder": "CRUD Operations/Find",
      "content": "### Developer Documentation for `findOne` Function\n\n---\n\n## **1. Overview**\n\nThe `findOne` function is designed to retrieve a single record from a database table, allowing for flexibility in defining search conditions, sorting, grouping, and performing aggregation. It supports both direct table queries and model-based queries, making it suitable for various use cases in a robust data handling layer.\n\n---\n\n## **2. `FindOneParamsType` Interface**\n\nThe `FindOneParamsType` interface defines the configuration options for the `findOne` function. It includes parameters for defining the query's filters, sorting, columns to select, and more.\n\n### **Type Breakdown**\n\n```ts\nexport interface FindOneParamsType<Tables extends string[]> {\n    distinct?: boolean;\n    sort?: SortType<Tables>;\n    columns?: {\n        [P in Tables[number]]?: string[];\n    } | { extra?: string | string[] } | string | string[];\n    groupBy?: {\n        [P in Tables[number]]?: string[];\n    } | { extra?: string | string[] } | string | string[];\n    aggregates?: Array<{\n        [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string;\n    } | { alias?: string; }>;\n    where?: string;\n    having?: string;\n    subQueries?: {\n        query: string,\n        as?: string;\n    }[];\n    joins?: JoinsType<Tables>;\n    recursiveCTE?: { baseCase: string, recursiveCase: string, alias: string };\n}\n```\n\n### **Key Parameters**\n\n1. **`distinct`**:\n   - If set to `true`, the query will return distinct results.\n\n   Example:\n\n   ```ts\n   distinct: true\n   ```\n\n2. **`sort`**:\n   - Defines the sorting for the query. Can be a column name or a record specifying sorting direction.\n\n   Example:\n\n   ```ts\n   sort: { age: 1 }  // Sort by age in ascending order\n   ```\n\n3. **`columns`**:\n   - Specifies which columns to include in the result. You can specify columns for each table or provide a string for all tables.\n\n   Example:\n\n   ```ts\n   columns: { users: ['id', 'name'] }\n   ```\n\n4. **`groupBy`**:\n   - Specifies the columns by which to group the result. Similar to the `GROUP BY` clause in SQL.\n\n   Example:\n\n   ```ts\n   groupBy: { users: ['status'] }\n   ```\n\n5. **`aggregates`**:\n   - Specifies aggregate functions (`MIN`, `MAX`, `SUM`, `COUNT`, `AVG`) to apply to columns.\n\n   Example:\n\n   ```ts\n   aggregates: [{ COUNT: 'age' }]\n   ```\n\n6. **`where`**:\n   - Defines the condition for filtering records, similar to the `WHERE` clause in SQL.\n\n   Example:\n\n   ```ts\n   where: \"status = 'active'\"\n   ```\n\n7. **`having`**:\n   - Defines the condition for filtering records after applying `GROUP BY`, similar to the `HAVING` clause in SQL.\n\n   Example:\n\n   ```ts\n   having: \"COUNT(age) > 2\"\n   ```\n\n8. **`subQueries`**:\n   - Allows for subqueries to be included in the `FROM` or `WHERE` clause.\n\n   Example:\n\n   ```ts\n   subQueries: [{ query: \"SELECT id FROM users WHERE status = 'active'\", as: 'active_users' }]\n   ```\n\n9. **`joins`**:\n   - Specifies how to join other tables in the query.\n\n   Example:\n\n   ```ts\n   joins: {\n       type: 'INNER',\n       table: 'orders',\n       on: 'users.id = orders.user_id'\n   }\n   ```\n\n10. **`recursiveCTE`**:\n    - Allows the use of recursive common table expressions (CTEs).\n\n    Example:\n\n    ```ts\n    recursiveCTE: { \n        baseCase: \"SELECT id FROM users WHERE status = 'active'\", \n        recursiveCase: \"SELECT u.id FROM users u INNER JOIN users r ON u.id = r.id\", \n        alias: \"recursion\"\n    }\n    ```\n\n---\n\n## **3. The `findOne` Function**\n\n### **Function Signatures**\n\n```ts\npublic findOne<tables extends string[]>(table: string, Config?: FindOneParamsType<tables>): DBnx;\npublic findOne<tables extends string[]>(model: typeof Model, Config?: FindOneParamsType<tables>): Promise<ResponseType>;\npublic findOne(...args: any): DBnx | Promise<ResponseType>;\n```\n\n### **How It Works**\n\nThe `findOne` function is overloaded to handle different types of input. It can work with either a table name or a model class, making it versatile for both raw SQL queries and ORM-based queries.\n\n#### **First Argument: Table Name or Model**\n\n- If the first argument is a string (the table name), the function generates a `SELECT` query for that table.\n- If the first argument is a model class, the function uses the model to determine the table and then executes the query.\n\n#### **Second Argument: Config**\n\n- The second argument is a configuration object, which contains the query parameters defined in `FindOneParamsType`. This object specifies the query filters, sorting, and other options.\n\n#### **Return Type:**\n\n- The function returns either a `DBnx` for further chaining of queries or a `Promise<ResponseType>` containing the query result.\n\n---\n\n## **4. Usage Examples**\n\n### **Basic Query**\n\n```ts\nconst result = await db.findOne('users', {\n    where: \"id = 1\"\n}).build();\nconsole.log(result);\n```\n\n**Execute**:\n\n```ts\nconst result = await db.findOne('users', {\n    where: \"id = 1\"\n}).execute();\nconsole.log(result);\n```\n\n**or use Model:**\n\n```ts\nconst result = await db.findOne(UserModel,{\n    where: \"id = 1\"\n});\nconsole.log(result);\n```\n\n**Or**:\n\n```ts\nconst result = await UserModel.findOne({\n    where: \"id = 1\"\n});\nconsole.log(result);\n```\n\n**Generated SQL Query:**\n\n```sql\nSELECT * FROM users WHERE id = 1 LIMIT 1;\n```\n\n### **Using Sorting**\n\n```ts\nconst result = await db.findOne('users', {\n    where: \"status = 'active'\",\n    sort: { name: 1 }\n}).build();\nconsole.log(result);\n```\n\n**Generated SQL Query:**\n\n```sql\nSELECT * FROM users WHERE status = 'active' ORDER BY name ASC LIMIT 1;\n```\n\n### **Using Aggregates**\n\n```ts\nconst result = await db.findOne('orders', {\n    aggregates: [{ COUNT: 'id' }],\n    where: \"status = 'completed'\"\n}).build();\nconsole.log(result);\n```\n\n**Generated SQL Query:**\n\n```sql\nSELECT COUNT(id) FROM orders WHERE status = 'completed' LIMIT 1;\n```\n\n### **Using Joins**\n\n```ts\nconst result = await db.findOne('users', {\n    joins: {\n        type: 'INNER',\n        table: 'orders',\n        on: 'users.id = orders.user_id'\n    },\n    where: \"users.status = 'active'\"\n}).build();\nconsole.log(result);\n```\n\n**Generated SQL Query:**\n\n```sql\nSELECT * FROM users INNER JOIN orders ON users.id = orders.user_id WHERE users.status = 'active' LIMIT 1;\n```\n\n### **Using Subqueries**\n\n```ts\nconst result = await db.findOne('users', {\n    subQueries: [{\n        query: \"SELECT id FROM users WHERE status = 'active'\",\n        as: 'active_users'\n    }],\n    where: \"id IN (SELECT id FROM active_users)\"\n}).build();\nconsole.log(result);\n```\n\n**Generated SQL Query:**\n\n```sql\nSELECT * FROM users WHERE id IN (SELECT id FROM users WHERE status = 'active') LIMIT 1;\n```\n\n### **Using Recursive CTEs**\n\n```ts\nconst result = await db.findOne('users', {\n    recursiveCTE: {\n        baseCase: \"SELECT id FROM users WHERE status = 'active'\",\n        recursiveCase: \"SELECT u.id FROM users u INNER JOIN users r ON u.id = r.id\",\n        alias: \"recursion\"\n    }\n}).build();\nconsole.log(result);\n```\n\n**Generated SQL Query:**\n\n```sql\nWITH recursion AS (\n    SELECT id FROM users WHERE status = 'active'\n    UNION ALL\n    SELECT u.id FROM users u INNER JOIN users r ON u.id = r.id\n)\nSELECT * FROM users WHERE id IN (SELECT id FROM recursion) LIMIT 1;\n```\n\n---\n"
    },
    {
      "id": 20,
      "path": "crud-operations/find/findall",
      "name": "FindAll",
      "folder": "CRUD Operations/Find",
      "content": "### `findAll` Method Documentation\n\n#### Description\n\nThe `findAll` method is used to retrieve data from a database table or model based on the configuration options provided. The method is overloaded to support both table names and models as the first argument.\n\n#### Method Signature\n\n```typescript\npublic findAll<tables extends string[]>(table: string, Config?: FindAllParamsType<tables>): DBnx;\npublic findAll<tables extends string[]>(model: typeof Model, Config?: FindAllParamsType<tables>): Promise<ResponseType>;\npublic findAll(...args: any): DBnx | Promise<ResponseType>;\n```\n\n#### Parameters\n\n1. **`table`**:\n   - Type: `string`\n   - Description: The name of the table from which the data is to be fetched.\n   - Required: Yes (if passing a table name as the first argument).\n\n2. **`model`**:\n   - Type: `typeof Model`\n   - Description: A Model class if you want to query using a model instead of a raw table name.\n   - Required: Yes (if passing a Model as the first argument).\n\n3. **`Config`**:\n   - Type: `FindAllParamsType<tables>`\n   - Description: An optional configuration object that customizes the query.\n   - Required: No.\n\n#### Returns\n\n- **When the first argument is a table name (`string`)**:\n  - Returns a `DBnx` instance that can be chained with additional query methods.\n  \n- **When the first argument is a Model (`typeof Model`)**:\n  - Returns a `Promise<ResponseType>`, which resolves to the query result.\n\n#### Method Flow\n\n- **Case 1: When a Table Name is Provided**\n  - If the first argument is a table name (string), the `findAll` method appends the query based on the provided configuration (e.g., filtering, sorting, etc.).\n  - The method will return an instance of `DBnx` for further query chaining.\n\n- **Case 2: When a Model is Provided**\n  - If the first argument is a Model class (an instance of `typeof Model`), the method will delegate the query to the `findAll` method of that model, which will execute the query and return the results as a `Promise<ResponseType>`.\n\n#### Example Usage\n\n##### Using a Table Name\n\n```typescript\nconst handler = DBnx.findAll(\"users\", {\n  limitSkip: { limit: 10, skip: 0 },\n  sort: { name: 'ASC' },\n  columns: { users: ['id', 'name'] },\n});\n\nhandler.execute(); // Executes the query and returns the result.\n```\n\n##### Using a Model\n\n```typescript\nconst result = await User.findAll({\n  limitSkip: { limit: 5 },\n  where: \"age > 25\",\n  columns: { users: ['id', 'name', 'age'] },\n});\n\nconsole.log(result); // Result will be the fetched data based on the model query.\n```\n\n#### `FindAllParamsType` Interface\n\nThe `FindAllParamsType` interface defines the available options for customizing the query.\n\n```typescript\nexport interface FindAllParamsType<Tables extends string[]> {\n  distinct?: boolean; // Whether to select distinct records.\n  sort?: SortType<Tables>; // Sorting options.\n  limitSkip?: { limit?: number; skip?: number }; // Pagination options.\n  columns?: { [P in Tables[number]]?: string[] } | { extra?: string | string[] } | string | string[]; // Columns to retrieve.\n  groupBy?: { [P in Tables[number]]?: string[] } | { extra?: string | string[] } | string | string[]; // Grouping options.\n  aggregates?: Array<{ [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string; } | { alias?: string; }>; // Aggregation functions.\n  where?: string; // WHERE clause for filtering.\n  having?: string; // HAVING clause for filtering after GROUP BY.\n  subQueries?: { query: string; as?: string }[]; // Subqueries to include.\n  joins?: JoinsType<Tables>; // JOIN conditions.\n  recursiveCTE?: { baseCase: string, recursiveCase: string, alias: string }; // Recursive Common Table Expressions.\n}\n```\n\n#### Example of `FindAllParamsType` Configuration\n\n```typescript\nconst config: FindAllParamsType<['users']> = {\n  distinct: true,\n  limitSkip: { limit: 10, skip: 0 },\n  sort: { name: 'ASC' },\n  columns: { users: ['id', 'name'] },\n  where: 'age > 25',\n  joins: [{ table: 'orders', on: 'users.id = orders.user_id' }],\n};\n\nconst handler = DBnx.findAll(\"users\", config);\nhandler.execute();\n```\n\n#### Error Handling\n\n- **Missing Arguments**: If no arguments are provided or the first argument is neither a table name nor a model, an error will be thrown:\n\n  ```typescript\n  throw new Error(\"No arguments provided to 'findAll'. Expected a table name or model.\");\n  ```\n\n- **Invalid Configuration**: If the configuration is not a valid object, an error is thrown:\n\n  ```typescript\n  throw new Error(\"Config must be a non-empty object.\");\n  ```\n\n#### Notes\n\n- This method supports chaining when working with raw table names (`DBnx` instance is returned), but resolves the results directly when working with models (`Promise<ResponseType>` is returned).\n- The `FindAllParamsType` interface allows flexible querying, including pagination, sorting, filtering, and complex joins, making the method highly versatile.\n"
    },
    {
      "id": 21,
      "path": "crud-operations/update",
      "name": "Update",
      "folder": "CRUD Operations",
      "content": "### Developer Documentation for `UpdateParamsType` and `update` Function\n\n---\n\n## **1. Overview**\n\nThe `update` function provides an easy-to-use interface for performing `UPDATE` operations in MySQL. It supports complex update scenarios, including conditional updates with `CASE` expressions, sorting, limiting, and more. This makes it highly flexible for handling a wide variety of use cases in your database management logic.\n\n---\n\n## **2. `UpdateParamsType` Type Definition**\n\n### **Basic Structure**\n\nThe `UpdateParamsType` type defines the structure of the properties (`Props`) that can be passed to the `update` function. It includes fields for setting values, conditional updates, sorting, and more.\n\n### **Type Breakdown**\n\n```ts\nexport type UpdateParamsType<Tables extends string[]> = {\n    values?: {\n        [key: string]: string | number | null | {\n            case: {\n                when: string;  // The condition in the WHEN clause\n                then: any;     // The value to set in the THEN clause\n            }[];   // The CASE structure with an array of WHEN/THEN conditions\n            default: any;       // The default value for the column when no conditions match\n        };\n    },\n    sort?: { [P in Tables[number]]?: Record<string, 1 | -1> } | Record<string, 1 | -1> | string,\n    where: string,\n    defaultValues?: string[],\n    limit?: string | number,\n    joins?: JoinsType<Tables>,\n    fromSubQuery?: Record<string, string>,\n    setCalculations?: {    // For SET calculation\n        [key: string]: string;\n    }\n};\n```\n\n### **Key Parameters**\n\n1. **`values`**:\n   - This defines the data to be updated in the database.\n   - It can either be a direct value (e.g., string, number, or `null`) or a `CASE` expression that includes conditional logic.\n\n   Example:\n\n   ```ts\n   values: {\n       age: {\n           case: [\n               { when: \"status = 'active'\", then: 30 },\n               { when: \"status = 'inactive'\", then: 25 }\n           ],\n           default: 20\n       }\n   }\n   ```\n\n   In this example, the `age` field is updated based on the `status` field's value. If the `status` is `active`, the `age` is set to `30`. If the `status` is `inactive`, the `age` is set to `25`. Otherwise, the default value `20` is used.\n\n2. **`sort`**:\n   - Specifies sorting for the update operation. It can either be a string (column name), or an object specifying sorting directions (`1` for ascending and `-1` for descending).\n\n   Example:\n\n   ```ts\n   sort: { age: 1 }\n   ```\n\n   This will sort the records by `age` in ascending order.\n\n3. **`where`**:\n   - Defines the condition for updating the records. It is similar to the `WHERE` clause in SQL.\n\n   Example:\n\n   ```ts\n   where: \"status = 'active'\"\n   ```\n\n4. **`Null Values`**:\n   - Specifies columns that should be set to `NULL` during the update.\n\n   Example:\n\n   ```ts\n   values:{\"address\":null}\n   ```\n\n5. **`defaultValues`**:\n   - Specifies columns to be updated with their default values.\n\n   Example:\n\n   ```ts\n   defaultValues: [\"email\"]\n   ```\n\n6. **`limit`**:\n   - Limits the number of records to be updated.\n\n   Example:\n\n   ```ts\n   limit: 100\n   ```\n\n7. **`joins`**:\n   - Allows for joining other tables in the `UPDATE` operation.\n\n   Example:\n\n   ```ts\n   joins: {\n       type: \"INNER\",\n       table: \"users\",\n       on: \"orders.user_id = users.id\"\n   }\n   ```\n\n8. **`fromSubQuery`**:\n   - Allows updating data from a subquery.\n\n9. **`setCalculations`**:\n   - For setting calculated values during the update.\n\n   Example:\n\n   ```ts\n   setCalculations: {\n       total_price: \"price * quantity\"\n   }\n   ```\n\n---\n\n## **3. The `update` Function**\n\n### **Function Signatures**\n\n```ts\npublic update<tables extends string[]>(table: string, Props: UpdateParamsType<tables>): DBnx;\npublic update<tables extends string[]>(model: typeof Model, Props: UpdateParamsType<tables>): Promise<ResponseType>;\npublic update(...args: any): DBnx | Promise<ResponseType>;\n```\n\n### **How It Works**\n\nThe `update` function is overloaded, meaning it can handle different types of inputs and return either a `DBnx` for chaining queries or a `Promise<ResponseType>` for immediate results.\n\n#### **First Argument: Table Name or Model**\n\n- If the first argument is a table name (string), the function generates an SQL `UPDATE` query for that table.\n- If the first argument is a model, the function uses the model to determine the table and generates an update query.\n\n#### **Second Argument: Props**\n\n- The second argument contains the update parameters defined in `UpdateParamsType`, which specify how the update should be executed.\n\n#### **Return Type:**\n\n- If used as a query builder (in a chain), it returns a `DBnx`.\n- If executed immediately, it returns a `Promise<ResponseType>` containing the result of the query.\n\n---\n\n## **4. How to Use the `update` Function**\n\n### **Basic Update**\n\n```ts\nconst query = await db.update('users', {\n    values: {\n        name: 'John Doe',\n        age: 30\n    },\n    where: \"id = 1\"\n}).build();\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE users SET name = 'John Doe', age = 30 WHERE id = 1;\n```\n\n### **Basic Update**\n\n```ts\nconst result = await db.update('users', {\n    values: {\n        name: 'John Doe',\n        age: 30\n    },\n    where: \"id = 1\"\n}).execute();\nconsole.log(result);\n```\n\n**With model**:\n\n```ts\nconst result = await db.update(UsersModel, {\n    values: {\n        name: 'John Doe',\n        age: 30\n    },\n    where: \"id = 1\"\n});\nconsole.log(result);\n```\n\n**or**:\n\n```ts\nconst result = await UsersModel.update( {\n    values: {\n        name: 'John Doe',\n        age: 30\n    },\n    where: \"id = 1\"\n});\nconsole.log(result);\n```\n\n### **Conditional Update with CASE**\n\n```ts\nconst query = await db.update('users', {\n    values: {\n        age: {\n            case: [\n                { when: \"status = 'active'\", then: 35 },\n                { when: \"status = 'inactive'\", then: 25 }\n            ],\n            default: 30\n        }\n    },\n    where: \"id = 1\"\n}).build();\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE users SET age = CASE WHEN status = 'active' THEN 35 WHEN status = 'inactive' THEN 25 ELSE 30 END WHERE id = 1;\n```\n\n### **Update with Sorting**\n\n```ts\nconst query = await db.update('users', {\n    values: {\n        status: 'active'\n    },\n    where: \"age > 18\",\n    sort: { name: 1 }\n}).build();\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE users SET status = 'active' WHERE age > 18 ORDER BY name ASC;\n```\n\n### **Using Joins in Update**\n\n```ts\nconst query = await db.update('orders', {\n    values: {\n        status: 'shipped'\n    },\n    where: \"orders.status = 'pending'\",\n    joins: {\n        type: 'INNER',\n        table: 'users',\n        on: 'orders.user_id = users.id'\n    }\n}).build();\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE orders INNER JOIN users ON orders.user_id = users.id SET status = 'shipped' WHERE orders.status = 'pending';\n```\n\n### **Using Subquery in Update**\n\n```ts\nconst query = await db.update('orders', {\n    values: {\n        status: 'shipped'\n    },\n    where: \"id IN (SELECT id FROM pending_orders)\",\n    fromSubQuery: {\n        pending_orders: \"SELECT id FROM orders WHERE status = 'pending'\"\n    }\n}).build();\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE orders SET status = 'shipped' WHERE id IN (SELECT id FROM orders WHERE status = 'pending');\n```\n\n---\n\n## **5. Advanced Use Cases**\n\n### **Handling Null Values**\n\nYou can specify which columns should be set to `NULL` during the update operation:\n\n```ts\nconst query = await db.update('users', {\n    values: {\n        name: 'Jane Doe',\n        age: 28,\n        address: null,\n    },\n    where: \"id = 2\"\n}).build();\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE users SET name = 'Jane Doe', age = 28, address = NULL WHERE id = 2;\n```\n\n### **Performing Calculations in Updates**\n\nYou can set calculated values directly in the `values`:\n\n```ts\nconst query = await db.update('orders', {\n    values: {\n        total_price: {\n            case: [\n                { when: \"quantity > 10\", then: \"price * quantity * 0.9\" },\n                { when: \"quantity <= 10\", then: \"price * quantity\" }\n            ],\n            default: \"price * quantity\"\n        }\n    },\n    where: \"id = 3\"\n}).build();\n\n\nconsole.log(query);\n```\n\n**Generated SQL Query:**\n\n```sql\nUPDATE orders SET total_price = CASE WHEN quantity > 10 THEN price * quantity * 0.9 WHEN quantity <= 10 THEN price * quantity ELSE price * quantity END WHERE id = 3;\n```\n\n---\n"
    },
    {
      "id": 22,
      "path": "crud-operations/delete",
      "name": "Delete",
      "folder": "CRUD Operations",
      "content": "\n---\n\n## **Delete Operation Documentation**\n\nThis section explains the **Delete Operation**, outlining how to delete data from a MySQL database using the `delete` helper function. This function supports customizing the deletion process with options such as **where conditions**, **joins**, **sorting**, and **limits**.\n\n---\n\n### **Setting Up the Database Handler**\n\nBefore performing delete operations, you need to configure the database handler that interacts with your MySQL database. Here's an example of how to set up the handler:\n\n```ts\nconst db = new DBnx(\n    {\n        host: 'localhost',\n        user: 'root',\n        password: '11224455',\n        database: 'world',\n        waitForConnections: true,\n        multipleStatements: true,\n        connectionLimit: 10,\n        queueLimit: 0,\n    },\n    // Use pool for better performance\n    // true\n); // Default connection is false\n\n// Define a User model with properties\nconst User = db.define('User', {\n    username: {\n        defaultValue: null,\n        type: \"VARCHAR(50)\",\n        allowNull: false,\n        unique: true,\n    },\n    created_at: {\n        type: \"TIMESTAMP\",\n        defaultValue: \"CURRENT_TIMESTAMP\",\n    },\n});\n```\n\n#### **Example Usage:**\n\n```ts\nconst query = await db.delete(\n    'users',\n    {\n        where: 'age > 30',\n        sort: { field: 'created_at', order: 'DESC' },\n        limit: 5\n    }\n).build();\nconsole.log(query); // Logs the generated DELETE SQL query\n```\n\nThis will generate the following SQL:\n\n```sql\nDELETE users FROM users WHERE age > 30 ORDER BY created_at DESC LIMIT 5;\n```\n\n#### **Customizing the Delete Operation:**\n\n1. **Where Condition**: The `where` clause is mandatory for defining which rows to delete. It is used to specify the conditions for the deletion operation (e.g., `WHERE age > 30`).\n\n2. **Joins**: The `joins` option allows you to specify SQL JOIN clauses if you need to delete data from multiple tables at once. It is passed as an object defining the tables to join.\n\nExample of a join condition:\n\n```ts\n    const query = db.delete(\n        'orders',\n        {\n            where: 'status = \"pending\"',\n            joins: {\n                type: 'INNER',\n                table: 'users',\n                on: 'orders.user_id = users.id'\n            }\n        }\n    );\n    console.log(query);\n```\n\nThis generates an SQL query with a join:\n\n```sql\n    DELETE orders FROM orders INNER JOIN users ON orders.user_id = users.id WHERE status = \"pending\";\n```\n\n**with Model**:\n\n```ts\n    const response = db.delete(\n        Orders,//this is Model of Orders\n        {\n            where: 'status = \"pending\"',\n            joins: {\n                type: 'INNER',\n                table: 'users',\n                on: 'orders.user_id = users.id'\n            }\n        }\n    );\n    console.log(response);\n```\n\n**with table**:\n\n```ts\n    const response = db.delete(\n        'orders',\n        {\n            where: 'status = \"pending\"',\n            joins: {\n                type: 'INNER',\n                table: 'users',\n                on: 'orders.user_id = users.id'\n            }\n        }\n    ).execute();\n    console.log(response);\n```\n\n1. **Limit**: The `limit` option restricts the number of rows to delete. If not specified, the operation will delete all rows matching the `where` condition.\n\n    Example with limit:\n\n```ts\n    const query = db.delete(\n        'users',\n        {\n            where: 'status = \"inactive\"',\n            limit: 10\n        }\n    );\n    console.log(query); // Deletes up to 10 rows\n```\n\nThis generates the following SQL query:\n\n```sql\n    DELETE users FROM users WHERE status = \"inactive\" LIMIT 10;\n```\n\n1. **Sorting**: The `sort` option specifies the sorting order (for example, deleting the most recent records first). This works in conjunction with the `WHERE` clause, but it's typically used for more controlled deletion strategies.\n\n    Example with sorting:\n\n```ts\nconst query = db.delete(\n    'products',\n    {\n        where: 'stock = 0',\n        sort: { field: 'created_at', order: 'ASC' }\n    }\n);\nconsole.log(query); // Deletes products in ascending order of `created_at`\n```\n\nThis generates the following SQL query:\n\n```sql\nDELETE products FROM products WHERE stock = 0 ORDER BY created_at ASC;\n```\n\n---\n\n### **Types and Definitions**\n\n#### **DeleteParamsType**\n\nDefines the shape of the parameters for the `delete` function. The `where` clause is mandatory, while `joins`, `limit`, and `sort` are optional for more advanced query configurations.\n\n```ts\nexport interface DeleteParamsType<Tables extends string[]> {\n    where: string;                    // Condition for deleting rows\n    sort?: SortType<Tables>;          // Optional sorting criteria\n    limit?: string | number;          // Optional limit for number of deleted rows\n    joins?: JoinsType<Tables>;        // Optional JOIN clauses for multi-table deletion\n}\n```\n\n#### **JoinsType**\n\nDefines the possible JOIN types (e.g., `INNER`, `LEFT`, etc.) and the associated table and ON condition.\n\n```ts\nexport type JoinsType<Tables extends string[]> = {\n    type: 'INNER' | 'LEFT' | 'RIGHT' | 'FULL';  // Type of the join\n    table: string;                             // The table to join\n    on: string;                                // The ON condition for the join\n};\n```\n\n#### **SortType**\n\nDefines sorting criteria for queries, with the field to sort by and the direction (e.g., `ASC`, `DESC`).\n\n```ts\nexport type SortType<Tables extends string[]> = {\n    field: string;  // The field to sort by\n    order: 'ASC' | 'DESC';  // Sorting direction\n};\n```\n\n---\n\n### **Best Practices for Delete Operations**\n\n1. **Always Use the WHERE Clause**: Deleting rows without a `WHERE` clause will remove all rows from the table. Ensure you always specify conditions to avoid unintended data loss.\n\n2. **Limit Deletions**: Use the `limit` option to restrict the number of rows deleted, especially in production environments where bulk deletions could affect system performance.\n\n3. **Optimize with Joins**: Use `joins` for multi-table deletion operations to ensure the deletion is properly linked across tables.\n\n4. **Test Queries First**: Always log or inspect the generated SQL query before execution to confirm it's deleting the correct data.\n\n---\n"
    },
    {
      "id": 23,
      "path": "advanced-usage/setquery",
      "name": "SetQuery",
      "folder": "Advanced Usage",
      "content": "---\n\n### `setQuery(query: string): DBnx`\n\nThe `setQuery` method allows you to overwrite the current query with a new one. It also provides useful logging to track query changes and avoid redundant updates.\n\n#### Parameters\n\n- **`query`** (`string`): The new SQL query string to be set. This query will replace the current one.\n\n#### Returns\n\n- **`DBnx`**: Returns the current instance of the class (`this`) for method chaining.\n\n#### Behavior\n\n- The method updates the internal query variable (`#query`) with the provided `query` string.\n- It logs a message indicating the query change. If the query remains the same as before, a message will indicate no change.\n- This method helps keep track of when and how queries are being set, which can be helpful for debugging or auditing purposes.\n\n#### Example Usage\n\n```typescript\n// Create an instance of DBnx\nconst logger = (message: string) => console.log(message);\nconst instance = new DBnx(logger);\n\n// Set a new query\ninstance.setQuery('SELECT * FROM users');\n\n// Set the same query again (no change will be logged)\ninstance.setQuery('SELECT * FROM users');\n\n// Set a different query\ninstance.setQuery('SELECT * FROM products');\n```\n\n#### Console Output\n\n```\nQuery set to: SELECT * FROM users\nQuery remains the same: SELECT * FROM users\nQuery set to: SELECT * FROM products\n```\n\n#### Notes\n\n- If the new query is the same as the previous query, a message indicating no change will be logged (`Query remains the same: <query>`).\n- If the query is different, the log message will indicate the new query that has been set (`Query set to: <query>`).\n  \n---\n"
    },
    {
      "id": 24,
      "path": "advanced-usage/multiple-execute-query",
      "name": "Multiple Execute Query",
      "folder": "Advanced Usage",
      "content": "\n---\n\n## **DBnx Multiple Execute Query Example with `executeQuery()`**\n\nThis documentation provides the step-by-step process of executing multiple database queries using the `DBnx` library. The following methods (`update`, `findAll`, `create`, `delete`) are chained together to execute in a single sequence.\n\n---\n\n### **1. Setup `database.js` (Database Connection Class)**\n\nThe `DBnx` instance is initialized in this file, establishing the connection with MySQL.\n\n#### **Code:**\n\n```javascript\n// database.js\nimport { DBnx } from \"@dbnx/mysql\";\n\n// Create a new DBnx instance to handle database connection.\nexport const db = new DBnx(\n    {\n        host: 'localhost',        // Database host\n        user: 'root',             // Database username\n        password: '11224455',     // Database password\n        database: 'world',        // Database name\n        waitForConnections: true, // Allow the pool to wait for a connection\n        multipleStatements: true, // Allow multiple SQL statements in one query\n        connectionLimit: 10,      // Max number of connections in the pool\n        queueLimit: 0,            // Unlimited queue size\n    },\n    // true // Enable connection pooling\n);\n\n// Connect to the database\ndb.connect()\n```\n\n---\n\n### **2. Multiple Queries with `executeQuery()`**\n\nIn this example, we'll execute the following queries sequentially using the `executeQuery()` method:\n\n1. **Update** a product's title.\n2. **Find all** products.\n3. **Create** a new product.\n4. **Find one** specific product.\n5. **Delete** a product.\n\n#### **Code:**\n\n```javascript\n// executeQueries.js\nimport { db } from './database.js';\n\nasync function executeMultipleQueries() {\n    try {\n        // Begin executing multiple queries\n        const result = await db\n            .update('product', {\n                values: {\n                    title: 'SRAKIB brand', // New title\n                },\n                where: 'product_id = 1', // Condition for the update\n            })\n            .findAll('product') // Retrieve all products\n            .create('product', {\n                title: 'test', // New product to be created\n            })\n            .findOne('product', {\n                where: 'product_id = 1', // Find one product with product_id = 1\n            })\n            .delete('product', {\n                where: 'product_id = 2', // Delete product with product_id = 2\n            })\n            .executeQuery(); // Execute all queries in sequence\n\n        console.log('Multiple queries executed successfully:', result);\n    } catch (error) {\n        console.error('Error executing multiple queries:', error);\n    } finally {\n        await db.close(); // Close the database connection after execution\n    }\n}\n\n// Call the function to execute the queries\nexecuteMultipleQueries();\n```\n\n---\n\n### **3. Breakdown of Methods**\n\nHere's an explanation of the different query methods used in the example:\n\n#### **`update(table, { values, where })`**\n\n- **Purpose**: Updates existing records in the specified table.\n- **Parameters**:\n  - **`table`**: Name of the table (e.g., `'product'`).\n  - **`values`**: An object containing the column-value pairs to update.\n  - **`where`**: The condition to match the records that need to be updated.\n\n#### **`findAll(table)`**\n\n- **Purpose**: Retrieves all records from the specified table.\n- **Parameters**:\n  - **`table`**: Name of the table (e.g., `'product'`).\n\n#### **`create(table, data)`**\n\n- **Purpose**: Inserts a new record into the specified table.\n- **Parameters**:\n  - **`table`**: Name of the table (e.g., `'product'`).\n  - **`data`**: An object containing the column-value pairs to insert.\n\n#### **`findOne(table, { where })`**\n\n- **Purpose**: Retrieves a single record from the specified table that matches the given condition.\n- **Parameters**:\n  - **`table`**: Name of the table (e.g., `'product'`).\n  - **`where`**: The condition to match the record (e.g., `'product_id = 1'`).\n\n#### **`delete(table, { where })`**\n\n- **Purpose**: Deletes a record from the specified table based on the condition.\n- **Parameters**:\n  - **`table`**: Name of the table (e.g., `'product'`).\n  - **`where`**: The condition to match the record to delete.\n\n#### **`executeQuery()`**\n\n- **Purpose**: Executes all the queued queries in sequence.\n- **Returns**: The result of the queries once executed.\n\n---\n\n### **4. Handling Errors**\n\nMake sure to handle errors properly by wrapping the entire process in a `try...catch` block. This will catch any exceptions that occur during the execution of the queries.\n\n#### **Error Handling Example:**\n\n```javascript\ntry {\n    const result = await db\n        .update('product', { values: { title: 'SRAKIB brand' }, where: 'product_id = 1' })\n        .findAll('product')\n        .create('product', { title: 'test' })\n        .findOne('product', { where: 'product_id = 1' })\n        .delete('product', { where: 'product_id = 2' })\n        .executeQuery();\n    \n    console.log(result);\n} catch (error) {\n    console.error('Error executing query chain:', error);\n}\n```\n\n---\n\n### **5. Closing the Connection**\n\nIt's important to close the database connection once all queries are executed to free up resources.\n\n```javascript\nawait db.close();\n```\n\n---\n\n### **6. Example Output**\n\nOnce the queries are executed successfully, you should see an output similar to this:\n\n```plaintext\nDatabase connected successfully\nMultiple queries executed successfully: [/* Array of results from each query */]\n```\n\n---\n"
    },
    {
      "id": 25,
      "path": "api-reference/crud/create",
      "name": "Create",
      "folder": "API Reference/Crud",
      "content": "### API Reference for `create` Method\n\nThis reference explains the usage of the `create` method, which is used to insert new records into a table or model.\n\n---\n\n### **`create` Method**\n\n#### **Method Signature**\n\n```typescript\npublic create<tables extends string[]>(table: string, values: CreateParamsType<[]>, options?: CreateOptionsType): MySQLHandler;\npublic create<tables extends string[]>(model: typeof Model, values: CreateParamsType<[]>, options?: CreateOptionsType): Promise<ResponseType>;\npublic create(...args: any): MySQLHandler | Promise<ResponseType>;\n```\n\n#### **Description**\n\nThe `create` method is used to insert new records into a table or model. The method supports both direct table insertion and ORM-based model insertion. It takes the values to be inserted and options that define the insertion behavior.\n\n---\n\n### **Parameters**\n\n1. **`table`** (required)  \n   - Type: `string`  \n   - Description: The name of the table into which the record will be inserted.  \n   - Example: `\"users\"`, `\"products\"`\n\n2. **`model`** (required for Model-based queries)  \n   - Type: `typeof Model`  \n   - Description: The model class (e.g., `User`, `Product`) if you prefer querying through the ORM model rather than using the table name directly.  \n   - Example: `User`, `Product`\n\n3. **`values`** (required)  \n   - Type: `CreateParamsType<[]>`  \n   - Description: The values to be inserted into the table or model.  \n   - Example:\n\n     ```typescript\n     {\n       name: \"John\",\n       age: 30,\n       email: \"john@example.com\"\n     }\n     ```\n\n4. **`options`** (optional)  \n   - Type: `CreateOptionsType`  \n   - Description: Options that define the behavior of the insertion (e.g., `engine`, `charset`, `collation`, `auto_increment`).  \n   - Example:\n\n     ```typescript\n     {\n       engine: \"InnoDB\",\n       charset: \"utf8mb4\",\n       collation: \"utf8mb4_unicode_ci\",\n       auto_increment: 100\n     }\n     ```\n\n---\n\n### **Response**\n\n- **When a table name is provided**:  \n  - Returns an instance of `MySQLHandler`, which is the query builder.\n  \n- **When a model class is provided**:  \n  - Returns a `Promise<ResponseType>` with the result of the insert operation executed on the database.\n\n---\n\n### **Details of `CreateParamsType` and `CreateOptionsType`**\n\n```typescript\nexport type CreateParamsType<Tables extends string[]> = {\n    // Define the fields and their values for inserting new records.\n    [key: string]: string | number | boolean | null;\n}\n\nexport type CreateOptionsType = {\n    engine?: Engine;        // Optional: Defines the storage engine (e.g., \"InnoDB\")\n    charset?: Charset;      // Optional: Defines the character set (e.g., \"utf8mb4\")\n    collation?: Collation;  // Optional: Defines the collation (e.g., \"utf8mb4_unicode_ci\")\n    auto_increment?: number; // Optional: Defines the auto-increment value for the primary key\n};\n```\n\n- **`CreateParamsType`**: This defines the fields and their values that will be inserted into the table. It can include basic types like strings, numbers, booleans, or `null`.\n\n- **`CreateOptionsType`**: This defines additional options for the creation operation, such as the database engine, charset, collation, and auto-increment values for primary keys.\n\n---\n\n### **Examples**\n\n#### Example 1: Inserting a record using a table name\n\n```typescript\nconst query = create('users', {\n    name: \"John\",\n    age: 30,\n    email: \"john@example.com\"\n}, {\n    engine: \"InnoDB\",\n    charset: \"utf8mb4\",\n    collation: \"utf8mb4_unicode_ci\"\n});\nconsole.log(query);  // The resulting INSERT SQL query string\n```\n\n#### Example 2: Inserting a record using a model\n\n```typescript\nconst result = await User.create({\n    name: \"John\",\n    age: 30,\n    email: \"john@example.com\"\n}, {\n    engine: \"InnoDB\",\n    charset: \"utf8mb4\",\n    collation: \"utf8mb4_unicode_ci\"\n});\nconsole.log(result);  // Result of the insert operation\n```\n\n---\n\n### **Errors**\n\n- **Missing arguments**: If no arguments are provided or if the arguments are invalid, an error will be thrown.\n  \n  Example:\n\n  ```typescript\n  // Missing table name or model\n  create();\n  // Error: No arguments provided to 'create'. Expected a table name and/or values.\n  ```\n\n- **Invalid first argument**: The first argument must be either a table name (string) or a model class.\n\n  Example:\n\n  ```typescript\n  // Invalid argument type\n  create(123, { name: \"John\", age: 30 });\n  // Error: Invalid first argument: must be a table name or a Model class.\n  ```\n\n- **Invalid values**: If `values` is not provided or is not an object, an error will be thrown.\n\n  Example:\n\n  ```typescript\n  // Invalid values\n  create('users', \"name: John\");\n  // Error: Values must be a non-empty object.\n  ```\n\n---\n\n### **Internal Methods**\n\n- **`insertInto` function**: This function constructs the actual SQL `INSERT` query based on the provided parameters.\n- **`runHooks` function**: If applicable, this can run hooks like `beforeCreate` before executing the insert operation.\n\n---\n\n### **Use Case**\n\nUse the `create` method when you need to insert new records into a table, either directly by specifying the table name or via ORM model classes. You can include additional options such as `charset`, `collation`, and `auto_increment` for advanced table configurations. This method ensures that the insertion operation is performed correctly with the provided data.\n"
    },
    {
      "id": 26,
      "path": "api-reference/crud/delete",
      "name": "Delete",
      "folder": "API Reference/Crud",
      "content": "### API Reference for `delete` Method\n\nThis reference provides detailed information on how to use the `delete` method in both Model and DBHandler, including parameters, response, examples, and possible errors.\n\n---\n\n### **`delete` Method**\n\n#### **Method Signature**\n\n```typescript\npublic delete<tables extends string[]>(table: string, Props: DeleteParamsType<tables>): MySQLHandler;\npublic delete<tables extends string[]>(model: typeof Model, Props: DeleteParamsType<tables>): Promise<ResponseType>;\npublic delete(...args: any): MySQLHandler | Promise<ResponseType>;\n```\n\n#### **Description**\n\nThe `delete` method is used to delete records from a table or model based on the provided conditions. It can be used either by passing a table name directly or by querying a model class.\n\n---\n\n### **Parameters**\n\n1. **`table`** (required)  \n   - Type: `string`  \n   - Description: The name of the table from which records will be deleted.  \n   - Example: `\"users\"`, `\"orders\"`\n\n2. **`model`** (required for Model-based queries)  \n   - Type: `typeof Model`  \n   - Description: A model class (e.g., `User`, `Product`) if you prefer querying through the ORM model rather than using the table name directly.  \n   - Example: `User`, `Product`\n\n3. **`Props`** (required)  \n   - Type: `DeleteParamsType<tables>`  \n   - Description: An object that defines the parameters for the delete operation.  \n   - Example:\n\n     ```typescript\n     {\n       where: \"age > 25\",\n       sort: { name: \"ASC\" },\n       limit: 10,\n       joins: { table: \"address\", on: \"users.id = address.user_id\" }\n     }\n     ```\n\n---\n\n### **Response**\n\n- **When a table name is provided**:  \n  - Returns an instance of `MySQLHandler`, which is the query builder.\n  \n- **When a model class is provided**:  \n  - Returns a `Promise<ResponseType>` with the result of the delete operation executed on the database.\n\n---\n\n### **Details of `DeleteParamsType`**\n\n```typescript\nexport interface DeleteParamsType<Tables extends string[]> {\n    where: string; // The condition to identify which rows to delete\n    sort?: SortType<Tables>; // Optional: Sorting options for the query\n    limit?: string | number; // Optional: Limit the number of deleted records\n    joins?: JoinsType<Tables>; // Optional: Join conditions for the delete query\n}\n```\n\n- **`where`**: The condition that specifies which rows should be deleted (e.g., `\"age > 30\"`).\n- **`sort`**: Sorting criteria for the query (e.g., `{ name: \"ASC\" }`).\n- **`limit`**: Limits the number of records to delete (e.g., `10`).\n- **`joins`**: Define join conditions if the delete query involves joining other tables.\n\n---\n\n### **Examples**\n\n#### Example 1: Deleting records using a table name\n\n```typescript\nconst query = dbHandler.delete('users', {\n    where: 'age > 30',\n    sort: { name: 'ASC' },\n    limit: 10,\n    joins: { table: 'orders', on: 'users.id = orders.user_id' }\n});\nconsole.log(query);  // The resulting DELETE SQL query string\n```\n\n#### Example 2: Deleting records using a model\n\n```typescript\nconst result = await User.delete({\n    where: 'age > 30',\n    sort: { name: 'ASC' },\n    limit: 10\n});\nconsole.log(result);  // Result of the delete operation\n```\n\n---\n\n### **Errors**\n\n- **Missing arguments**: If no arguments are provided or if the arguments are invalid, an error will be thrown.\n  \n  Example:\n\n  ```typescript\n  // Missing table name or model\n  delete();\n  // Error: No arguments provided to 'delete'. Expected a table name or model.\n  ```\n\n- **Invalid first argument**: The first argument must be either a table name (string) or a model class.\n\n  Example:\n\n  ```typescript\n  // Invalid argument type\n  delete(123, { where: \"age > 30\" });\n  // Error: Invalid first argument: must be a table name or a Model class.\n  ```\n\n- **Props must be a non-empty object**: If `Props` is not provided or is not an object, an error will be thrown.\n\n  Example:\n\n  ```typescript\n  // Invalid props\n  delete('users', \"where: age > 30\");\n  // Error: Props must be a non-empty object.\n  ```\n\n---\n\n### **Internal Methods**\n\n- **`destroy` function**: This is used to construct the actual DELETE SQL query.\n- **`parseJoins` function**: Handles parsing and formatting the `joins` parameter into SQL JOIN clauses.\n- **`parseSort` function**: Handles parsing and formatting the `sort` parameter into SQL ORDER BY clauses.\n\n---\n\n### **Use Case**\n\nUse the `delete` method when you want to delete records from a table with specific conditions such as filtering, sorting, and limiting the number of records to be deleted. It can be used with both direct table names or ORM-based models.\n"
    },
    {
      "id": 27,
      "path": "api-reference/crud/find",
      "name": "Find",
      "folder": "API Reference/Crud",
      "content": "\n---\n\nThis API offers methods to query and retrieve records from the database. You can find a single record or multiple records with advanced filtering, sorting, and aggregation capabilities.\n\n---\n\n### **1. `findAll` Method**\n\n#### **Method Signature**\n\n```typescript\npublic findAll<tables extends string[]>(table: string, config?: FindAllParamsType<tables>): MySQLHandler;\npublic findAll<tables extends string[]>(model: typeof Model, config?: FindAllParamsType<tables>): Promise<ResponseType>;\n```\n\n#### **Parameters:**\n\n- **`table`** (`string`):\n  - The name of the table to query.\n  - Alternatively, you can pass a `Model` class.\n  \n- **`config`** (`FindAllParamsType<tables>`):\n  - Optional configuration for querying the table.\n  - **Possible options:**\n    - `distinct`: If true, returns distinct rows.\n    - `sort`: Sorting configuration, defined using `SortType`.\n    - `limitSkip`: Pagination options (`limit` and `skip` values).\n    - `columns`: Columns to select (can be specified per table).\n    - `groupBy`: Columns to group by.\n    - `aggregates`: Array of aggregate functions (e.g., `MIN`, `MAX`).\n    - `where`: `WHERE` clause condition.\n    - `having`: `HAVING` clause condition.\n    - `subQueries`: List of subqueries.\n    - `joins`: Table joins, defined using `JoinsType`.\n    - `recursiveCTE`: Recursive common table expressions.\n\n#### **Returns:**\n\n- **`MySQLHandler`**: If a `table` name is provided, the query handler is returned to build and execute the query.\n- **`Promise<ResponseType>`**: If a `Model` class is provided, the query is executed, and a `Promise` with the response is returned.\n\n#### **Example:**\n\n```typescript\nconst results = await findAll('users', {\n  sort: { name: 1 },\n  limitSkip: { limit: 10, skip: 0 },\n  columns: ['name', 'email'],\n  where: 'status = \"active\"',\n});\n```\n\n---\n\n### **2. `findOne` Method**\n\n#### **Method Signature**\n\n```typescript\npublic findOne<tables extends string[]>(table: string, config?: FindOneParamsType<tables>): MySQLHandler;\npublic findOne<tables extends string[]>(model: typeof Model, config?: FindOneParamsType<tables>): Promise<ResponseType>;\n```\n\n#### **Parameters:**\n\n- **`table`** (`string`):\n  - The name of the table to query.\n  - Alternatively, you can pass a `Model` class.\n  \n- **`config`** (`FindOneParamsType<tables>`):\n  - Optional configuration for querying the table.\n  - **Possible options:**\n    - `distinct`: If true, returns distinct rows.\n    - `sort`: Sorting configuration, defined using `SortType`.\n    - `columns`: Columns to select (can be specified per table).\n    - `groupBy`: Columns to group by.\n    - `aggregates`: Array of aggregate functions.\n    - `where`: `WHERE` clause condition.\n    - `having`: `HAVING` clause condition.\n    - `subQueries`: List of subqueries.\n    - `joins`: Table joins, defined using `JoinsType`.\n    - `recursiveCTE`: Recursive common table expressions.\n\n#### **Returns:**\n\n- **`MySQLHandler`**: If a `table` name is provided, the query handler is returned to build and execute the query.\n- **`Promise<ResponseType>`**: If a `Model` class is provided, the query is executed, and a `Promise` with the response is returned.\n\n#### **Example:**\n\n```typescript\nconst user = await findOne('users', {\n  where: 'id = 1',\n  columns: ['id', 'name', 'email'],\n});\n```\n\n---\n\n### **3. `JoinsType`**\n\nDefines the different types of joins that can be used in the query.\n\n```typescript\nexport type JoinsType<Tables extends string[]> = Array<{\n    operator?: OperatorType | string,\n    type?: 'JOIN' | 'INNER JOIN' | 'OUTER JOIN' | 'CROSS JOIN' | 'RIGHT JOIN' | 'LEFT JOIN';\n} | {\n    on?: string, table?: string\n} | {\n    [key: string]: string\n} | {\n    [P in Tables[number]]?: string\n}>\n```\n\n#### **Usage:**\n\nYou can define how to join tables, specify the join type (e.g., `LEFT JOIN`), and use operators (e.g., `=` or `IN`).\n\n#### **Example:**\n\n```typescript\nconst results = await findAll('users', {\n  joins: [\n    { type: 'INNER JOIN', table: 'profiles', on: 'users.id = profiles.user_id' },\n  ],\n});\n```\n\n---\n\n### **4. `SortType`**\n\nDefines how the results should be sorted.\n\n```typescript\nexport type SortType<Tables extends string[]> = { [P in Tables[number]]?: Record<string, 1 | -1> } | Record<string, 1 | -1> | string;\n```\n\n#### **Usage:**\n\nYou can sort the results based on one or more columns.\n\n- `1` indicates ascending order.\n- `-1` indicates descending order.\n\n#### **Example:**\n\n```typescript\nconst sortedResults = await findAll('products', {\n  sort: { price: -1 }, // Sort by price in descending order\n});\n```\n\n---\n\n### **5. `OperatorType`**\n\nDefines the different operators that can be used in the query conditions.\n\n```typescript\nexport type OperatorType =\n    | '='    // Equality\n    | '!='   // Not equal\n    | '<>'   // Not equal (alternate syntax)\n    | '<'    // Less than\n    | '>'    // Greater than\n    | '<='   // Less than or equal\n    | '>='   // Greater than or equal\n    | 'LIKE' // Pattern matching\n    | 'IN'   // Check if value exists in a set\n    | 'BETWEEN'; // Range condition\n```\n\n#### **Usage:**\n\nYou can use these operators in the `where` condition to define filters on the data.\n\n#### **Example:**\n\n```typescript\nconst results = await findAll('orders', {\n  where: 'totalAmount > 100 AND status = \"completed\"',\n  operator: 'IN',\n});\n```\n\n---\n\n### **6. `FindOneParamsType` Interface**\n\nThe configuration object for a single query to find one record.\n\n```typescript\nexport interface FindOneParamsType<Tables extends string[]> {\n    distinct?: boolean;\n    sort?: SortType<Tables>;\n    columns?: { [P in Tables[number]]?: string[] } | string | string[];\n    groupBy?: { [P in Tables[number]]?: string[] } | string | string[];\n    aggregates?: Array<{ [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string }>;\n    where?: string;\n    having?: string;\n    subQueries?: { query: string, as?: string }[];\n    joins?: JoinsType<Tables>;\n    recursiveCTE?: { baseCase: string, recursiveCase: string, alias: string };\n}\n```\n\n#### **Usage:**\n\nThis is used to pass query options for the `findOne` operation. You can filter data, sort, group, and more.\n\n---\n\n### **7. `FindAllParamsType` Interface**\n\nThe configuration object for a query to find multiple records.\n\n```typescript\nexport interface FindAllParamsType<Tables extends string[]> {\n    distinct?: boolean;\n    sort?: SortType<Tables>;\n    limitSkip?: { limit?: number; skip?: number };\n    columns?: { [P in Tables[number]]?: string[] } | string | string[];\n    groupBy?: { [P in Tables[number]]?: string[] } | string | string[];\n    aggregates?: Array<{ [K in keyof Record<'MIN' | 'MAX' | 'SUM' | 'COUNT' | 'AVG', string>]?: string }>;\n    where?: string;\n    having?: string;\n    subQueries?: { query: string, as?: string }[];\n    joins?: JoinsType<Tables>;\n    recursiveCTE?: { baseCase: string, recursiveCase: string, alias: string };\n}\n```\n\n#### **Usage:**\n\nThis is used to pass query options for the `findAll` operation. You can control the results using filtering, sorting, pagination, and more.\n\n---\n\n### **Conclusion**\n\nWith the `find` API, you can easily query the database to fetch single or multiple records, with flexible configurations for sorting, filtering, grouping, and joining tables. This API is highly customizable to suit various database query requirements, giving you full control over how the data is retrieved.\n\n---\n"
    },
    {
      "id": 28,
      "path": "api-reference/crud/update",
      "name": "Update",
      "folder": "API Reference/Crud",
      "content": "### API Reference for `update` Method\n\nThis reference explains the usage of the `update` method, including parameters, response, examples, and possible errors.\n\n---\n\n### **`update` Method**\n\n#### **Method Signature**\n\n```typescript\npublic update<tables extends string[]>(table: string, Props: UpdateParamsType<tables>): MySQLHandler;\npublic update<tables extends string[]>(model: typeof Model, Props: UpdateParamsType<tables>): Promise<ResponseType>;\npublic update(...args: any): MySQLHandler | Promise<ResponseType>;\n```\n\n#### **Description**\n\nThe `update` method is used to update existing records in a table or model. The update is performed based on the conditions provided in the parameters. You can specify fields to update, conditions to match, sorting, and other query modifiers.\n\n---\n\n### **Parameters**\n\n1. **`table`** (required)  \n   - Type: `string`  \n   - Description: The name of the table where records will be updated.  \n   - Example: `\"users\"`, `\"products\"`\n\n2. **`model`** (required for Model-based queries)  \n   - Type: `typeof Model`  \n   - Description: The model class (e.g., `User`, `Product`) if you prefer querying through the ORM model rather than using the table name directly.  \n   - Example: `User`, `Product`\n\n3. **`Props`** (required)  \n   - Type: `UpdateParamsType<tables>`  \n   - Description: The parameters for the update operation, including columns to update, conditions, sorting, and other options.  \n   - Example:\n\n     ```typescript\n     {\n       values: { \n         age: 30, \n         name: \"John\" \n       },\n       where: \"id = 5\",\n       sort: { name: \"ASC\" },\n       limit: 10,\n       joins: { table: \"orders\", on: \"users.id = orders.user_id\" }\n     }\n     ```\n\n---\n\n### **Response**\n\n- **When a table name is provided**:  \n  - Returns an instance of `MySQLHandler`, which is the query builder.\n  \n- **When a model class is provided**:  \n  - Returns a `Promise<ResponseType>` with the result of the update operation executed on the database.\n\n---\n\n### **Details of `UpdateParamsType`**\n\n```typescript\nexport type UpdateParamsType<Tables extends string[]> = {\n    values?: { // The data to update\n        [key: string]: string | number | null | { \n            case: { \n                when: string;  // The condition in the WHEN clause\n                then: any;     // The value to set in the THEN clause\n            }[];  // The CASE structure with an array of WHEN/THEN conditions\n            default: any;  // The default value for the column when no conditions match\n        };\n    },\n    sort?: { [P in Tables[number]]?: Record<string, 1 | -1> } | Record<string, 1 | -1> | string,\n    where: string,   // The condition to identify which rows to update\n    defaultValues?: string[], // Optional: Columns to set to default values\n    limit?: string | number,  // Optional: Limits the number of records to update\n    joins?: JoinsType<Tables>, // Optional: Join conditions for the update query\n    fromSubQuery?: Record<string, string>, // Optional: Subqueries for the update operation\n    setCalculations?: { // For SET calculation\n        [key: string]: string; // Expressions to calculate new values\n    }\n}\n```\n\n- **`values`**: Specifies the columns to be updated. It can include:\n  - Direct values (e.g., `{ age: 30, name: \"John\" }`).\n  - Complex `CASE` structures with conditions and default values.\n\n- **`sort`**: Sorting options for the query (e.g., `{ name: \"ASC\" }`).\n\n- **`where`**: The condition for selecting the rows to be updated (e.g., `\"id = 5\"`).\n\n- **`defaultValues`**: Columns to be set to their default values.\n\n- **`limit`**: Limits the number of records to update.\n\n- **`joins`**: Specifies join conditions if the update operation involves multiple tables.\n\n- **`fromSubQuery`**: Allows the use of a subquery for the update operation.\n\n- **`setCalculations`**: Allows you to specify calculations to set the new values (e.g., `{ total_price: \"quantity * unit_price\" }`).\n\n---\n\n### **Examples**\n\n#### Example 1: Updating records using a table name\n\n```typescript\nconst query = update('users', {\n    values: { age: 30, name: \"John\" },\n    where: \"id = 5\",\n    sort: { name: \"ASC\" },\n    limit: 10,\n    joins: { table: \"orders\", on: \"users.id = orders.user_id\" }\n});\nconsole.log(query);  // The resulting UPDATE SQL query string\n```\n\n#### Example 2: Updating records using a model\n\n```typescript\nconst result = await User.update({\n    values: { age: 30, name: \"John\" },\n    where: \"id = 5\",\n    sort: { name: \"ASC\" },\n    limit: 10\n});\nconsole.log(result);  // Result of the update operation\n```\n\n---\n\n### **Errors**\n\n- **Missing arguments**: If no arguments are provided or if the arguments are invalid, an error will be thrown.\n  \n  Example:\n\n  ```typescript\n  // Missing table name or model\n  update();\n  // Error: No arguments provided to 'update'. Expected a table name or model.\n  ```\n\n- **Invalid first argument**: The first argument must be either a table name (string) or a model class.\n\n  Example:\n\n  ```typescript\n  // Invalid argument type\n  update(123, { where: \"id = 5\" });\n  // Error: Invalid first argument: must be a table name or a Model class.\n  ```\n\n- **Props must be a non-empty object**: If `Props` is not provided or is not an object, an error will be thrown.\n\n  Example:\n\n  ```typescript\n  // Invalid props\n  update('users', \"where: id = 5\");\n  // Error: Props must be a non-empty object.\n  ```\n\n---\n\n### **Internal Methods**\n\n- **`update` function**: This function constructs the actual SQL `UPDATE` query based on the provided parameters.\n- **`parseJoins` function**: Parses and formats the `joins` parameter into SQL JOIN clauses.\n- **`parseSort` function**: Parses and formats the `sort` parameter into SQL ORDER BY clauses.\n\n---\n\n### **Use Case**\n\nUse the `update` method when you need to modify existing records in a table, with various conditions and sorting. It can be used with both direct table names or ORM-based models. This method supports advanced features like `CASE` expressions, sorting, joining multiple tables, and limiting the number of records affected.\n"
    }
  ]
}